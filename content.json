{"meta":{"title":"DayDream","subtitle":null,"description":null,"author":"断梦三生","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-08-26T14:44:03.238Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"聊会儿天？ 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-10-25T12:59:37.500Z","comments":false,"path":"book/index.html","permalink":"/book/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-08-28T03:15:50.367Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-09-26T02:45:19.287Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"2019——2020 最近常听~ 2018 2016——2017 2013——2015 Sun Cloud 一事无成 永恒废青 Rain Storm","keywords":"音乐盒"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-09-26T02:39:47.021Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"修改自Sakura主题hexo提供博客渲染支持","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"leetcode 98 验证二叉搜索树","slug":"leetcode97","date":"2020-11-04T08:04:10.548Z","updated":"2020-11-04T08:10:29.803Z","comments":true,"path":"2020/11/04/leetcode97/","link":"","permalink":"/2020/11/04/leetcode97/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 思路：二叉搜索树即为：中序遍历结果为升序的树这里采用非递归遍历 class Solution { public: int pre = 0; int cur = 0; int counter = 0; stack&lt;TreeNode*&gt; S; bool isValidBST(TreeNode* root) { TreeNode* p = root; while(!S.empty() || p) { while(p) { S.push(p); p = p-&gt;left; } pre = cur; p = S.top(); cur = p-&gt;val; if(counter) { if(pre &gt;= cur) return false; } ++counter; S.pop(); p = p-&gt;right; } return true; } };","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}],"tags":[{"name":"编程","slug":"编程","permalink":"/tags/编程/"},{"name":"C++","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}]},{"title":"leetcode 96 不同的二叉搜索树","slug":"leetcode96","date":"2020-11-03T07:33:47.547Z","updated":"2020-11-04T08:08:25.683Z","comments":true,"path":"2020/11/03/leetcode96/","link":"","permalink":"/2020/11/03/leetcode96/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述：给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例:-输入：3-输出：5-解释：-以下 5 种不同结构的二叉搜索树：- 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 简单动规。设dp[n]存储着n个结点共能组成多少不同的树。以n = 5为例：5个结点标记为1~5，取i号结点为根，则其左右子树分别有i-1、 5-i个结点。则共能生成dp[i-1] * dp[5-i]个结点 dp[5] = dp[0] dp[4] + dp[1] dp[3] + dp[2] dp[2] + dp[3] dp[1] + dp[4] * dp[0] class Solution { public: int numTrees(int n) { int * dp = new int[100]; dp[0] = 1; dp[1] = 1; for(int i = 2; i &lt;= n; ++i) { int sum = 0; for(int j = 1; j &lt;= i; ++j) { sum += dp[j - 1] * dp[i - j]; } dp[i] = sum; } int ans = dp[n]; delete []dp; return ans; } };","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}],"tags":[{"name":"编程","slug":"编程","permalink":"/tags/编程/"},{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"动态规划","slug":"动态规划","permalink":"/tags/动态规划/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}]},{"title":"鱼书笔记 第四章 神经网络的学习","slug":"鱼书笔记 第四章 神经网络的学习","date":"2020-11-03T02:30:00.000Z","updated":"2020-11-04T07:09:31.310Z","comments":true,"path":"2020/11/03/鱼书笔记 第四章 神经网络的学习/","link":"","permalink":"/2020/11/03/鱼书笔记 第四章 神经网络的学习/","excerpt":"","text":"这里的“学习”是指从训练数据中自动获取最优权重参数的过程。 4.1 从数据中学习4.1.1 数据驱动如何从图片中识别“5”呢？如图4.2所示。机器学习领域，特征量仍是人工设计的，而深度学习中，特征量也是由机器来学习 tip:深度学习有时也被称为端到端机器学习（end-to-end machine learning）。这里的“端到端”指的是从原始数据（输入）到目标结果（输出）。而中间过程究竟使用了怎样的权重、怎样的神经网络、外界是无从得知的。 神经网络的优点是对所有的问题都可以用同样的流程来解决。无论是识别“5”、还是识别狗、识别人脸，均使用同样的模式。 4.1.2 训练数据和测试数据机器学习中，一般将数据分为训练数据和测试数据两部分。先利用训练数据来训练出模型、再用测试数据来评价训练得来的模型的实际能力。 训练数据也被称为“监督数据” 泛化能力: 处理未被观察过的数据（即训练集之外数据）的能力。 获得泛化能力是机器学习的最终目标 过拟合（over fitting）： 没有泛化能力，仅仅对某个数据集过度拟合的状态 4.2 损失函数损失函数（loss function）: 用于评价神经网络性能的指标。 4.2.1 均方误差均方误差（mean squared error） E=\\frac{1}{2}\\sum_{i=0} (y_{k}-x_{k})^2这里, y_{k} 表示神经网络的输出，t_{k}表示监督数据，k表示数据的维数。比如：在3.6节手写数字识别的例子中， y_{k} 和t_{k}是如下元素组成的数据 y = [0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0] t = [0, 0, 1, 0, 0, 0, 0, 0, 0, 0] y表示各种数字的概率t表示正确答案。这种将正确解标签表示为1，其他标签表示为0的方法称为one-hot表示。 python实现： import numpy as np def mean_squared_error(y, t): return 0.5 * np.sum((y - t)**2) t = [0, 0, 1, 0, 0, 0, 0, 0, 0, 0] # 例：&quot;2&quot;的概率最高的情况 y = [0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0] # 例：“7”的概率最高的情况 print(mean_squared_error(np.array(y), np.array(t))) # 输出为0.09750000000000003 y = [0.1, 0.05, 0.2, 0.0, 0.05, 0.1, 0.0, 0.6, 0.0, 0.0] print(mean_squared_error(np.array(y), np.array(t))) # 输出为0.5125000000000001 显然， 第二组数据误差很大 4.2.2 交叉熵误差交叉熵误差（cross entropy）也经常被用作损失函数 E=-\\sum_{k}t_{k}log y_{k}*更新中 最后更新于2020/10/3*","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"深度学习","slug":"编程/深度学习","permalink":"/categories/编程/深度学习/"},{"name":"鱼书笔记","slug":"编程/深度学习/鱼书笔记","permalink":"/categories/编程/深度学习/鱼书笔记/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"深度学习","slug":"编程/深度学习","permalink":"/categories/编程/深度学习/"},{"name":"鱼书笔记","slug":"编程/深度学习/鱼书笔记","permalink":"/categories/编程/深度学习/鱼书笔记/"}]},{"title":"leetcode 95 不同的二叉搜索树 Ⅱ","slug":"leetcode95","date":"2020-11-02T11:00:56.128Z","updated":"2020-11-04T07:06:52.313Z","comments":true,"path":"2020/11/02/leetcode95/","link":"","permalink":"/2020/11/02/leetcode95/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。 示例:-输入：3-输出：-[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]-]-解释：-以上的输出对应以下 5 种不同结构的二叉搜索树：- 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 提示：0 &lt;= n &lt;= 8 这里采用的是官方思路 class Solution { public: vector&lt;TreeNode*&gt; generateTrees(int left, int right) { vector&lt;TreeNode *&gt; ans; if(left &gt; right) { ans.push_back(NULL); return ans; }//注意这里push NULL !! 因为左右子树都有可能是空指针 vector&lt;TreeNode*&gt; leftTrees; vector&lt;TreeNode*&gt; rightTrees; for(int i = left; i &lt;= right; ++i) { leftTrees = generateTrees(left, i-1); rightTrees = generateTrees(i + 1, right); for(int j = 0; j &lt; leftTrees.size(); ++j) { for(int k = 0; k &lt; rightTrees.size(); ++k) { TreeNode * root = new TreeNode(i); root -&gt; left = leftTrees[j]; root -&gt; right = rightTrees[k]; ans.push_back(root); } } } return ans; } vector&lt;TreeNode*&gt; generateTrees(int n) { if(n &lt; 1) return vector&lt;TreeNode*&gt;(); vector&lt;TreeNode *&gt; ans = generateTrees(1, n); return ans; } };","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}],"tags":[{"name":"编程","slug":"编程","permalink":"/tags/编程/"},{"name":"C++","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}]},{"title":"leetcode 93 复原IP地址","slug":"leetcode93","date":"2020-10-26T13:10:00.000Z","updated":"2020-10-26T13:18:18.777Z","comments":true,"path":"2020/10/26/leetcode93/","link":"","permalink":"/2020/10/26/leetcode93/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述： 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。 示例1： 输入：s = “25525511135” 输出：[“255.255.11.135”,”255.255.111.35”] 示例2： 输入：s = “0000” 输出：[“0.0.0.0”] 标准DFS 不过第一次提交没有剪枝，导致超时，记录一下 class Solution { public: vector&lt;string&gt; ans; string ans_; vector&lt;string&gt; tmp; vector&lt;string&gt; restoreIpAddresses(string s) { solve(s, 0); return ans; } int solve(string &amp; s, int start) { if(tmp.size() &gt; 4)//注意这里的剪枝！！！否则当数据过长会超时 return 0; if(start == s.size()) { if(tmp.size() == 4) { ans_.clear(); ans_+=tmp[0]; for(int i = 1;i &lt; 4; ++i) { ans_ += &quot;.&quot;; ans_+= tmp[i]; } ans.push_back(ans_); } return 0; } for(int i = 1; i &lt; 4; ++i)//i为长度 { if((s[start] == &#39;0&#39;)&amp;&amp; (i &gt; 1)) { break; } if(start + i &gt; s.size()) break; string a(s.begin() + start, s.begin() + start + i); if((a &gt; &quot;255&quot;)&amp;&amp;(i == 3)) break; tmp.push_back(a); solve(s, start + i); tmp.pop_back(); } return 0; } };","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}],"tags":[{"name":"编程","slug":"编程","permalink":"/tags/编程/"},{"name":"C++","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}]},{"title":"leetcode 94 二叉树中序遍历","slug":"leetcode94","date":"2020-10-26T12:02:00.000Z","updated":"2020-10-26T14:18:50.795Z","comments":true,"path":"2020/10/26/leetcode94/","link":"","permalink":"/2020/10/26/leetcode94/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述：给定一个二叉树，返回它的中序 遍历。 示例: 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] 递归很简单，这里采用堆栈代替递归 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: stack&lt;TreeNode*&gt; S; vector&lt;int&gt; inorderTraversal(TreeNode* root) { TreeNode* t = root; vector&lt;int&gt; ans; while((t)||!S.empty()) { while(t) { S.push(t); t = t-&gt;left; } /* if(!S.empty())//******************* { t = S.top(); S.pop(); ans.push_back(t-&gt;val); t = t-&gt;right; } } */ t = S.top(); S.pop(); ans.push_back(t-&gt;val); t = t-&gt;right; return ans; } }; 注意注释掉的部分： 在浙大陈越数据结构课中，有一步 if(!S.empty())的判定…我在应用时发现这其实是废操作","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}],"tags":[{"name":"编程","slug":"编程","permalink":"/tags/编程/"},{"name":"C++","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}]},{"title":"单链表合辑","slug":"链表基本操作","date":"2020-10-22T14:13:03.072Z","updated":"2020-10-23T02:48:45.642Z","comments":true,"path":"2020/10/22/链表基本操作/","link":"","permalink":"/2020/10/22/链表基本操作/","excerpt":"","text":"链表的定义：/** Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} };*/ 1、交换元素以交换单链表中第m和n号结点为例。以头节点为第一个结点，保证m&gt;n，且m、n均小于链表长度。做法是将待交换的两结点的前驱及自身地址记录下来，然后逐个交换。 需要考虑的特殊情况： 可能涉及到头节点。这里的处理是建立一个哨兵 可能待交换的结点是紧挨着的,这样就不可以简单地交换了，这里进行了特判 class Solution { public: ListNode* swapNode(ListNode* head, int m, int n) { ListNode* headTmp = new ListNode(1); headTmp-&gt;next = head; ListNode* pre1 = NULL; ListNode* lat1 = NULL; ListNode* pre2 = NULL; ListNode* lat2 = NULL; int counter = 0; ListNode* p = headTmp; while(p &amp;&amp; (counter &lt;= n)) { if(counter == m-1) pre1 = p; if(counter == m) lat1 = p; if(counter == n-1) pre2 = p; if(counter == n) lat2 = p; ++counter; p = p-&gt;next; } ListNode* tmp = lat1-&gt;next; lat1-&gt;next = lat2-&gt;next; pre1-&gt;next = lat2; if(n == m+1)//结点紧挨着的情况 { lat2-&gt;next = lat1; } else { pre2-&gt;next = lat1; lat2-&gt;next = tmp; } ListNode* newHead = headTmp-&gt;next; delete headTmp; return newHead; } }; 2、链表反转反转从位置 m 到 n 的链表。使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。示例： 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 大体思路：采用三指针，前两个指针用于反转，后一个指针用于记录next的值 注意：反转如果涉及到头或尾节点需要特殊处理. class Solution { public: ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* headTmp = new ListNode(1); headTmp-&gt;next = head;//设置哨兵 ListNode *pre = NULL; ListNode *rear = NULL; ListNode *p = headTmp; int counter = 0; while(p &amp;&amp; (counter + 1 &lt; m)) { ++counter; p = p-&gt;next; }//循环后p指向反转部分的前驱(第m-1个结点) pre = p; p = p-&gt;next; rear = p;//反转部分的头部(第m个结点，也就是反转后的尾部) ++counter; ListNode *p1 = p-&gt;next, *p2; if(!p1)//m=n=链表长度，啥也不用做 { delete headTmp; return head; } p2 = p1-&gt;next; while(p2 &amp;&amp; (counter &lt; n))//交换第counter和第counter+1个结点 { p1-&gt;next = p; p = p1; p1 = p2; p2 = p2-&gt;next; counter++; }//p为第n个结点，p1为尾结点的后继 if(n &gt; counter ) { p1-&gt;next = p; p = p1; p1 = p2; } pre-&gt;next = p; rear-&gt;next = p1; ListNode* newhead = headTmp-&gt;next; delete headTmp; return newhead; } }; 下面是在leetcode上找到的比较优美的代码： 范例1：这个不需要特判，太舒服了。需要弄明白如何迭代（建议画画图）。 class Solution { public: ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* headTmp = new ListNode(1); headTmp-&gt;next = head; ListNode* pre = headTmp; int counter = 0; while(counter &lt; m - 1) { ++counter; pre = pre-&gt;next; }//pre定位到m-1的位置 ListNode* back = pre-&gt;next; while(counter &lt; n-1) { ListNode* front = back-&gt;next;//back-&gt;next指向反转部分的最后一个结点 back-&gt;next = front-&gt;next;//front-&gt;next是下一个反转的结点 front-&gt;next = pre-&gt;next;//pre-&gt;next指向反转之后、反转部分的尾结点 pre-&gt;next = front; ++counter; } return headTmp-&gt;next; } };","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C++","slug":"编程/C","permalink":"/categories/编程/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"/tags/编程/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"c++","slug":"c","permalink":"/tags/c/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C++","slug":"编程/C","permalink":"/categories/编程/C/"}]},{"title":"大二。","slug":"2020_10","date":"2020-10-20T10:55:00.000Z","updated":"2020-10-20T13:29:11.875Z","comments":true,"path":"2020/10/20/2020_10/","link":"","permalink":"/2020/10/20/2020_10/","excerpt":"","text":"刚上大学那会儿，姐姐跟我聊了几句。她没有老生常谈式地叮嘱我“好好学习”，她告诉我的反而是：“好好玩，我大学四年最后悔的事情是把时间全花在学习上了。该旅游旅游、该恋爱恋爱，毕业了可没这么好的时间了”。 姐姐本科毕业后就工作了，加班是常态。 姐姐蛮了解我，从小因为家里各种各样的原因，我比较内向比较自卑，大学所谓的多彩生活吧，我可能真的不太能体验。旅游、恋爱、聚餐、或者是各种爱好——我接触得越少越没办法破圈。多彩的大学生活到底和我有什么交集呢？ 现在我大二，准备着课设、期末、竞赛、力扣……不知不觉已经处在高校的内卷之中。身处“卷”中，焦虑会逼着我前进。但好像我真的不清楚这一切是为了什么 ...今天、代码敲的恶心的时候，我关上编译器就觉得自己蛮可怜的。对我来说，大学只是给未来工作做好铺垫，我没办法过上有趣的生活、找到交心的人。 我想问自己这条路真的是我选的吗。 写于10月20日傍晚 经信楼","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"音乐","slug":"音乐","permalink":"/tags/音乐/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"JLU C语言课设：医院管理系统 源码","slug":"C","date":"2020-10-16T13:36:35.005Z","updated":"2020-10-16T14:18:57.206Z","comments":true,"path":"2020/10/16/C/","link":"","permalink":"/2020/10/16/C/","excerpt":"","text":"实验说明：《程序设计基础课程设计》（2019级） 1、编写一个C语言程序，实现一个医院的诊疗管理系统，能够管理至少30位患者，每位患者至多30条诊疗记录。其中：1）每条诊疗记录包括患者信息、医生信息、诊疗情况三部分。请自行组织相关信息的存储方式（冗余信息可不存储）和显示格式。2）患者信息包括：姓名、年龄、挂号；挂号唯一。3）医生信息包括：姓名、级别、科室、工号、出诊时间；工号唯一；每位医生只在规定时间出诊（如每周一、周三，默认出诊即全天出诊）。4）诊疗情况分为3类信息：检查、开药、住院。对于检查，仅记录每种检查费用，以及所有检查的总费用；对于开药，仅记录每种药品名称、单价、数量，以及所有药品的总价；对于住院，仅记录住院开始日期、预计出院日期、住院押金。5）住院费用按实际天数计算。在办理住院时（即开始日期）需要交纳住院押金，住院押金要求为100元的整数倍，且不低于200*N（N为拟住院天数）元。特殊约定：在00:00-08:00之间办理出院不收取当天的住院费。对于拟继续住院的患者则系统会自动在08:00从患者的住院押金中扣除当天的住院费用，患者住院期间需随时保证住院押金一直不低于1000元。 为了简化，特做如下约定：1）如涉及时间，仅包括月、日、时、分（默认为当年）。2）患者最多100位，医生最多30位；药品最多30种，药品充足；患者每次开药最多100盒（或其它合适的数量单位）。3）医生的级别限定为：主任医师、副主任医师、主治医师、住院医师1，尽可能符合实际情况。医生仅隶属于某个科室。提醒：医生之间、患者之间、医生患者之间均可能重名。4）每天，医院可最多受理500个号，每位医生可最多受理20个号，每位患者可最多挂5个号、同一科室最多挂1个号；需自行设计挂号的编码规则，可隐含挂号日期、挂号当天的顺序号、对应的医生等信息，保证每条诊疗记录的挂号唯一。5）金额要精确到元、角、分，不允许有误差，最高额度不超过10万；最大数量不超过int允许最大整数。 具体功能要求如下：0）开始时，管理系统默认医院的运营资金为0元。1）【增加】能够从文件中录入多条诊疗记录，也能够随时录入1条诊疗记录。注意：需要考虑各种类型的不规范、不合理或错误数据，如：数据位数不对、格式不对等。【重点考察】2）【修改】能够随时修改1条诊疗记录。按照财务规范，如需修改错误的诊疗记录，应将当前错误的诊疗记录予以撤销后，再补充添加正确的诊疗记录。【重点考察】3）【删除】能够随时删除1条诊疗记录。1 住院医师只是医生的一种级别，并不表示诊疗情况中的住院只能与住院医师对应。4）【查询】能够按照合理顺序打印某个科室的诊疗信息（按照科室检索）。5）【查询】能够按照合理顺序打印某位医生的诊疗信息（按照医生的工号检索）。6）【查询】能够按照合理顺序打印某位患者的历史诊疗信息（按照患者的相关信息检索）。7）【统计】能够统计医院目前的营业额（检查费用+药品费用+住院费用，不含住院押金）；能够生成目前的住院患者报表。【重点考察】8）【统计】能够统计每位医生的出诊情况和工作繁忙程度。9）【某段时间范围】能够打印某段时间范围内的所有诊疗信息。【重点考察】10）【存储】能够将当前系统中的所有信息保存到文件中。11）其它你认为有用的附加功能，可酌情添加。 2、课程设计要求《程序设计基础课程设计》最终成绩（五分制）=《程序设计基础课程设计》超星MOOC成绩×10% + 育信OJ在线评测成绩×10% + 分组报告答辩成绩×80%。《程序设计基础课程设计》超星MOOC：由教师导入学生名单，学生无需注册；学生在规定时间内登录并独立完成在线任务（视频学习、单元测验和PBL提交）。育信OJ在线评测：学生独立在实验室在线评测。分组报告答辩：学生分组在实验室现场评测。1）自由分组，每组3人（特殊情况以指导教师安排为准），每组1份实验报告（请严格按照模板撰写）。2）答辩前在超星平台上以PBL形式提交材料（源代码、相关测试文件和实验报告等），所提交的C语言源程序需要含有必要的代码注释。3）答辩时现场提交实验报告的打印版。4）指导教师按照平时考核、代码和实验报告质量、任务分工和完成比例、界面美观和人性化、个人和团队答辩情况等环节综合评定成绩。重要说明1：全程链表实现。重要说明2：请按照人性化的方式设计具体功能，如：增加的诊疗信息仅含有部分数据，灵活的数据输入方式，软件使用人员操作失误，用户希望的多样化的查询和统计方式，清晰美观的输出方式，合理划分为多个源文件。重要说明3：请自行构造原始数据文件用于测试，文件类型为txt，每个文件至少包含30条诊疗记录。3、成绩说明五分制：优秀15%左右；良好35%左右；中等35%左右；及格和不及格15%左右。旷课比例达到20%（2次），最高成绩为中等；旷课比例达到30%（3次），最高成绩为及格；旷课比例达到50%（4次），取消答辩资格，成绩为不及格。4、特殊说明1）对于计算机科学与技术学院、软件学院的2019级学生，所有事宜以具体指导教师安排为准。2）对于软件学院2019级荣誉班，除此文件外，另有一个命名为“《程序设计基础课程设计》（软2019级补充材料）”的附件。3）对于计算机科学与技术学院、软件学院的重修、转专业学生，请尽快加入QQ群：**，主动联系任课教师（**），所有事宜以任课教师安排为准。 源码注：该源码脱离资源文件不能运行,运行请下载附件中的工程文件 //文件basic.h #ifndef OPEN_H_INCLUDED #define OPEN_H_INCLUDED struct Doctor{ int number;//工号 char name[20];//姓名 int level; //级别 int department;//科室 int workingHours[7];//工作时间。索引值0~6对应周日~周六,存储值为1则为上班，0则为不上班 struct Doctor *next; int registed;//今日挂号量统计 int w_registed;//周挂号量统计 }; struct ExaminationFee{ char name[20]; int cost; struct ExaminationFee *next; }; struct Medicine{ int number; char name[20]; int price; struct Medicine *next; }; struct Hospitalization{ int zhuyuanyajin;//住院押金 int ruyuanshijian;//入院时间：月、日、时、分 int chuyuanshijian;//出院时间：月、日、时、分 }; struct Treatment{ int total; int totalExaminationFee; //总检查费 struct ExaminationFee exminationFee; int totalMedicineCharge; //总药费 struct Medicine medicine; struct Hospitalization hospitalization; }; /*数据类*/ struct Data{ int number; //挂号序列 需是唯一值 int ID;//患者ID，对于每位患者来说是唯一值 char name[20]; //患者姓名 int age; //患者年龄 struct Doctor doctor; //医生 struct Treatment treatment; //治疗方法 struct Data *next;//链 }; int clearMedList();//回收药品链表内存 int clearDoctorList();//回收医生链表 int clearExamList();//回收诊疗项目链表内存 void saveData(char *location);//在location路径下将dataHead链表的所有数据存储到文件中 int registe();//挂号模块 void inputMedData();//从文件中读取并加载药品仓库数据 void buildDoctorList();//加载医生值班数据 int compStr(char *s1, int len1, char *s2, int len2);//字符串比对函数，用于检索 void buyMedicine(struct Data* newnode);//购药函数 int printDeparList(int n);//输出某个科室的情况 void hospitalize(struct Data* newNode);//住院模块 void selectExaminations(struct Data * newnode);//选择检查项目 void menu();//主菜单 int viewData();//浏览数据模块 void inputExamData();//加载所有的检查项目 void clearList1(struct Medicine *base);//回收base链表内存 void clearList2(struct ExaminationFee * base);//回收base链表内存 int findExamStart(int left, int right, FILE *pf_exam, int target); //二分查找，在文件中寻找对应的购药数据 int findMedStart(int left, int right, FILE *pf_med, int target); //二分查找，在文件中寻找对应的检查项目数据 int buildMedList(struct Medicine *base, FILE *pf_med, int start, int end);//建立诊疗记录中的购药单链表 int buildExamList(struct ExaminationFee *base, FILE *pf_exam, int start, int end);//建立诊疗记录中的检查项目链表 void clearList(struct Data *base);//回收base链表内存 struct Data* input(const char *dir);//建立链表的主函数，文件路径为dir，返回值为哨兵节点 void openUTDfile();//打开最新的数据文件 int preDay(char *ori);//输入为&quot;data/1009/&quot;型字符串，输出为前一天的字符串，如“data/1008/” int nextDay(char *ori);//输入为&quot;data/1009/&quot;型字符串，输出为后一天的字符串，如“data/1010/” int scanInt(int *num, int length);//输入整型变量，回车键结束输入，非法字符会被忽略,输入过长返回-2，无输入返回-1； int scanStrNum(char *num,int length);//输入数字的字符串，回车键结束输出，非法字符会被忽略，若无符合要求的输入则返回1，长度过长返回-2. int scanName(char *s, int length);//输入姓名,返回-2为输入过长 void loadHospitalizeData();//加载住院数据 void saveHosData();//存储主链表数据 int inputDate(int *month, int *day);//输入日期的函数 struct Data* reInput(const char* dir);//从路径为dir的文件中倒序建立链表 int viewUTDdata(int n);//浏览最新的n条数据 int showDepartStatus();//显示挂号情况模块 void showDocRegisted(struct Doctor *head);//显示科室中所有医生的情况 int leaveHospital(struct Data *p);//出院模块 int timeSpan(int start, int end);//日期不合法返回0 int printfMoneyStatus();//打印医院的营业额 void w_countAllDoc();//统计所有医生近一周的挂号量 int scanStr(char *s, int length);//安全读取字符串的函数 int dataChangeMenu();//数据修改菜单 int changeDataMenu();//修改数据的主界面 int setPassWord();//加密函数 char * deCode();//解密函数 int dataViewMenu(); //数据浏览模块 int inpatientDapart();//住院部模块 int patientAdminMenu();//住院病人管理菜单 int delayTime(struct Data *p);//延期出院模块 int printMargin(int n) ;//用于排版 void loading() ;//加载动效 int printSingleData(struct Data *p);//打印单条数据 int saveMedData(); int reSeek(FILE *pf); #endif // OPEN_H_INCLUDED //文件basic.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include &lt;io.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include&lt;windows.h&gt; #include&quot;basic.h&quot; #include&quot;view.h&quot; #include&quot;change.h&quot; /* 设定：每个医生一天最多挂10个号 每个科室最多挂20个号 */ const char DoctorLevel[5][12] = {&quot;&quot;,&quot;住院医师&quot;,&quot;主治医师&quot;,&quot;副主任医师&quot;,&quot;主任医师&quot;}; struct Medicine * mediStorage;//医院药品仓库 struct ExaminationFee * examlists; //医院所有可检查的项目 struct Data* dataHead;//链表头结点.有哨兵 struct Data* dataRear;//链表尾结点 struct Data* inHospital;//所有正在住院的病人，无哨兵 struct Data* inHospitalRear; struct Doctor doctor_departments[5];//设置5个科室,每个科室都是一个医生链表，有哨兵结点 char departments[7][20] = {&quot;内科&quot;,&quot;外科&quot;,&quot;儿科&quot;,&quot;五官科&quot;,&quot;传染病科&quot;}; int countDepartment[7];//记录每个科室挂了多少号 int sequence = 1;//挂号序列 /*考虑：几种模式的浏览：*/ int viewData() { system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;1、浏览最新数据\\n\\n&quot;); printMargin(40); printf(&quot;2、浏览历史数据\\n\\n&quot;); printMargin(40); printf(&quot;0、返回上一层\\n\\n\\n\\n\\n&quot;); printf(&quot;请选择：&quot;); int command; for(;;) { scanInt(&amp;command, 3); if((command &lt; 0)||(command &gt; 3)) { printf(&quot;输入非法!\\n请重新输入:&quot;); } else break; } if(!command) return 0; if(command == 1) { printf(&quot;请输入要查看多少条数据（最多100条）:&quot;); for(;;) { scanInt(&amp;command, 4); if((command &lt; 0)||(command &gt; 100)) { printf(&quot;输入非法\\n请重新输入:&quot;); } else break; } viewUTDdata(command); } else viewDataSpan(); return 0; } struct Data* input(const char* dir)//打开以路径“dir”为参数的所有文件,路径格式：“data/1001/” { FILE *pf, *pf_med, *pf_exam; char position[40]; strcpy(position,dir); strcpy(position+10,&quot;data.txt&quot;); sequence = 0; struct Data * base = (struct Data*)malloc(sizeof(struct Data)); base-&gt;next = NULL; if(pf = fopen(position,&quot;r&quot;),pf==NULL) { dataRear = base; dataHead = base; return base; } strcpy(position+10,&quot;examination.txt&quot;); pf_exam = fopen(position,&quot;r&quot;); strcpy(position+10,&quot;medicine.txt&quot;); pf_med = fopen(position,&quot;r&quot;); struct Data *p1, *p2 = NULL; p1 = base; struct Data *ptmp = NULL; while(!feof(pf)) { p2 = (struct Data *)malloc(sizeof(struct Data)); p2-&gt;next = NULL; p1-&gt;next = p2; fscanf(pf,&quot;%d%d%s%d%d%s&quot;,&amp;(p2-&gt;number),&amp;(p2-&gt;ID),p2-&gt;name,&amp;(p2-&gt;age),&amp;(p2-&gt;doctor.number),p2-&gt;doctor.name); fscanf(pf,&quot;%d%d&quot;,&amp;p2-&gt;doctor.level,&amp;p2-&gt;doctor.department); int i; for(i = 0; i &lt; 7; ++i) fscanf(pf,&quot;%d&quot;,&amp;(p2-&gt;doctor.workingHours[i])); fscanf(pf,&quot;%d&quot;,&amp;(p2-&gt;treatment.total)); int med_start,med_end,exam_start,exam_end; fscanf(pf,&quot;%d%d%d%d&quot;,&amp;med_start,&amp;med_end,&amp;exam_start,&amp;exam_end); fscanf(pf,&quot;%d%d&quot;,&amp;(p2-&gt;treatment.hospitalization.ruyuanshijian),&amp;(p2-&gt;treatment.hospitalization.chuyuanshijian)); p2-&gt;treatment.medicine.next = NULL; fgetc(pf); p2-&gt;treatment.totalMedicineCharge = buildMedList(&amp;(p2-&gt;treatment.medicine),pf_med,med_start,med_end); p2-&gt;treatment.totalExaminationFee = buildExamList(&amp;(p2-&gt;treatment.exminationFee), pf_exam,exam_start,exam_end); ptmp = p1; sequence = (ptmp-&gt;number)%10000; p1 = p2; } dataRear = ptmp; ptmp-&gt;next = NULL; free(p2); fclose(pf); fclose(pf_exam); fclose(pf_med); return base; } /*建立购药单链表*/ int buildMedList(struct Medicine *base, FILE *pf_med, int start, int end)//建立药品链表(需要读取购药单所在的文件) { base-&gt;next = NULL; if(start &gt; end) return 0; if(!start) return 0; int totalcost = 0; int right; fseek(pf_med,-38,SEEK_END);//共有right条数据 fscanf(pf_med,&quot;%d&quot;,&amp;right); --right; struct Medicine *p1, *p2; p1 = (struct Medicine *)malloc(sizeof(struct Medicine)); //文件尾记录了总共有多少条数据，8字节 base-&gt;next = p1; p1-&gt;next = NULL; int s; s = findMedStart(0, right, pf_med,start);//二分查找开始的记录 fseek(pf_med,s * 38, SEEK_SET); int tmp; fscanf(pf_med,&quot;%d%s%d%d&quot;,&amp;(tmp),p1-&gt;name,&amp;(p1-&gt;price),&amp;(p1-&gt;number)); totalcost += ((p1-&gt;price) * (p1-&gt;number)); if(start &gt; end) return 0; while((tmp &lt; end)&amp;&amp;(!feof(pf_med))) { p2 = (struct Medicine*)malloc(sizeof(struct Medicine)); p2-&gt;next = NULL; p1-&gt;next = p2; p1 = p2; fscanf(pf_med,&quot;%d%s%d%d&quot;,&amp;tmp,p1-&gt;name,&amp;(p1-&gt;price),&amp;(p1-&gt;number)); totalcost += ((p1-&gt;price) * (p1-&gt;number)); } return totalcost; } /*寻找购药单起点*/ int findMedStart(int left, int right, FILE *pf_med, int target) { int mid = (left + right) / 2; fseek(pf_med,mid * 38, SEEK_SET); int tmp; fscanf(pf_med,&quot;%d&quot;,&amp;tmp); if(tmp == target) return mid; if(left &gt; right) return -1; if(tmp &gt; target) return findMedStart(left,mid - 1, pf_med,target); else return findMedStart(mid + 1,right , pf_med, target); } /*建立检查项目链表*/ int buildExamList(struct ExaminationFee *base, FILE *pf_exam, int start, int end) { base-&gt;next = NULL; int total = 0; if(end &lt; start) return total; if(!end) return total; int right; fseek(pf_exam,-29,SEEK_END); fscanf(pf_exam,&quot;%d&quot;,&amp;right); --right; struct ExaminationFee *p1, *p2; p1 = (struct ExaminationFee *)malloc(sizeof(struct ExaminationFee)); //文件尾记录了总共有多少条数据，8字节 base-&gt;next = p1; int s; s = findExamStart(0, right, pf_exam,start);//二分查找开始的记录 fseek(pf_exam,s * 30, SEEK_SET); int tmp; fscanf(pf_exam,&quot;%d%s%d&quot;,&amp;tmp,p1-&gt;name,&amp;(p1-&gt;cost)); total += (p1-&gt;cost); p1-&gt;next = NULL; while((tmp &lt; end)&amp;&amp;(!feof(pf_exam))) { p2 = (struct ExaminationFee*)malloc(sizeof(struct ExaminationFee)); p1-&gt;next = p2; p1 = p2; fscanf(pf_exam,&quot;%d%s%d&quot;,&amp;(tmp),p1-&gt;name,&amp;(p1-&gt;cost)); total += (p1-&gt;cost); p2-&gt;next = NULL; } return total; } /*在检查项目总文件中寻找需要的数据段*/ int findExamStart(int left, int right, FILE *pf_exam, int target) { int mid = (left + right) / 2; fseek(pf_exam,mid * 30, SEEK_SET); int tmp; fscanf(pf_exam,&quot;%d&quot;,&amp;tmp); if(tmp == target) return mid; if(left &gt; right) return -1; if(tmp &gt; target) return findExamStart(left,mid - 1, pf_exam,target); else return findExamStart(mid + 1,right , pf_exam, target); } /*释放总诊疗记录链表*/ void clearList(struct Data *base) { if(!base) return; struct Data *p = base-&gt;next; free(base); struct Data *p2; while(p) { p2 = p; p = p-&gt;next; clearList2(p2-&gt;treatment.exminationFee.next); clearList1(p2-&gt;treatment.medicine.next); free(p2); } return; } /*释放购药链表*/ void clearList1(struct Medicine *base) { struct Medicine *p = base; struct Medicine *p2; while(p) { p2 = p; p = p-&gt;next; free(p2); } return; } /*释放诊疗记录链表*/ void clearList2(struct ExaminationFee *base) { struct ExaminationFee *p = base; struct ExaminationFee *p2; while(p) { p2 = p; p = p-&gt;next; free(p2); } return; } int printSingleData(struct Data * p) { printf(&quot;挂号序列：%d 患者姓名：%s ID:%d 患者年龄： %d &quot;, p-&gt;number, p-&gt;name,p-&gt;ID, p-&gt;age); printf(&quot;医生：%s %s %s 工号：%d\\n药品费： %d元 %d角\\n&quot;,departments[p-&gt;doctor.department],DoctorLevel[p-&gt;doctor.level],p-&gt;doctor.name,p-&gt;doctor.number,(p-&gt;treatment.totalMedicineCharge)/10,(p-&gt;treatment.totalMedicineCharge)%10); printMedList(&amp;(p-&gt;treatment.medicine)); printf(&quot;检查费： %d元 %d角&quot;,(p-&gt;treatment.totalExaminationFee)/10,(p-&gt;treatment.totalExaminationFee)%10); printExamList(&amp;(p-&gt;treatment.exminationFee)); if(p-&gt;treatment.hospitalization.ruyuanshijian) { int a = p-&gt;treatment.hospitalization.ruyuanshijian; int b = p-&gt;treatment.hospitalization.chuyuanshijian; printf(&quot;入院时间:%d月 %d日 %d时&quot;,a /1000000,(a%1000000)/10000, (a%10000)/100); printf(&quot;出院时间:%d月 %d日 %d时&quot;,b /1000000,(b%1000000)/10000, (b%10000)/100); } printf(&quot;\\n\\n\\n\\n&quot;); return 0; } /*将dataHead链表的所有信息存在路径为location的文件中*/ void saveData(char *location) { strcpy(location+10,&quot;data.txt&quot;); FILE *pf_data = fopen(location,&quot;w&quot;); strcpy(location+10,&quot;examination.txt&quot;); FILE *pf_exa = fopen(location,&quot;w&quot;); strcpy(location+10,&quot;medicine.txt&quot;); FILE *pf_med = fopen(location,&quot;w&quot;); struct Data * p = dataHead-&gt;next; int k_med = 1,k_exa = 1; while(p) { fprintf(pf_data,&quot;%09d %08d %8s %03d %06d %8s %d %02d &quot;,p-&gt;number,p-&gt;ID,p-&gt;name,p-&gt;age,p-&gt;doctor.number,p-&gt;doctor.name,p-&gt;doctor.level,p-&gt;doctor.department); for(int i = 0; i &lt; 7; ++i) fprintf(pf_data,&quot;%d &quot;,p-&gt;doctor.workingHours[i]); fprintf(pf_data,&quot;%06d &quot;,p-&gt;treatment.total); struct Medicine* p_med = p-&gt;treatment.medicine.next; if(p_med) { fprintf(pf_data,&quot;%06d &quot;,k_med); while(p_med) { fprintf(pf_med,&quot;%06d %20s %03d %04d\\n&quot;,k_med++,p_med-&gt;name,p_med-&gt;number,p_med-&gt;price); p_med = p_med-&gt;next; } fprintf(pf_data,&quot;%06d &quot;,k_med-1); } else { fprintf(pf_data,&quot;%06d %06d &quot;,0,0); } struct ExaminationFee* p_exa = p-&gt;treatment.exminationFee.next; if(p_exa) { fprintf(pf_data,&quot;%06d &quot;,k_exa); while(p_exa) { fprintf(pf_exa,&quot;%06d %14s %06d\\n&quot;,k_exa++,p_exa-&gt;name,p_exa-&gt;cost); p_exa = p_exa-&gt;next; } fprintf(pf_data,&quot;%06d &quot;,k_exa-1); } else { fprintf(pf_data,&quot;%06d %06d &quot;,0, 0); } fprintf(pf_data,&quot;%08d %08d\\n&quot;,p-&gt;treatment.hospitalization.ruyuanshijian,p-&gt;treatment.hospitalization.chuyuanshijian); p = p-&gt;next; } fclose(pf_data); fclose(pf_exa); fclose(pf_med); } /*建立一个药品链表：该链表存储着医院所有药品*/ void inputMedData() { FILE *pf_med = fopen(&quot;hospital/medicine.txt&quot;,&quot;r&quot;); mediStorage = (struct Medicine *)malloc(sizeof(struct Medicine)); struct Medicine * p = mediStorage,*p1,*p2; while(!feof(pf_med)) { p1 = (struct Medicine *)malloc(sizeof(struct Medicine)); int tmp; fscanf(pf_med,&quot;%d%s%d%d&quot;,&amp;tmp,p1-&gt;name,&amp;(p1-&gt;number),&amp;(p1-&gt;price)); p1-&gt;next = NULL; p-&gt;next = p1; p2 = p; p = p1; } free(p); p2-&gt;next = NULL; fclose(pf_med); } int clearMedList() { struct Medicine * p = mediStorage,*p1; while(p) { p1 = p; p = p-&gt;next; free(p1); } return 0; } /*在每一个科室之下建立医生链表*/ void buildDoctorList()// { FILE *pf_doctor = fopen(&quot;hospital/doctor.txt&quot;,&quot;a+&quot;); struct Doctor *p1[5], *p2; for(int i = 0; i &lt; 5; ++i) p1[i] = &amp;(doctor_departments[i]); while(!feof(pf_doctor)) { p2 = (struct Doctor*) malloc(sizeof(struct Doctor)); p2-&gt;next = NULL; fscanf(pf_doctor,&quot;%s%d%d%d&quot;,p2-&gt;name,&amp;(p2-&gt;level), &amp;(p2-&gt;department),&amp;(p2-&gt;number)); for(int i = 0; i &lt; 7; ++i) fscanf(pf_doctor,&quot;%d&quot;,&amp;(p2-&gt;workingHours[i])); p1[(p2-&gt;department)-1]-&gt;next = p2; p1[(p2-&gt;department)-1] = p2; } } int clearDoctorList() { for(int i = 0; i &lt; 5; ++i) { struct Doctor * p = doctor_departments[i].next, *p1; while(p) { p1 = p; p = p-&gt;next; free(p1); } } return 0; } int compStr(char *s1, int len1, char *s2, int len2)//字符串比对,返回匹配度 { int count = 0; for(int i = 0; i &lt; len1; ++i) { for(int j = 0; j &lt; len2; ++j) { if(s1[i] == s2[j]) { ++count; break; } } } return count==len1; } /*患者的购药函数*/ void buyMedicine(struct Data* newnode) { char s[20]; struct Medicine *p1 = &amp;newnode-&gt;treatment.medicine,*p2; newnode-&gt;treatment.totalMedicineCharge = 0; for(;;) { int flag = 0; printf(&quot;请输出欲购买药品的名称，输入exit退出购药界面\\n输入：&quot;); scanStr(s,19); if(s[0]==&#39;e&#39;) break; if(strlen(s) &lt; 3) { printf(&quot;检索的关键词过短！&quot;); continue; } struct Medicine * container[100]; int itr = 0; struct Medicine *p = mediStorage-&gt;next;//p是药仓，p1p2是新建链表 printf(&quot;\\n\\n\\n&quot;); while(p) { if(compStr(s,strlen(s),p-&gt;name,strlen(p-&gt;name))) { flag = 1; container[itr++] = p; printMargin(5); printf(&quot;%d、%s 单价 %d 元 %d 角 库存剩余 %d\\n\\n&quot;,itr, p-&gt;name, p-&gt;price/10, p-&gt;price%10, p-&gt;number); } p = p-&gt;next; } container[itr] = NULL; if(!flag) { printf(&quot;并没有找到该药品，请重新输入\\n&quot;); continue; } printf(&quot;请选择欲购买药品的序号:&quot;); int command; for(;;) { scanInt(&amp;command, 3); if((command &lt; 1)||(command &gt; itr)) printf(&quot;输入不合法，请重新输入:&quot;); else break; } p = container[command-1]; printf(&quot;您要购买：\\n%s 单价 %d 元 %d 角 库存剩余 %d\\n&quot;, p-&gt;name, p-&gt;price/10, p-&gt;price%10, p-&gt;number); for(;;) { printf(&quot;请输入数量:&quot;); scanInt(&amp;command, 3); if((command &lt; 0)||(command &gt; p-&gt;number)||(command &gt; 99)) printf(&quot;输入不合法，请重新输入:&quot;); else break; } if(!command) { printf(&quot;继续购买请输入1，结束购买请输入0:&quot;); for(;;) { scanInt(&amp;command, 3); if((command &lt; 0)||(command &gt; 1)) { printf(&quot;非法输入，请重新输入:&quot;); } else break; } if(command == 0) break; } else { p2 = (struct Medicine *)malloc(sizeof(struct Medicine)); p2-&gt;number = command; p2-&gt;next = NULL; p2-&gt;price = p-&gt;price; p1-&gt;next = p2; p-&gt;number -= command; newnode-&gt;treatment.totalMedicineCharge += (command* p-&gt;price); strcpy(p2-&gt;name,p-&gt;name); p1 = p2; } itr = -1; printf(&quot;继续购买请选择1，结束购买请选择0&quot;); for(;;) { scanInt(&amp;command, 2); if((command &lt; 0)||(command &gt; 1)) { printf(&quot;输入非法，请重新输入：&quot;); } else break; } if(command == 0) break; } printMedList(&amp;newnode-&gt;treatment.medicine); return ; } /*打印出某个科室的所有值班医生(不值班的不会被打印)*/ int printDeparList(int n) { if(countDepartment[n] &gt;= 20) { printMargin(40); printf(&quot;该科室患者已经达到上限20\\n&quot;); return -1; } printf(&quot;\\n\\n\\n&quot;); printMargin(40); printf(&quot;该科室目前有%d位患者\\n\\n\\n&quot;,countDepartment[n]); struct Doctor * p = doctor_departments[n].next; time_t rawtime; time(&amp;rawtime); struct tm *ti = localtime(&amp;rawtime); printMargin(40); printf(&quot;%s坐诊医生如下:\\n\\n\\n&quot;,departments[n]); int ii = 0; while(p) { if(p-&gt;workingHours[ti-&gt;tm_wday]) { printMargin(40); printf(&quot;| %d:医生：%s %s&quot;,++ii,p-&gt;name,DoctorLevel[p-&gt;level]); printf(&quot; 目前有%d名患者\\n&quot;,p-&gt;registed); printMargin(40);printf(&quot;|\\n&quot;); } p = p-&gt;next; } printMargin(44); return 0; } /*挂号函数*/ int registe() { countAllDoc(); printfMoneyStatus(); time_t timep; time(&amp;timep); char location[20] = &quot;data/&quot;; strftime(location+5,sizeof(location),&quot;%m%d&quot;,localtime(&amp;timep)); if ( access(location, F_OK) != 0) { mkdir(location); } location[9] = &#39;/&#39;; int money = 0; openUTDfile();//这里建立最新数据的链表。需要统计各个科室、各个医生挂了多少号 FILE *pf_money = fopen(&quot;data/money.txt&quot;,&quot;r&quot;); fscanf(pf_money,&quot;%d&quot;,&amp;money); fclose(pf_money); for(;;) { struct Data * newNode = (struct Data*) malloc(sizeof(struct Data)); newNode-&gt;next = NULL; newNode-&gt;treatment.totalExaminationFee = 0; newNode-&gt;treatment.totalMedicineCharge = 0; newNode-&gt;treatment.hospitalization.zhuyuanyajin = 0; printf(&quot;正在挂号...\\n\\n&quot;); time_t now; struct tm* tm_now; time(&amp;now); tm_now = localtime(&amp;now); int seq = (tm_now-&gt;tm_mon+1) * 10e6 + tm_now-&gt;tm_mday * 10e4; seq += (++sequence); printf(&quot;挂号序号:%d\\n&quot;,seq%1000); newNode-&gt;number = seq; int command = 0; int m; struct Doctor * p; for(;;) { printf(&quot;\\n\\n\\n\\n\\n\\n\\n\\n&quot;); for(int i = 0; i &lt; 5; ++i) { printMargin(40);printf(&quot;%d,%s&quot;,i+1,departments[i]); printf(&quot; 目前有患者%d人\\n\\n&quot;,countDepartment[i]); } printf(&quot;\\n\\n\\n\\n\\n\\n\\n\\n请选择(输入0则返回主菜单)：&quot;); scanInt(&amp;m,2); if((m &gt; 5)||(m &lt;0)) { printf(&quot;请正确输入！\\n&quot;); continue; } if(m == 0) { system(&quot;cls&quot;); return 0; } p = doctor_departments[m-1].next; system(&quot;cls&quot;); if(printDeparList(m-1) == 0) { break; } } int n; while(1) { printf(&quot;\\n\\n\\n&quot;); printMargin(10); printf(&quot;请输入医生序号，输入0则返回上一层（医生的患者上限为10人）:&quot;); scanInt(&amp;command,3); n = command; if(n &lt; 0) { printf(&quot;请正确输入\\n&quot;); continue; } if(n == 0) { free(newNode); break; } p = doctor_departments[m-1].next; while(p) { if((p-&gt;workingHours[tm_now-&gt;tm_wday])) { if(!(--n)) break; } p = p-&gt;next; } if(p == NULL) { printf(&quot;请正确输入\\n&quot;); continue; } if(p-&gt;registed &gt;= 10) { printf(&quot;该医生患者数已达上限\\n&quot;); continue; } else { ++(p-&gt;registed); break; } } if(!command) continue; system(&quot;cls&quot;); printf(&quot;%s\\n&quot;,p-&gt;name); strcpy(newNode-&gt;doctor.name,p-&gt;name); newNode-&gt;doctor.department = m; newNode-&gt;doctor.level = p-&gt;level; newNode-&gt;doctor.number = p-&gt;number; newNode-&gt;doctor.next = NULL; for(int i = 0; i &lt; 7; ++i) newNode-&gt;doctor.workingHours[i] = p-&gt;workingHours[i]; printf(&quot;请输入身份码（8位数字）：&quot;); while((scanInt(&amp;(newNode-&gt;ID),8)!= 8)) { printf(&quot;请检查输入长度!重新输入!\\n&quot;); } int num = countPatientDoc(newNode-&gt;ID,newNode-&gt;doctor.number); if(num) { printf(&quot;注意：您今天在%s 下已有挂号\\n&quot;,newNode-&gt;doctor.name); printf(&quot;如要取消本次挂号请输入0,否则输入其他数字\\n&quot;); scanInt(&amp;command,2); if(command == 0) { free(newNode); continue; } } countDepartment[newNode-&gt;doctor.department]++; printf(&quot;请输入患者姓名 :&quot;); scanName(newNode-&gt;name,10); for(;;) { printf(&quot;请输入性别，0为女，1为男\\n&quot;); int sex; scanInt(&amp;sex,3); if((sex &gt; 1)||(sex &lt; 0)) printf(&quot;请正确输入\\n&quot;); else { newNode-&gt;number += (sex * 10000); break; } } for(;;) { printf(&quot;请输入年龄 :&quot;); scanInt(&amp;(newNode-&gt;age),5); if((newNode-&gt;age &gt; 150)||(newNode-&gt;age&lt; 0)) { printf(&quot;请检查输入！\\n&quot;); } else { break; } } newNode-&gt;treatment.medicine.next = NULL; newNode-&gt;treatment.exminationFee.next = NULL; printf(&quot;如需购药请输入1， 输入其他数字则不购药\\n&quot;); newNode-&gt;treatment.totalExaminationFee = 0; newNode-&gt;treatment.totalMedicineCharge = 0; newNode-&gt;treatment.total = 0; scanInt(&amp;command,3); if(command == 1) buyMedicine(newNode); else newNode-&gt;treatment.medicine.next = NULL; printf(&quot;如需进行检查请输入1，否则输入其他数字\\n&quot;); scanInt(&amp;command,3); if(command == 1) selectExaminations(newNode); else newNode-&gt;treatment.exminationFee.next = NULL; printf(&quot;如需住院请输入1，否则输入其他数字\\n&quot;); scanInt(&amp;command,3); newNode-&gt;treatment.hospitalization.chuyuanshijian = 0; newNode-&gt;treatment.hospitalization.ruyuanshijian = 0; newNode-&gt;treatment.hospitalization.zhuyuanyajin = 0; if(command == 1) hospitalize(newNode); dataRear-&gt;next = newNode; dataRear = dataRear-&gt;next; printf(&quot;挂号成功！\\n&quot;); saveData(location); printf(&quot;序号：%d 姓名:%s &quot;,newNode-&gt;number,newNode-&gt;name); printf(&quot; ID %d 年龄 %d 医生：%s\\n\\n&quot;,newNode-&gt;ID,newNode-&gt;age,newNode-&gt;doctor.name); printf(&quot;输入1继续挂号，输入0退出挂号系统\\n&quot;); money += newNode-&gt;treatment.totalExaminationFee; money += newNode-&gt;treatment.totalMedicineCharge; money += newNode-&gt;treatment.hospitalization.zhuyuanyajin * 10; scanInt(&amp;command,1); if(!command) break; } int moneyy = money; pf_money = fopen(&quot;data/money.txt&quot;,&quot;w&quot;); fprintf(pf_money,&quot;%d&quot;,moneyy); fclose(pf_money); printfMoneyStatus(); printf(&quot;按任意键返回\\n&quot;); getchar(); system(&quot;cls&quot;); clearList(dataHead); return 0; } int nextDay(char *ori)//输入为&quot;data/1009/&quot;型字符串，输出为后一天的字符串，如“data/1010/” { if(ori[8]==&#39;0&#39;) { ori[8]=&#39;1&#39;; return 0; } if(ori[7] == &#39;3&#39;)//肯定为31号 { ori[7] = &#39;0&#39;; ori[8] = &#39;1&#39;; ori[6] += 1; return 0; } if(ori[8] == &#39;9&#39;) { ori[8] = &#39;0&#39;; ori[7] += 1; return 0; } ori[8] += 1; return 0; } int preDay(char *ori)//输入为&quot;data/1009/&quot;型字符串，输出为前一天的字符串，如“data/1008/” { if((ori[7] == &#39;0&#39;)&amp;&amp;(ori[8] == &#39;1&#39;)) { ori[7] = &#39;3&#39;; ori[8] = &#39;1&#39;; if(ori[6]==&#39;0&#39;) { ori[6] = &#39;9&#39;; ori[5] -= 1; } else { ori[6] -= 1; } return 0; } if(ori[8] == &#39;0&#39;) { ori[8] = &#39;9&#39;; ori[7] -= 1; return 0; } ori[8] -= 1; return 0; } /*患者的住院函数*/ void hospitalize(struct Data* newNode)//住院 { struct Data * p = inHospital; while(p) { if(newNode-&gt;ID == p-&gt;ID) { printf(&quot;该患者已经正在住院，无法重复办理住院\\n&quot;); return; } p = p-&gt;next; } int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31}; printf(&quot;请输入入院时间,格式：月 日 时如： \\&quot;9 10 10\\&quot;,数字间以空格间隔 \\n&quot;); int m,d,h,s; newNode-&gt;treatment.hospitalization.zhuyuanyajin = 0; int time1 = 0; for(;;) { scanInt(&amp;m, 2); scanInt(&amp;d, 2); scanInt(&amp;h, 2); s = 0; if((m &gt; 0)&amp;&amp;(m &lt; 13)&amp;&amp;(d &gt; 0)&amp;&amp; (d &lt;= months[m])&amp;&amp;(h &gt;= 0)&amp;&amp;(h &lt; 24)&amp;&amp;(s &gt;= 0)&amp;&amp;(s &lt; 60)) { } else { printf(&quot;请检查输入格式重新输入:&quot;); continue; } time1 = m * 1000000; time1 += (d * 10000); time1 += (h * 100); time_t now; struct tm* tm_now; time(&amp;now); tm_now = localtime(&amp;now); int tmp = (tm_now-&gt;tm_mon+1) * 1000000 + tm_now-&gt;tm_mday * 10000 + tm_now-&gt;tm_hour * 100; if(tmp &gt; time1) { printf(&quot;请保证入院时间晚于当前时间\\n&quot;); continue; } else break; } newNode-&gt;treatment.hospitalization.ruyuanshijian = time1; int m1,d1,h1; printf(&quot;请输入预计出院时间,格式：月 日 时如： \\&quot;9 10 10\\&quot;,数字间以空格间隔 \\n&quot;); int time2; for(;;) { scanInt(&amp;m1, 2); scanInt(&amp;d1, 2); scanInt(&amp;h1, 2); if((m1 &gt; 0)&amp;&amp;(m1 &lt; 13)&amp;&amp;(d1 &gt; 0)&amp;&amp; (d1 &lt;= months[m])&amp;&amp;(h1 &gt;= 0)&amp;&amp;(h1 &lt; 24)) { time2 = m1 * 1000000; time2 += (d1 * 10000); time2 += (h1 * 100); if(time1 &lt; time2) { } else { printf(&quot;请保证出院时间晚于入院时间\\n&quot;); continue; } time_t now; struct tm* tm_now; time(&amp;now); tm_now = localtime(&amp;now); int tmp = (tm_now-&gt;tm_mon+1) * 1000000 + tm_now-&gt;tm_mday * 10000 + tm_now-&gt;tm_hour; if(tmp &gt; time2) { printf(&quot;请保证出院时间晚于当前时间\\n&quot;); continue; } break; } else { printf(&quot;请检查输入格式\\n请重新输入出院时间：&quot;); } } newNode-&gt;treatment.hospitalization.chuyuanshijian = time2; int money = timeSpan(newNode-&gt;treatment.hospitalization.ruyuanshijian,newNode-&gt;treatment.hospitalization.chuyuanshijian) * 200; for(;;) { printf(&quot;请缴纳押金 至少为 %d元,至多为99900元，且必须为100的整数倍\\n&quot;, money+1000); scanInt(&amp;(newNode-&gt;treatment.hospitalization.zhuyuanyajin),7); if(((newNode-&gt;treatment.hospitalization.zhuyuanyajin) &lt; money+1000) ||(newNode-&gt;treatment.hospitalization.zhuyuanyajin &gt; 99999)||(newNode-&gt;treatment.hospitalization.zhuyuanyajin%100)) printf(&quot;非法输入\\n&quot;); else break; } printf(&quot;已缴纳！\\n&quot;); struct Data* node_hospital = (struct Data*)malloc(sizeof(struct Data)); node_hospital-&gt;next = NULL; if(inHospital == NULL) { inHospital = node_hospital; inHospitalRear = node_hospital; } else { inHospitalRear-&gt;next = node_hospital; inHospitalRear = node_hospital; } node_hospital-&gt;age = newNode-&gt;age; node_hospital-&gt;ID = newNode-&gt;ID; node_hospital-&gt;number = newNode-&gt;number; strcpy(node_hospital-&gt;name,newNode-&gt;name); node_hospital-&gt;treatment.hospitalization.chuyuanshijian = newNode-&gt;treatment.hospitalization.chuyuanshijian; node_hospital-&gt;treatment.hospitalization.ruyuanshijian = newNode-&gt;treatment.hospitalization.ruyuanshijian; node_hospital-&gt;treatment.hospitalization.zhuyuanyajin = newNode-&gt;treatment.hospitalization.zhuyuanyajin; node_hospital-&gt;treatment.exminationFee.next = NULL; node_hospital-&gt;treatment.medicine.next = NULL; return; } /*患者进行检查的函数*/ void selectExaminations(struct Data * newnode) { char s[20]; struct ExaminationFee *p1 = &amp;(newnode-&gt;treatment.exminationFee),*p2; struct ExaminationFee * container[200]; int command; for(;;) { int flag = 0; printf(&quot;请输入检查项目名，输入exit退出界面\\n&quot;); scanStr(s,10); if(s[0]==&#39;e&#39;) break; if(strlen(s) &lt; 3) { printf(&quot;检索关键词过短&quot;); continue; } struct ExaminationFee *p = examlists; int itr = 0; printf(&quot;\\n\\n\\n&quot;); while(p) { if(compStr(s,strlen(s),p-&gt;name,strlen(p-&gt;name))) { container[itr++] = p; flag = 1; printMargin(5); printf(&quot;%d 、%s 单价： %d元 %d角\\n\\n&quot;,itr,p-&gt;name, p-&gt;cost/10, p-&gt;cost % 10); } p = p-&gt;next; } if(!flag) { printf(&quot;未找到匹配的检查项目，请重新输入\\n&quot;); continue; } for(;;) { printf(&quot;请选择检查项目的序号,选择0则重新检索:&quot;); scanInt(&amp;command, 3); if((command &lt; 0) ||(command &gt; itr)) { printf(&quot;输入非法!\\n&quot;); } else break; } if(command == 0) continue; p = container[command - 1]; printf(&quot;%s 已选择√\\n&quot;,p-&gt;name); newnode-&gt;treatment.totalExaminationFee += p-&gt;cost; p2 = (struct ExaminationFee*) malloc (sizeof(struct ExaminationFee)); p2-&gt;cost = p-&gt;cost; strcpy(p2-&gt;name,p-&gt;name); p2-&gt;next = NULL; p1-&gt;next = p2; p1 = p2; printf(&quot;继续选择请选择1，结束选择请选择0\\n&quot;); for(;;) { scanInt(&amp;command, 2); if((command &lt;0)||(command &gt; 1)) { printf(&quot;输入非法！\\n&quot;); } else break; } if(command == 0) break; } printExamList(&amp;(newnode-&gt;treatment.exminationFee)); return; } /*主菜单*/ void menu() { int (*mainMenu[5])() = {registe,inpatientDapart,dataViewMenu,dataChangeMenu}; int command = 0; while(1) { system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;|----------主菜单----------|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|&quot;);printMargin(8); printf(&quot;1、挂号&quot;);printMargin(11);printf(&quot;|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|&quot;);printMargin(8); printf(&quot;2、住院部&quot;);printMargin(9);printf(&quot;|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|&quot;);printMargin(8); printf(&quot;3、浏览数据&quot;);printMargin(7);printf(&quot;|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|&quot;);printMargin(8); printf(&quot;4、修改数据&quot;);printMargin(7);printf(&quot;|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|&quot;);printMargin(8); printf(&quot;0、退出系统&quot;);printMargin(7);printf(&quot;|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|--------------------------|\\n\\n\\n\\n\\n\\n\\n&quot;); printf(&quot;请选择：&quot;); scanInt(&amp;command,1); if((command &gt; 4)||(command&lt;0)) { printf(&quot;请检查输入！\\n&quot;); continue; } if(!command) break; system(&quot;cls&quot;); mainMenu[command-1](); } } /*从文件中加载医院所有的检查项目*/ void inputExamData() { FILE *pf_exa = fopen(&quot;hospital/examination.txt&quot;,&quot;r&quot;); examlists = (struct ExaminationFee *)malloc(sizeof(struct ExaminationFee)); struct ExaminationFee * p = examlists,*p1; while(!feof(pf_exa)) { p1 = (struct ExaminationFee *)malloc(sizeof(struct ExaminationFee)); int tmp; fscanf(pf_exa,&quot;%d%s%d&quot;,&amp;tmp,p1-&gt;name,&amp;(p1-&gt;cost)); p1-&gt;next = NULL; p-&gt;next = p1; p = p1; } fclose(pf_exa); } int clearExamList() { struct ExaminationFee * p, *p1; p = examlists; while(p) { p1 = p; p = p-&gt;next; free(p1); } return 0; } void openUTDfile()//打开最新的数据文件 { time_t timep; time(&amp;timep); char location[20] = &quot;data/&quot;; strftime(location+5,sizeof(location),&quot;%m%d&quot;,localtime(&amp;timep)); location[9] = &#39;/&#39;; location[10] = 0; dataHead = input(location); return; } int scanInt(int *num,int length)//输入整型变量，回车键或空格键结束输入，非法字符会被忽略,过长输入会被截取,输入过长返回-1; { *num = 0; char c = getchar(); int len = 0; while((c &gt; &#39;9&#39;)||(c &lt; &#39;0&#39;)) { c = getchar(); } while((c != &#39;\\n&#39;) &amp;&amp; (c != &#39; &#39;)) { if((c &lt;= &#39;9&#39;)&amp;&amp; (c &gt;= &#39;0&#39;)) { *num *= 10; *num += (c - &#39;0&#39;); ++len; if(len &gt;= length) { c = getchar(); if(c == &#39;\\n&#39;) return len; while((c != &#39;\\n&#39;) &amp;&amp; (c != &#39; &#39;)) { c = getchar(); } return -1; } } c = getchar(); } return len; } int scanName(char *s,int length)//输入姓名,返回-1为输入过长,非法字符会被过滤 { char c = getchar(); while(!((c &lt; 0)||((c &lt;= &#39;Z&#39;)&amp;&amp;(c &gt;= &#39;A&#39;))||((c &lt;= &#39;z&#39;)&amp;&amp;(c &gt;= &#39;a&#39;)))) { c = getchar(); } s[0] = c; int i = 0; if(c &lt; 0)//中文 { while(c != &#39;\\n&#39;) { c = getchar(); if(c &gt;= 0) continue; s[++i] = c; if(i &gt;= length-1) { s[++i] = 0; while(c != &#39;\\n&#39;) { c = getchar(); } return -1; } } } else { while(c != &#39;\\n&#39;) { c = getchar(); if(!(((c &lt;= &#39;Z&#39;)&amp;&amp;(c &gt;= &#39;A&#39;))||((c &lt;= &#39;z&#39;)&amp;&amp;(c &gt;= &#39;a&#39;))||(c == &#39; &#39;))) continue; s[++i] = c; if(i &gt;= length-1) { s[++i] = 0; while(c != &#39;\\n&#39;) { c = getchar(); } return -1; } } } s[++i] = 0; return i; } int scanStrNum(char *num,int length)//输入数字的字符串,回车结束输入，其他非数字的字符会被过滤，返回值为长度，长度过长返回-1. { char c = getchar(); int i = 0; while((c &gt; &#39;9&#39;) || (c &lt; &#39;0&#39;)) { c = getchar(); } while(c != &#39;\\n&#39;) { if((c &lt;= &#39;9&#39;)&amp;&amp;(c &gt;= &#39;0&#39;)) { num[i++] = c; if(i &gt;= length) { num[i] = 0; while(c != &#39;\\n&#39;) { c = getchar(); } return -1; } } c = getchar(); } num[i] = 0; return (i-1); } void saveHosData() { FILE *pf = fopen(&quot;hospital/hospital.txt&quot;,&quot;w&quot;); struct Data * p = inHospital; while(p) { int sex = (p-&gt;number % 100000) / 10000; fprintf(pf,&quot;%08d %20s %d %03d %08d &quot;,p-&gt;ID,p-&gt;name,sex ,p-&gt;age,p-&gt;treatment.hospitalization.ruyuanshijian); fprintf(pf,&quot;%08d %08d\\n&quot;,p-&gt;treatment.hospitalization.chuyuanshijian,p-&gt;treatment.hospitalization.zhuyuanyajin); p = p-&gt;next; } fclose(pf); } /*加载住院数据*/ void loadHospitalizeData() { inHospital = NULL; inHospitalRear = NULL; FILE *pf = fopen(&quot;hospital/hospital.txt&quot;,&quot;r&quot;); if(!pf) return; inHospital = (struct Data*)malloc(sizeof(struct Data)); inHospital-&gt;treatment.medicine.next = NULL; inHospital-&gt;treatment.exminationFee.next = NULL; struct Data *p = inHospital, *p1; p-&gt;next = NULL; while(!feof(pf)) { int sex; p1 = p; p-&gt;next = (struct Data*)malloc(sizeof(struct Data)); p = p-&gt;next; p-&gt;next = NULL; p-&gt;treatment.medicine.next = NULL; p-&gt;treatment.exminationFee.next = NULL; fscanf(pf,&quot;%d%s%d%d%d&quot;,&amp;(p-&gt;ID),p-&gt;name,&amp;sex,&amp;(p-&gt;age),&amp;(p-&gt;treatment.hospitalization.ruyuanshijian)); fscanf(pf,&quot;%d%d&quot;,&amp;(p-&gt;treatment.hospitalization.chuyuanshijian),&amp;(p-&gt;treatment.hospitalization.zhuyuanyajin)); p-&gt;number = sex * 10000; } inHospitalRear = p1; p1-&gt;next = NULL; free(p); p = inHospital; inHospital = p-&gt;next; free(p); fclose(pf); } void countAllDoc()//统计所有医生的繁忙情况 { openUTDfile(); extern int countDepartment[7]; extern struct Doctor doctor_departments[5]; extern struct Data* dataHead; for(int i = 0; i &lt; 5; ++i) { countDepartment[i] = 0; struct Doctor *p_doc = doctor_departments[i].next; while(p_doc) { struct Data * p_data = dataHead-&gt;next; p_doc-&gt;registed = 0; while(p_data) { if(p_data-&gt;doctor.number == p_doc-&gt;number) { ++(p_doc-&gt;registed); ++countDepartment[i]; } p_data = p_data-&gt;next; } p_doc = p_doc-&gt;next; } } return; } int showDepartStatus()//繁忙情况统计的交互界面 { countAllDoc(); w_countAllDoc(); system(&quot;cls&quot;); extern struct Doctor doctor_departments[5]; extern char departments[7][20]; printf(&quot;要查看哪个科室的情况? 输入0返回上一层\\n&quot;); for(int i = 0; i &lt; 5; ++i) { printMargin(40); printf(&quot;%d、%s\\n\\n&quot;,i+1,departments[i]); } printf(&quot;请选择：&quot;); int command; for(;;) { scanInt(&amp;command,3); if((command &lt; 0)||(command &gt; 5)) { printf(&quot;输入非法\\n&quot;); } else break; } system(&quot;cls&quot;); printMargin(40); printf(&quot;%s 所有医生挂号状况如下：\\n\\n\\n&quot;,departments[command-1]); printMargin(40); printf(&quot;该科室今天共有%d个病人\\n&quot;,countDepartment[command-1]); showDocRegisted(doctor_departments[command-1].next); printMargin(40);printf(&quot;按任意键返回上一层&quot;); getchar(); return 0; } void showDocRegisted(struct Doctor *head)//以科室头指针为参数，显示该科室医生的繁忙情况 { char dic[7][3] = {&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;}; struct Doctor * p_doc = head; int counter = 0; while(p_doc) { int workDay = 0; printMargin(40); printf(&quot;%d %10s 今天共有%2d病人 本周共有%d病人\\n&quot;,++counter,p_doc-&gt;name,p_doc-&gt;registed,p_doc-&gt;w_registed); printMargin(40);printf(&quot;上班时间： 周&quot;); for(int i = 0; i &lt; 7; ++i) { if(p_doc-&gt;workingHours[i]) { printf(&quot;%s、&quot;,dic[i]); ++workDay; } } printf(&quot;\\n&quot;); printMargin(40); printf(&quot;今天挂号率:%.2f%% 本周挂号率: %.2f%%\\n\\n&quot;,(float)(p_doc-&gt;registed)*10, (float)(p_doc-&gt;w_registed*10/workDay)); p_doc = p_doc-&gt;next; } return; } int leaveHospital(struct Data *p) { time_t now; struct tm* tm_now; time(&amp;now); tm_now = localtime(&amp;now); int tmp = (tm_now-&gt;tm_mon+1) * 1000000 + tm_now-&gt;tm_mday * 10000 + tm_now-&gt;tm_hour; extern struct Data* inHospital; int hos_time = timeSpan(p-&gt;treatment.hospitalization.ruyuanshijian,tmp); int hos_money = 200 * hos_time; printf(&quot;您共住院%d天，产生住院费%d元 住院押金剩余%d&quot;,hos_time,hos_money,p-&gt;treatment.hospitalization.zhuyuanyajin-hos_money ); if(p-&gt;treatment.hospitalization.zhuyuanyajin-hos_money &gt;= 0) printf(&quot;余额已返还，请确认\\n&quot;); else { printf(&quot;请缴纳欠款！\\n&quot;); } FILE *pf_money = fopen(&quot;data/money.txt&quot;,&quot;r+&quot;); fseek(pf_money,0,SEEK_SET); int money; fscanf(pf_money,&quot;%d&quot;,&amp;money); if(p-&gt;treatment.hospitalization.zhuyuanyajin-hos_money &gt;= 0) money = money - p-&gt;treatment.hospitalization.zhuyuanyajin + hos_money; else money = money + p-&gt;treatment.hospitalization.zhuyuanyajin - hos_money; fseek(pf_money,0,SEEK_SET); fprintf(pf_money,&quot;%d&quot;,money); fclose(pf_money); printfMoneyStatus(); printf(&quot;出院成功！\\n\\n\\n\\n\\n\\n&quot;); printf(&quot;按任意键返回主菜单\\n&quot;); getchar(); system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;出院成功！\\n\\n\\n\\n\\n\\n&quot;); printf(&quot;按任意键返回主菜单\\n&quot;); getchar(); return 0; } int patientAdminMenu() { struct Data* p = inHospital; struct Data * p1 = p; printf(&quot;请输入病人ID,输入0返回上一层\\n&quot;); int id; for(;;) { int length = scanInt(&amp;id, 9); if(!id) return 0; if(length != 8) { printf(&quot;输入非法！请重新输入:&quot;); continue; } while(p) { if(p-&gt;ID == id) break; p1 = p; p = p-&gt;next; } if(p == NULL) printf(&quot;未找到该患者\\n&quot;); else break; } system(&quot;cls&quot;); showPatientsInfo(p); printf(&quot;\\n\\n\\n&quot;); printMargin(40); printf(&quot;1、办理出院\\n\\n&quot;); printMargin(40); printf(&quot;2、延迟出院\\n\\n&quot;); printMargin(40); printf(&quot;0、退出系统\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;请选择：&quot;); int command; for(;;) { scanInt(&amp;command,3); if((command &lt; 0)|| (command &gt; 2)) printf(&quot;输入非法&quot;); else break; } switch(command) { case 1: { leaveHospital(p); if(p == inHospital) inHospital = p-&gt;next; else p1-&gt;next = p-&gt;next; free(p); break; } case 2: delayTime(p); break; case 0: break; } return 0; } int delayTime(struct Data *p) { int b; int money = 0; while(1) { int a = p-&gt;treatment.hospitalization.chuyuanshijian; int t[3]; printf(&quot;请输入月 日 时中间用空格分隔，如:9 2 1 :&quot;); scanInt(&amp;(t[0]),2); scanInt(&amp;(t[1]),2); scanInt(&amp;(t[2]),2); b = t[0] * 1000000 + t[1] * 10000 + t[2] * 100; if(timeSpan(a,b) != 0) { int cost = timeSpan(p-&gt;treatment.hospitalization.ruyuanshijian,b) * 200; if(cost+1000 &gt; p-&gt;treatment.hospitalization.zhuyuanyajin) printf(&quot;请续缴住院费，至少缴纳%d 元,至多缴纳99999元&quot;,cost+1000 - p-&gt;treatment.hospitalization.zhuyuanyajin); else break; for(;;) { scanInt(&amp;money, 7); if((money &lt; cost+1000 - p-&gt;treatment.hospitalization.zhuyuanyajin)||(money &gt; 99999)) printf(&quot;请检查输入！\\n&quot;); else break; } break; } printf(&quot;输入不合法，请检查\\n&quot;); } printf(&quot;操作成功！ 任意键返回上一级\\n&quot;); getchar(); FILE *pf_money = fopen(&quot;data/money.txt&quot;,&quot;r+&quot;); int money_; fseek(pf_money,0,SEEK_SET); fscanf(pf_money,&quot;%d&quot;,&amp;money_); money_ = money + money_; fseek(pf_money,0,SEEK_SET); fprintf(pf_money,&quot;%d&quot;,money_); fclose(pf_money); p-&gt;treatment.hospitalization.chuyuanshijian = b; printfMoneyStatus(); printf(&quot;操作成功！ 任意键返回上一级\\n&quot;); getchar(); return 0; } int timeSpan(int start, int end)//日期不合法返回0 { int a = start / 100; int b = end / 100; if(end &lt;= start) return 0; int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31}; int m1,d1,h1,m2,d2,h2; h1 = a % 100; a /= 100; d1 = a % 100; a /= 100; m1 = a; h2 = b % 100; b /= 100; d2 = b % 100; b /= 100; m2 = b; if((m1&lt;1)||(m1&gt;12)||(m2&lt;1)||(m2&gt;12)) return -1; if((d1&lt;1)||(d1&gt;months[m1])||(d2&lt;1)||(d2&gt;months[m2])) return -1; if((h1&lt;0)||(h1&gt;23)||(h2&lt;0)||(h2&gt;23)) return -1; int sum = 0; for(int i = m1; i &lt; m2; ++i) sum += months[i]; sum += d2; sum -= d1; if(h2 &gt; 8) ++sum; return sum; } int printfMoneyStatus() { FILE *pf_money = fopen(&quot;data/money.txt&quot;,&quot;r&quot;); int money; fscanf(pf_money,&quot;%d&quot;,&amp;money); printf(&quot;\\n\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;当前医院总营业额为%d元%d角\\n\\n\\n\\n\\n\\n&quot;,money/10,money%10); fclose(pf_money); return 0; } int inputDate(int *month, int *day)//输入月、日，并检查格式 { int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31}; printf(&quot;请输入月 日 中间用空格隔开&quot;); for(;;) { scanInt(month,9); if((*month &gt; 12)||(*month &lt;0)) { printf(&quot;输入不正确，请检查\\n&quot;); } else break; } for(;;) { scanInt(day,9); if((*day &lt; 0) || (*day &gt; months[*month]) ) { printf(&quot;输入不正确，请检查\\n&quot;); } else break; } return 0; } struct Data* reInput(const char* dir)//打开以路径“dir”为参数的所有文件,路径格式：“data/1001/”,并逆序建立链表。 { FILE *pf, *pf_med, *pf_exam; char position[40]; strcpy(position,dir); strcpy(position+10,&quot;data.txt&quot;); sequence = 0; struct Data * base = (struct Data*)malloc(sizeof(struct Data)); base-&gt;next = NULL; if(pf = fopen(position,&quot;r&quot;),pf==NULL) { dataRear = base; dataHead = base; return base; } strcpy(position+10,&quot;examination.txt&quot;); pf_exam = fopen(position,&quot;r&quot;); strcpy(position+10,&quot;medicine.txt&quot;); pf_med = fopen(position,&quot;r&quot;); struct Data *p1, *p2 = NULL; p1 = base; int itr = 1; int flag = 0; fseek(pf,-123,SEEK_END); while(!flag) { int countScan = 0; p2 = (struct Data *)malloc(sizeof(struct Data)); p2-&gt;next = NULL; p1-&gt;next = p2; countScan = fscanf(pf,&quot;%d%d%s%d%d%s&quot;,&amp;(p2-&gt;number),&amp;(p2-&gt;ID),p2-&gt;name,&amp;(p2-&gt;age),&amp;(p2-&gt;doctor.number),p2-&gt;doctor.name); if(countScan != 6) { reSeek(pf); continue; } countScan = fscanf(pf,&quot;%d%d&quot;,&amp;p2-&gt;doctor.level,&amp;p2-&gt;doctor.department); if(countScan != 2) { reSeek(pf); continue; } countScan = 0; int i; for(i = 0; i &lt; 7; ++i) countScan += fscanf(pf,&quot;%d&quot;,&amp;(p2-&gt;doctor.workingHours[i])); if(countScan != 7) { reSeek(pf); continue; } if(fscanf(pf,&quot;%d&quot;,&amp;(p2-&gt;treatment.total))!= 1) { reSeek(pf); continue; } int med_start,med_end,exam_start,exam_end; countScan = fscanf(pf,&quot;%d%d%d%d&quot;,&amp;med_start,&amp;med_end,&amp;exam_start,&amp;exam_end); if(countScan != 4) { reSeek(pf); continue; } countScan = fscanf(pf,&quot;%d%d&quot;,&amp;(p2-&gt;treatment.hospitalization.ruyuanshijian),&amp;(p2-&gt;treatment.hospitalization.chuyuanshijian)); if(countScan != 2) { reSeek(pf); continue; } p2-&gt;treatment.medicine.next = NULL; fgetc(pf); p2-&gt;treatment.totalMedicineCharge = buildMedList(&amp;(p2-&gt;treatment.medicine),pf_med,med_start,med_end); p2-&gt;treatment.totalExaminationFee = buildExamList(&amp;(p2-&gt;treatment.exminationFee), pf_exam,exam_start,exam_end); p1 = p2; flag = fseek(pf,-(++itr) * 123,SEEK_END); } dataRear = p1; fclose(pf); fclose(pf_exam); fclose(pf_med); return base; } int viewUTDdata(int n)//打开最新的数据文件 { system(&quot;cls&quot;); extern char departments[7][20]; extern struct Data* dataHead; struct Data* dataHeadToDel[100]; int i_del = 0; if(n &gt; 100) { printf(&quot;最多查看100条数据\\n&quot;); return -1; } time_t timep; time(&amp;timep); char location[20] = &quot;data/&quot;; strftime(location+5,sizeof(location),&quot;%m%d&quot;,localtime(&amp;timep)); location[9] = &#39;/&#39;; location[10] = 0; int count = 0; struct Data *container[120]; while(count &lt; n) { dataHead = reInput(location); struct Data *p = dataHead-&gt;next; if(!p) { free(dataHead); } else { dataHeadToDel[i_del++] = dataHead; } printf(&quot;数据日期：%c%c月%c%c日:\\n&quot;,location[5],location[6],location[7],location[8]); while(p) { container[count] = p; printf(&quot;---------------------\\n&quot;); printf(&quot;%d、 &quot;,++count); printf(&quot;序号：%d 患者姓名：%s ID:%d 患者年龄： %d &quot;, p-&gt;number, p-&gt;name,p-&gt;ID, p-&gt;age); printf(&quot;主治医生：%s %s %s 工号:%d \\n药品费： %d元%d角\\n&quot;,departments[p-&gt;doctor.department],DoctorLevel[p-&gt;doctor.level],p-&gt;doctor.name,p-&gt;doctor.number,(p-&gt;treatment.totalMedicineCharge)/10,(p-&gt;treatment.totalMedicineCharge)%10); printMedList(&amp;(p-&gt;treatment.medicine)); printf(&quot;检查费： %d元 %d角&quot;,(p-&gt;treatment.totalExaminationFee)/10,(p-&gt;treatment.totalExaminationFee)%10); printExamList(&amp;(p-&gt;treatment.exminationFee)); printf(&quot;\\n\\n\\n\\n&quot;); p = p-&gt;next; if(count &gt;= n) break; } preDay(location); } container[count] = NULL; for(;;) {printMargin(40); printf(&quot;1：按医生筛选数据\\n&quot;); printMargin(40); printf(&quot;2：按患者ID筛选数据\\n&quot;); printMargin(40); printf(&quot;3：按科室筛选数据\\n&quot;); printMargin(40); printf(&quot;0: 退出\\n&quot;); int command; for(;;) { printf(&quot;请选择：&quot;); scanInt(&amp;command,3); if((command &lt;0)||(command &gt; 3)) { printf(&quot;输入不合法\\n&quot;); } else break; } switch(command) { case 1: { int id; printf(&quot;请输入医生ID(8位):&quot;); for(;;) { if(scanInt(&amp;id,9) != 8) { printf(&quot;数据非法！请重新输入\\n&quot;); } else break; } viewByDoctorID(container,id); break; } case 2: { int id; printf(&quot;请输入患者ID(8位):&quot;); for(;;) { if(scanInt(&amp;id,9) != 8) { printf(&quot;数据非法！请重新输入\\n&quot;); } else break; } viewByPatientID(container,id); break; } case 3: { int nn; for(int i = 0; i &lt; 5; ++i) printf(&quot;%d、%s\\n&quot;,i+1,departments[i]); printf(&quot;请选择：&quot;); for(;;) { scanInt(&amp;nn,3); if((nn &lt; 1)||(nn &gt; 5)) { printf(&quot;输入非法\\n&quot;); } else break; } viewByDepart(container,nn-1); break; } case 0:break; } if(!command) break; } for(int i = 0; i &lt; i_del; ++i) clearList(dataHeadToDel[i]); return 0; } void w_countAllDoc()//统计所有医生本周的繁忙情况 { extern struct Doctor doctor_departments[5]; struct Doctor * p_doc; int count_w = 0; time_t timep; time(&amp;timep); char location[20] = &quot;data/&quot;; strftime(location+5,sizeof(location),&quot;%m%d&quot;,localtime(&amp;timep)); location[9] = &#39;/&#39;; location[10] = 0; dataHead = input(location); for(int i = 0; i &lt; 5; ++i) { p_doc = doctor_departments[i].next; while(p_doc) { p_doc-&gt;w_registed = 0; p_doc = p_doc-&gt;next; } } while(count_w &lt; 7)//打开7天的数据 { if(dataHead-&gt;next)//导入成功 { ++count_w; for(int i = 0; i &lt; 5; ++i) { p_doc = doctor_departments[i].next; while(p_doc) { struct Data * p = dataHead-&gt;next; while(p) { if(p-&gt;doctor.number == p_doc-&gt;number) { ++(p_doc-&gt;w_registed); } p = p-&gt;next; } p_doc = p_doc-&gt;next; } } } preDay(location); clearList(dataHead); dataHead = input(location); } } int showPatientsInHospital() { system(&quot;cls&quot;); printf(&quot;当前住院患者如下:\\n\\n&quot;); struct Data *p = inHospital; int count = 0; while(p) { ++count; printf(&quot;------------------------------------------------------------\\n&quot;); printf(&quot;%d、 &quot;,count); showPatientsInfo(p); printf(&quot;\\n------------------------------------------------------------\\n&quot;); printf(&quot;\\n\\n&quot;); p = p-&gt;next; } printf(&quot;按任意键返回上一级\\n&quot;); getchar(); return 0; } int scanStr(char *s, int length) { int count = 0; char c; while(count &lt; length) { c = getchar(); if(c == &#39;\\n&#39;) break; s[count++] = c; } s[count] = 0; while(c != &#39;\\n&#39;) { c = getchar(); ++count; } return count; } int dataChangeMenu() { printMargin(40); printf(&quot;执行敏感操作，需要您输入密码\\n&quot;); printf(&quot;\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); char pass[20]; char* key = deCode(); for(;;) { printf(&quot;请输入密码，若要退出系统请直接按回车:&quot;); int length = scanStr(pass,15); if(length == 0) return 0; if(strcmp(pass,key)) { printf(&quot;密码错误！\\n&quot;); } else { printf(&quot;密码正确，正在载入\\n&quot;); loading(); system(&quot;cls&quot;); break; } } free(key); for(;;) {printf(&quot;\\n\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;1、诊断记录修改\\n\\n&quot;); printMargin(40); printf(&quot;2、密码修改\\n\\n&quot;); printMargin(40); printf(&quot;0、返回主菜单\\n\\n\\n\\n\\n\\n\\n\\n&quot;); int command; for(;;) { printf(&quot;请选择序号：&quot;); scanInt(&amp;command,3); if((command &gt; 2)||(command &lt; 0)) { printf(&quot;输入非法！\\n&quot;); } else break; } if(command == 0) return 0; if(command == 1) { changeDataMenu(); } else if (command == 2) { printf(&quot;请设置新密码\\n&quot;); setPassWord(); } else { printf(&quot;系统构建中\\n\\n&quot;); printf(&quot;按任意键返回主菜单\\n\\n&quot;); getchar(); } } return 0; } int changeDoctorData(struct Doctor *p) { extern char departments[7][20]; extern const char DoctorLevel[5][12]; int command; for(;;) { printf(&quot;请选择需要修改哪一项:\\n&quot;); printf(&quot;1、医生姓名 2、 医生职级 3、医生科室\\n&quot;); scanInt(&amp;command, 2); if((command &lt; 1)||(command &gt; 3)) { printf(&quot;输入不合法，请检查 \\n&quot;); } else break; } switch(command) { case 2: { printf(&quot;请选择修改后的医生职级(输入序号):&quot;); printf(&quot;1:%s\\n2:%s\\n3:%s\\n4:%s\\n&quot;,DoctorLevel[1],DoctorLevel[2],DoctorLevel[3],DoctorLevel[4]); for(;;) { int n; scanInt(&amp;n,4); if((n &lt; 1)||(n &gt; 4)) printf(&quot;输入不合法！\\n&quot;); else { p-&gt;level = n; break; } } break; } case 1: { printf(&quot;修改姓名:&quot;); scanName(p-&gt;name,20); break; } case 3: { printf(&quot;修改科室(输入序号):&quot;); printf(&quot;1:%s\\n2:%s\\n3:%s\\n4:%s\\n5:%s\\n\\n&quot;,departments[0],departments[1],departments[2],departments[3],departments[4]); for(;;) { int n; scanInt(&amp;n,4); if((n &lt; 1)||(n &gt; 5)) printf(&quot;输入不合法！\\n&quot;); else { p-&gt;department = n-1; break; } } break; } } printf(&quot;修改成功！修改后的医生信息为：&quot;); printf(&quot;%s %s %s \\n&quot;,departments[p-&gt;department],DoctorLevel[p-&gt;level],p-&gt;name); return 0; } int changeExamList(struct ExaminationFee * head) { struct ExaminationFee *p = head-&gt;next; struct ExaminationFee * line[200]; int i = 0; while(p) { line[i] = p; printf(&quot;%d)、 项目名： %15s 单价：%5d \\n&quot;,++i,p-&gt;name,p-&gt;cost); p = p-&gt;next; } line[i] = NULL; int command; for(;;) { printf(&quot;请选择需要执行的操作：1、增加一条数据 2、删除一条数据 3、修改数据\\n&quot;); scanInt(&amp;command,3); if((command &gt;3) || (command &lt; 1)) { printf(&quot;输入不合法\\n&quot;); } else break; } switch (command) { case 1://插入一条数据 { struct ExaminationFee * pnew = (struct ExaminationFee *) malloc (sizeof(struct ExaminationFee)); pnew-&gt;next = NULL; printf(&quot;请输入检查项目名称：&quot;); scanStr(pnew-&gt;name,14); for(;;) { printf(&quot;请输入检查项目价格（格式： 元 角,最高不超过99999元） 中间用空格隔开：&quot;); int m, n; for(;;) { scanInt(&amp;m, 6); scanInt(&amp;n,3); if((m &lt; 0)||(m &gt; 99999)||(n &lt; 0)||(n &gt; 9)) { printf(&quot;请检查输入格式\\n&quot;); } else { pnew-&gt;cost = m * 10 + n; break; } } } break; } case 2://删除一条数据 { if(!i)//链表为空 { printf(&quot;没有可删除的数据\\n&quot;); break; } printf(&quot;请输入欲删除的数据序号\\n&quot;); for(;;) { int command; scanInt(&amp;command,3); if((command &lt; 0)||(command &gt; i)) { printf(&quot;请检查输入格式!\\n&quot;); } else { if(command == 1) { free(line[0]); head-&gt;next = NULL; } else { free(line[command - 1]); line[command - 2]-&gt;next = line[command]; } printf(&quot;已删除&quot;); break; } } break; } case 3://修改一条数据 { int command; struct ExaminationFee *pp; for(;;) { printf(&quot;请输入欲修改的数据序号：&quot;); scanInt( &amp;command, 3); if((command &gt; i)||(command &lt; 0)) { printf(&quot;输入不合法！\\n&quot;); } else { pp = line[command - 1]; break; } } printf(&quot;请输入检查项目名称：&quot;); scanStr(pp-&gt;name,14); for(;;) { printf(&quot;请输入检查项目价格（格式： 元 角,最高不超过99999元） 中间用空格隔开：&quot;); int m, n; for(;;) { scanInt(&amp;m, 6); scanInt(&amp;n,3); if((m &lt; 0)||(m &gt; 99999)||(n &lt; 0)||(n &gt; 9)) { printf(&quot;请检查输入格式\\n&quot;); } else { pp-&gt;cost = m * 10 + n; break; } } } break; } } p = head-&gt;next; printf(&quot;修改后数据：\\n&quot;); i = 0; while(p) { line[i] = p; printf(&quot;%d)、 项目名： %15s 单价：%5d \\n&quot;,++i,p-&gt;name,p-&gt;cost); p = p-&gt;next; } return 0; } int changeDataMenu() { extern struct Data* dataHead; char position[20] = &quot;data/&quot;; int start_m, start_d; system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n\\n&quot;); printf(&quot;要修改哪天的数据呢？\\n&quot;); inputDate(&amp;start_m,&amp;start_d); position[5] = start_m / 10 + &#39;0&#39;; position[6] = start_m % 10 + &#39;0&#39;; position[7] = start_d / 10 + &#39;0&#39;; position[8] = start_d % 10 + &#39;0&#39;; position[9] = &#39;/&#39;; position[10] = 0; dataHead = input(position); if(changeData() == -1) { printf(&quot;\\n\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;未找到这一天的数据，按任意键返回上一层\\n&quot;); getchar(); system(&quot;cls&quot;); } saveData(position); clearList(dataHead); return 0; } int setPassWord()//加密控件 { char key[21]; int length; for(;;) { printf(&quot;请输入新密码(8到16位):&quot;); length = scanStr(key,17); if((length &gt; 16)||(length &lt; 8)) { printf(&quot;请检查输入长度\\n&quot;); continue; } printf(&quot;请再次输入：&quot;); char key2[20]; scanStr(key2,18); if(strcmp(key,key2)) { printf(&quot;两次输入密码不一致，请检查\\n&quot;); continue; } break; } srand(time(0)); FILE *pf = fopen(&quot;data/key.txt&quot;,&quot;wb&quot;); for(int i = 0; i &lt; length; ++i) { for(int j = 0; j &lt; 7; ++j) { int num = rand()%128; int bi = 1 &lt;&lt; j; if(((key[i]) &amp; bi)) { num |= bi; } else num &amp;= (~bi); fwrite(&amp;num,1,1,pf); } } fclose(pf); return 0; } char * deCode() { FILE *pf = fopen(&quot;data/key.txt&quot;,&quot;rb&quot;); char *password = (char *)malloc(20); int pos = 0; int num; while(!feof(pf)) { num = 0; for(int i = 0; i &lt; 7; ++i) { int tmp; int bi = (1 &lt;&lt; i); fread(&amp;tmp,1,1,pf); num += (tmp &amp; bi); } password[pos++] = num; } password[pos-1] = 0; fclose(pf); return password; } int dataViewMenu() { printf(&quot;\\n\\n\\n\\n\\n&quot;); printMargin(40);printf(&quot;1、医生信息\\n\\n&quot;); printMargin(40);printf(&quot;2、营业额 \\n\\n&quot;); printMargin(40);printf(&quot;3、诊疗记录浏览 \\n\\n&quot;); printMargin(40);printf(&quot;0、返回上一层\\n\\n\\n\\n\\n&quot;); int command; for(;;) { printf(&quot;请选择一项（输入序号）:&quot;); scanInt(&amp;command,3); if((command &gt; 3)||(command &lt; 0)) { printf(&quot;输入非法\\n&quot;); } else break; } switch(command) { case 1: showDepartStatus(); break; case 2: { system(&quot;cls&quot;); printfMoneyStatus(); printf(&quot;按任意键返回\\n&quot;); getchar(); break; } case 3: viewData();break; case 0: break; } return 0; } int inpatientDapart() { for(;;) { system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;1、病房信息\\n\\n&quot;); printMargin(40); printf(&quot;2、住院病人管理\\n\\n&quot;); printMargin(40); printf(&quot;0、返回主菜单\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); int command = 0; for(;;) { scanInt(&amp;command, 3); if((command &lt; 0)||(command &gt; 3)) printf(&quot;输入不合法\\n&quot;); else break; } if(command == 1) { showPatientsInHospital(); } else if(command == 2) patientAdminMenu(); else break; } return 0; } int printMargin(int n) { for (int i = 0; i &lt; n; i++) printf(&quot; &quot;); return 0; } void loading() { system(&quot;color f0&quot;); int i, j; printf(&quot;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); for (i = 1; i &lt;= 10; i++) { printf(&quot;\\t\\t\\t\\t\\t\\t欢迎使用|&quot;); for (j = 0; j &lt; i; j++) printf(&quot;-&quot;); printf(&quot;|&#39;%d%%&#39;\\r&quot;, i*10); Sleep(50); } system(&quot;cls&quot;); } int countPatient(int id, int departmentID)//根据病人id，统计它在某个科室挂了多少号 { extern struct Data *dataHead; struct Data * p = dataHead; int num = 0; while(p) { if((p-&gt;ID == id)&amp;&amp;(p-&gt;doctor.department == departmentID)) { ++num; } p = p-&gt;next; } return num; } int countPatientDoc(int id, int doctorID)//根据病人id，统计它在某个医生名下挂了多少号 { extern struct Data *dataHead; struct Data * p = dataHead; int num = 0; while(p) { if((p-&gt;ID == id)&amp;&amp;(p-&gt;doctor.number == doctorID)) { ++num; } p = p-&gt;next; } return num; } int saveMedData() { extern struct Medicine* mediStorage; struct Medicine * p = mediStorage-&gt;next; FILE * pf = fopen(&quot;hospital/medicine.txt&quot;,&quot;w&quot;); int i = 0; while(p) { fprintf(pf,&quot;%06d %16s %3d %4d\\n&quot;,++i,p-&gt;name,p-&gt;number,p-&gt;price); p = p-&gt;next; } fprintf(pf,&quot;%8d&quot;, i); fclose(pf); return 0; } int reSeek(FILE *pf) { char c = 0; while((c != &#39;\\n&#39;)&amp;&amp;(c != EOF)) { c = fgetc(pf); } return 0; } //文件view.h #ifndef HOUSJ_H_INCLUDED #define HOUSJ_H_INCLUDED int viewByDoctorID(struct Data ** container, int ID);//按医生工号筛选诊疗信息 int viewByDepart(struct Data ** container, int ID);//按科室筛选诊疗信息 int viewByPatientID(struct Data ** container, int ID);//按患者ID筛选诊疗信息 int countPatientDoc(int id, int doctorID);//根据病人id，统计它在某个医生名下挂了多少号 int countPatient(int id, int departmentID);//根据病人id，统计它在某个科室挂了多少号 void countAllDoc();//统计所有医生的挂号数量 void printMedList(struct Medicine * head);//输出某位患者的购药单 void printExamList(struct ExaminationFee * head);//输出某位患者的检查单 int showPatientsInHospital();//展示病房信息 int showPatientsInfo(struct Data *node);//展示住院病人的信息 int viewDataSpan();//按时间区间浏览历史诊疗记录 int printDataList(struct Data * base);//输出所建链表的所有数据 #endif // HOUSJ_H_INCLUDED //文件view.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include &lt;io.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include&lt;windows.h&gt; #include&quot;basic.h&quot; #include&quot;view.h&quot; #include&quot;change.h&quot; /*打印head链表的所有的诊疗记录*/ int printDataList(struct Data * base)//返回值为链表的有效结点数 { if(base-&gt;next == NULL) return -1; struct Data *p = base-&gt;next; printf(&quot;正在打印数据...：\\n\\n&quot;); int i = 0; while(p) { printf(&quot;---------------------\\n&quot;); printf(&quot;%d、 &quot;,++i); printSingleData(p); printf(&quot;\\n\\n\\n\\n&quot;); p = p-&gt;next; } return i; } int viewByDoctorID(struct Data ** container, int ID) { int itr = 0; int i = 0; int count = 0; while(container[itr]) { if(container[itr]-&gt;doctor.number == ID) { ++i; printf(&quot;%d、&quot;,++count); printSingleData(container[itr]); printf(&quot;\\n\\n&quot;); } ++itr; } if(!i) { printMargin(40); printf(&quot;未找到任何数据！\\n&quot;); printMargin(40); printf(&quot;按任意键返回上一层\\n&quot;); getchar(); return 0; } return 0; } int viewByDepart(struct Data ** container, int ID) { int itr = 0; int count = 0; int i = 0; while(container[itr]) { if(container[itr]-&gt;doctor.department == ID) { printf(&quot;%d、&quot;,++count); printSingleData(container[itr]); printf(&quot;\\n\\n&quot;); ++i; } ++itr; } if(!i) { printMargin(40); printf(&quot;未找到任何数据！\\n&quot;); printMargin(40); printf(&quot;按任意键返回上一层\\n&quot;); getchar(); return 0; } return 0; } int viewByPatientID(struct Data ** container, int ID) { int itr = 0; int count = 0; int i = 0; while(container[itr]) { if(container[itr]-&gt;ID == ID) { printf(&quot;%d、&quot;,++count); printSingleData(container[itr]); printf(&quot;\\n\\n&quot;); ++i; } ++itr; } if(!i) { printMargin(40); printf(&quot;未找到任何数据！\\n&quot;); printMargin(40); printf(&quot;按任意键返回上一层\\n&quot;); getchar(); return 0; } return 0; } /*打印购药链表*/ void printMedList(struct Medicine * head) { struct Medicine *p = head-&gt;next; if(!p) return; printf(&quot; ***所购药品如下:*** \\n\\n&quot;); int i = 0; while(p) { printf(&quot;%d)、 药品名：%s 数量：%d, 单价：%d元 %d角 \\n&quot;,++i,p-&gt;name,p-&gt;number,(p-&gt;price)/10,(p-&gt;price)%10); p = p-&gt;next; } printf(&quot; \\n\\n&quot;); } /*打印所做检查项目链表*/ void printExamList(struct ExaminationFee * head) { struct ExaminationFee *p = head-&gt;next; if(!p) return; printf(&quot;\\n ***所做检查项目如下:*** \\n\\n&quot;); int i = 0; while(p) { printf(&quot;检查项目%d： %s 价格：%d 元 %d 角 \\n&quot;,++i,p-&gt;name,(p-&gt;cost)/10,(p-&gt;cost)%10); p = p-&gt;next; } } int viewDataSpan()//可以手动输入日期获取该日期的诊疗记录 { extern struct Data * dataHead; extern char departments[7][20]; char endPosition[20] = &quot;data/&quot;; char position[20] = &quot;data/&quot;; int start_m, start_d; int end_m, end_d; printf(&quot;注意：您最多查看30天的数据\\n&quot;); for(;;) { printf(&quot;请输入需要查看的起始日期\\n&quot;); inputDate(&amp;start_m,&amp;start_d); int tmp1 = start_m * 1000000; tmp1 += (start_d * 10000); printf(&quot;请输入需要查看的结束日期\\n&quot;); inputDate(&amp;end_m, &amp;end_d); int tmp2 = end_m * 1000000; tmp2 += (end_d * 10000); int aa = timeSpan(tmp1,tmp2); if(aa &gt; 30) { printf(&quot;最多查看30天的数据，请重新输入！\\n&quot;); } else break; } position[5] = start_m / 10 + &#39;0&#39;; position[6] = start_m % 10 + &#39;0&#39;; position[7] = start_d / 10 + &#39;0&#39;; position[8] = start_d % 10 + &#39;0&#39;; position[9] = &#39;/&#39;; position[10] = 0; endPosition[5] = end_m / 10 + &#39;0&#39;; endPosition[6] = end_m % 10 + &#39;0&#39;; endPosition[7] = end_d / 10 + &#39;0&#39;; endPosition[8] = end_d % 10 + &#39;0&#39;; endPosition[9] = &#39;/&#39;; position[10] = 0; struct Data* container[300]; int itr = 0; struct Data* dataHeadToDel[100]; int i_del = 0; while(strcmp(position,endPosition) &lt;= 0) { dataHead = input(position); struct Data * p = dataHead-&gt;next; if(!p) { free(dataHead); } else dataHeadToDel[itr++] = dataHead; while(p) { printf(&quot;%d、&quot;,itr+1); printSingleData(p); container[itr++]= p; p = p-&gt;next; } nextDay(position); } container[itr] = NULL; if(!itr) { printMargin(40); printf(&quot;未找到该时间段的任何数据！\\n&quot;); printMargin(40); printf(&quot;按任意键返回上一层\\n&quot;); getchar(); return 0; } for(;;) {printMargin(40); printf(&quot;1：按医生筛选数据\\n&quot;); printMargin(40); printf(&quot;2：按患者ID筛选数据\\n&quot;); printMargin(40); printf(&quot;3：按科室筛选数据\\n&quot;); printMargin(40); printf(&quot;0: 退出\\n&quot;); int command; for(;;) { printf(&quot;请选择：&quot;); scanInt(&amp;command,3); if((command &lt;0)||(command &gt; 3)) { printf(&quot;输入不合法\\n&quot;); } else break; } switch(command) { case 1: { int id; printf(&quot;请输入医生ID(8位):&quot;); for(;;) { if(scanInt(&amp;id,9) != 8) { printf(&quot;数据非法！请重新输入\\n&quot;); } else break; } viewByDoctorID(container,id); break; } case 2: { int id; printf(&quot;请输入患者ID(8位):&quot;); for(;;) { if(scanInt(&amp;id,9) != 8) { printf(&quot;数据非法！请重新输入\\n&quot;); } else break; } viewByPatientID(container,id); break; } case 3: { int nn; for(int i = 0; i &lt; 5; ++i) printf(&quot;%d、%s\\n&quot;,i+1,departments[i]); printf(&quot;请选择：&quot;); for(;;) { scanInt(&amp;nn,3); if((nn &lt; 1)||(nn &gt; 5)) { printf(&quot;输入非法\\n&quot;); } else break; } viewByDepart(container,nn-1); break; } case 0: break; } if(!command) break; } for(int i = 0; i &lt; i_del; ++i) clearList(dataHeadToDel[i]); return 0; } int showPatientsInfo(struct Data *node) { /*日期格式：09020900*/ int in_mon = node-&gt;treatment.hospitalization.ruyuanshijian/1000000; int in_day = (node-&gt;treatment.hospitalization.ruyuanshijian/10000)%100; int in_hou = (node-&gt;treatment.hospitalization.ruyuanshijian/100) % 100; int out_mon = node-&gt;treatment.hospitalization.chuyuanshijian/1000000; int out_day = (node-&gt;treatment.hospitalization.chuyuanshijian/10000)%100; int out_hou = (node-&gt;treatment.hospitalization.chuyuanshijian/100) % 100; char sexstr[2][4] = {&quot;女&quot;,&quot;男&quot;}; int sex = (node-&gt;number % 100000) / 10000; printf(&quot;ID: %d 姓名:%5s 性别：%s 年龄:%2d &quot;,node-&gt;ID,node-&gt;name,sexstr[sex],node-&gt;age); printf(&quot;入院时间： %2d月 %2d日 %2d时 预计出院时间: %2d月 %2d日 %2d时 &quot;,in_mon,in_day,in_hou,out_mon,out_day,out_hou); time_t now; struct tm* tm_now; time(&amp;now); tm_now = localtime(&amp;now); int now_time = (tm_now-&gt;tm_mon+1)*1000000 + tm_now-&gt;tm_mday * 10000 + tm_now-&gt;tm_hour * 100; int cost = 200*timeSpan(node-&gt;treatment.hospitalization.ruyuanshijian,now_time); printf(&quot;总缴纳押金:%d&quot;,node-&gt;treatment.hospitalization.zhuyuanyajin); printf(&quot;住院押金剩余：%d&quot;,node-&gt;treatment.hospitalization.zhuyuanyajin - cost); if(node-&gt;treatment.hospitalization.zhuyuanyajin - cost &lt; 1000) { HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(handle, 0xFC); printMargin(30); printf(&quot;余额不足！&quot;); SetConsoleTextAttribute(handle, 0xF0); } return 0; } //文件change.h #ifndef ZHANGWY_H_INCLUDED #define ZHANGWY_H_INCLUDED int changePatientData(struct Data *p);//修改患者基本信息 int changeDoctorData(struct Doctor *p);//修改数据中的医生信息 int changeMedList(struct Medicine * head);//修改数据中的购药信息 int changeExamList(struct ExaminationFee * head);//修改数据中的检查项目信息 int changeHospitalData(struct Hospitalization *base);//修改数据中的住院信息 int changeData();//修改挂号数据的主界面 #endif // ZHANGWY_H_INCLUDED //文件change.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include &lt;io.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include&lt;windows.h&gt; #include&quot;basic.h&quot; #include&quot;view.h&quot; #include&quot;change.h&quot; int changePatientData(struct Data *p) { int command; for(;;) { printf(&quot;请选择需要修改哪一项:\\n&quot;); printf(&quot;1、挂号序列 2、 姓名 3、年龄 4、ID \\n&quot;); scanInt(&amp;command, 2); if((command &lt; 1)||(command &gt; 4)) { printf(&quot;输入不合法，请检查 \\n&quot;); } else break; } switch(command) { case 1: { printf(&quot;请重新输入挂号序列（9位正整数）:&quot;); for(;;) { if(scanInt(&amp;(p-&gt;number),9)==9) break; else { printf(&quot;请正确输入！\\n&quot;); } } break; } case 2: { printf(&quot;修改姓名:&quot;); scanName(p-&gt;name,20); break; } case 3: { printf(&quot;修改年龄:&quot;); for(;;) { scanInt(&amp;(p-&gt;age), 4); if((p-&gt;age &lt;0) || (p-&gt;age &gt; 140)) { printf(&quot;输入不合法，请检查！\\n&quot;); } else break; } break; } case 4: { printf(&quot;修改ID(8位正整数):&quot;); for(;;) { if(scanInt(&amp;(p-&gt;ID),8) == 8) break; else { printf(&quot;请正确输入!\\n&quot;); } } break; } } printf(&quot;修改成功！修改后的患者信息为：&quot;); printf(&quot;挂号序列：%d 患者姓名：%s ID:%d 患者年龄： %d &quot;, p-&gt;number, p-&gt;name,p-&gt;ID, p-&gt;age); return 0; } int changeData() { system(&quot;cls&quot;); extern struct Data *dataHead; struct Data* p = dataHead-&gt;next; int command; struct Data* line[300]; if(dataHead-&gt;next == NULL) return -1; int i = 0; while(p) { line[i] = p; printf(&quot;---------------------\\n&quot;); printf(&quot;%d、 &quot;,++i); printSingleData(p); p = p-&gt;next; } line[i] = NULL; for(;;) { printMargin(40); printf(&quot;1:删除数据\\n\\n&quot;); printMargin(40); printf(&quot;2:修改数据\\n\\n&quot;); printMargin(40); printf(&quot;0:返回上一层\\n\\n\\n\\n\\n\\n\\n\\n请输入:&quot;); scanInt(&amp;command,3); if((command &gt; 2)||(command &lt;0)) { printf(&quot;输入不合法\\n&quot;); } else break; } if(!command) return 0; if(command == 1) { for(;;) { printf(&quot;您要删除哪条数据？\\n&quot;); int n; scanInt(&amp;n,3); if((n &gt; i)||(n &lt; 1)) printf(&quot;输入不合法！\\n&quot;); else { free(line[n-1]); if(n == 1) dataHead-&gt;next = line[1]; else line[n-2]-&gt;next = line[n]; break; } } system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;删除成功！按任意键返回上一层&quot;); getchar(); return 0; } for(;;) { printf(&quot;请输入需要修改的数据序号(输入0返回上一层):&quot;); scanInt(&amp;command,2); if((command &gt; i)||(command &lt; 0)) { printf(&quot;请检查输入\\n&quot;); } else break; } if(!command) return 0; p = line[command-1]; printf(&quot;\\n\\n\\n\\n&quot;); printMargin(10); printSingleData(p); printf(&quot;\\n\\n请选择修改哪项数据？\\n\\n\\n\\n\\n&quot;); printMargin(10); printf(&quot;1:患者基本信息\\n\\n&quot;); printMargin(10); printf(&quot;2:医生信息\\n\\n&quot;); printMargin(10); printf(&quot;3:购药信息\\n\\n&quot;); printMargin(10); printf(&quot;4:检查项目信息\\n\\n&quot;); printMargin(10); printf(&quot;5:住院信息\\n\\n&quot;); printMargin(10); printf(&quot;0:退出页面\\n\\n&quot;); printMargin(10); for(;;) { scanInt(&amp;command,3); if((command &lt; 0)||(command &gt; 5)) { printf(&quot;输入不合法，请检查！\\n&quot;); } else break; } switch(command) { case 1: changePatientData(p);break; case 2: changeDoctorData(&amp;(p-&gt;doctor));break; case 3: changeMedList(&amp;(p-&gt;treatment.medicine)); break; case 4: changeExamList(&amp;(p-&gt;treatment.exminationFee)); break; case 5: changeHospitalData(&amp;(p-&gt;treatment.hospitalization));break; case 0: break; } system(&quot;cls&quot;); printf(&quot;\\n\\n\\n&quot;); printf(&quot;修改后的完整数据：\\n&quot;); printSingleData(p); printf(&quot;\\n\\n\\n&quot;); printf(&quot;按任意键返回主菜单！&quot;); getchar(); return 0; } int changeHospitalData(struct Hospitalization *base) { int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31}; printf(&quot;请输入入院时间,格式：月 日 时如： \\&quot;9 10 10\\&quot;,数字间以空格间隔 \\n&quot;); int m,d,h,s; base-&gt;zhuyuanyajin = 0; for(;;) { scanInt(&amp;m, 2); scanInt(&amp;d, 2); scanInt(&amp;h, 2); s = 0; if((m &gt; 0)&amp;&amp;(m &lt; 13)&amp;&amp;(d &gt; 0)&amp;&amp; (d &lt;= months[m])&amp;&amp;(h &gt;= 0)&amp;&amp;(h &lt; 24)&amp;&amp;(s &gt;= 0)&amp;&amp;(s &lt; 60)) { break; } printf(&quot;请检查输入格式重新输入:&quot;); } int time1 = m * 1000000; time1 += (d * 10000); time1 += (h * 100); base-&gt;ruyuanshijian = time1; int m1,d1,h1,s1; printf(&quot;请输入出院时间,格式：月 日 时如： \\&quot;9 10 10\\&quot;,数字间以空格间隔 \\n&quot;); for(;;) { scanInt(&amp;m1, 2); scanInt(&amp;d1, 2); scanInt(&amp;h1, 2); s1 = 0; if((m1 &gt; 0)&amp;&amp;(m1 &lt; 13)&amp;&amp;(d1 &gt; 0)&amp;&amp; (d1 &lt;= months[m])&amp;&amp;(h1 &gt;= 0)&amp;&amp;(h1 &lt; 24)) { int n1 = m; n1 = n1 * 40 + d; n1 = n1 * 30 + h; n1 = n1 * 60 + s; int n2 = m1; n2 = n2 * 40 + d1; n2 = n2 * 30 + h1; n2 = n2 * 60 + s1; if(n1 &lt; n2) break; else { printf(&quot;请保证出院时间晚于入院时间\\n&quot;); } } printf(&quot;请重新输入出院时间:&quot;); } time1 = m1 * 1000000; time1 += (d1 * 10000); time1 += (h1 * 100); time1 += (s1); base-&gt;chuyuanshijian = time1; printf(&quot;入院时间：%d月 %d日 %d时 &quot;,(base-&gt;ruyuanshijian)/1000000,((base-&gt;ruyuanshijian)%1000000)/10000,((base-&gt;ruyuanshijian)%10000)/100); printf(&quot;出院时间：%d月 %d日 %d时 \\n&quot;,(base-&gt;chuyuanshijian)/1000000,((base-&gt;chuyuanshijian)%1000000)/10000,((base-&gt;chuyuanshijian)%10000)/100); return 0; } int changeMedList(struct Medicine * head) { struct Medicine *p = head-&gt;next; struct Medicine * line[200]; int i = 0; while(p) { line[i] = p; printf(&quot;%d)、 药品名：%s 数量：%d, 单价：%d \\n&quot;,++i,p-&gt;name,p-&gt;number,p-&gt;price); p = p-&gt;next; } line[i] = NULL; int command; for(;;) { printf(&quot;请选择需要执行的操作：1、增加一条数据 2、删除一条数据 3、修改数据\\n&quot;); scanInt(&amp;command,3); if((command &gt;3) || (command &lt; 1)) { printf(&quot;输入不合法\\n&quot;); } else break; } switch (command) { case 1://插入一条数据 { struct Medicine * pnew = (struct Medicine *) malloc (sizeof(struct Medicine)); pnew-&gt;next = NULL; printf(&quot;请输入药品名称：&quot;); scanStr(pnew-&gt;name,14); printf(&quot;请输入药品单价,\\(格式 \\&quot; 元 角 \\&quot; ,不得超过999元):&quot;); int m,n; for(;;) { scanInt(&amp;n,6); scanInt(&amp;m,5); if((n &lt; 0)||(n &gt; 999)||(m &gt; 9)||(m &lt; 0)) { printf(&quot;请检查输入格式\\n&quot;); } else { pnew-&gt;price = n*10 + m; break; } } printf(&quot;请输入药品数量，不得超过999&quot;); for(;;) { scanInt(&amp;m,4); if((m &lt; 0)||(m &gt; 999)) { printf(&quot;数据不合法\\n&quot;); } else { pnew-&gt;number = m; break; } } head-&gt;next = pnew; pnew-&gt;next = line[0]; break; } case 2://删除一条数据 { if(!i)//链表为空 { printf(&quot;没有可删除的数据\\n&quot;); break; } printf(&quot;请输入欲删除的数据序号\\n&quot;); for(;;) { int command; scanInt(&amp;command,3); if((command &lt; 0)||(command &gt; i)) { printf(&quot;请检查输入格式!\\n&quot;); } else { if(command == 1) { free(line[0]); head-&gt;next = NULL; } else { free(line[command - 1]); line[command - 2]-&gt;next = line[command]; } printf(&quot;已删除&quot;); break; } } break; } case 3://修改一条数据 { int command; struct Medicine *pp; for(;;) { printf(&quot;请输入欲修改的数据序号：&quot;); scanInt( &amp;command, 3); if((command &gt; i)||(command &lt; 0)) { printf(&quot;输入不合法！\\n&quot;); } else { pp = line[command - 1]; break; } } printf(&quot;请输入药品名称：&quot;); scanStr(pp-&gt;name,14); printf(&quot;请输入药品单价,（格式 “元 角” ,不得超过999元）:&quot;); int m,n; for(;;) { scanInt(&amp;n,6); scanInt(&amp;m,5); if((n &lt; 0)||(n &gt; 999)||(m &gt; 9)||(m &lt; 0)) { printf(&quot;请检查输入格式\\n&quot;); } else { pp-&gt;price = n*10 + m; break; } } printf(&quot;请输入药品数量，不得超过999&quot;); for(;;) { scanInt(&amp;m,4); if((m &lt; 0)||(m &gt; 99)) { printf(&quot;数据不合法\\n&quot;); } else { pp-&gt;number = m; break; } } break; } } p = head-&gt;next; printf(&quot;修改后数据：\\n&quot;); while(p) { line[i] = p; printf(&quot;%d)、 药品名：%s 数量：%d, 单价：%d \\n&quot;,++i,p-&gt;name,p-&gt;number,p-&gt;price); p = p-&gt;next; } return 0; } 附件：1、工程源文件.zip2、实验报告.docx 注：工程使用codeblocks:: 17.12编译","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C语言","slug":"编程/C语言","permalink":"/categories/编程/C语言/"}],"tags":[{"name":"课设","slug":"课设","permalink":"/tags/课设/"},{"name":"C语言","slug":"C语言","permalink":"/tags/C语言/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C语言","slug":"编程/C语言","permalink":"/categories/编程/C语言/"}]},{"title":"BBC news 10/10 白宫的“超级传播事件”","slug":"BBCnews2020 10 10","date":"2020-10-10T15:00:01.000Z","updated":"2020-10-11T15:33:06.450Z","comments":true,"path":"2020/10/10/BBCnews2020 10 10/","link":"","permalink":"/2020/10/10/BBCnews2020 10 10/","excerpt":"","text":"本报道在2020/10/10日 BBC new官网中浏览量排在第一位 White House hosted Covid ‘superspreader’ event, says Dr FauciTop US virus expert Dr Anthony Fauci has criticised the White House for hosting a gathering last month that has been linked to an outbreak of Covid-19.Dr Fauci, a member of the White House coronavirus task force, said the unveiling of President Donald Trump’s nominee to the Supreme Court was a “superspreader event”.At least 11 people who attended the event on 26 September tested positive.Mr Trump is himself recovering from Covid-19.His doctors have just cleared him to hold public events, less than a month before he faces Democratic candidate Joe Biden in the presidential election.Mr Trump has expressed scepticism about measures such as masks and lockdowns to combat the spread of Covid-19, which has killed more than 213,000 people in the US. He has talked up the prospects of a vaccine becoming available, although researchers say this is unlikely to happen before next year at the earliest.Polling suggests Mr Biden has a single-digit lead over Mr Trump and an ABC News/Ipsos poll found that just 35% of Americans approved of how Mr Trump has handled the crisis. What did Dr Fauci say?CBS News asked on Friday what Dr Fauci thought of the White House’s reluctance to insist on mask-wearing and social distancing as virus precautions, and instead rely on regular testing.“The data speak for themselves - we had a superspreader event in the White House, and it was in a situation where people were crowded together and were not wearing masks.”An event at the White House on Saturday 26 September, for the president’s nomination of Amy Coney Barrett as a Supreme Court justice, is thought to be the root of the localised outbreak.As well as President Trump and his wife Melania, those who attended and later tested positive included two senators, the White House press secretary and former Trump counsellor Kellyanne Conway.Dr Fauci also noted experts have been recommending mask-wearing for the last six months, and condemned talk of a coronavirus “cure” - a word Mr Trump has used in reference to the experimental Covid-19 treatments he received during his recent stay at a military hospital.Large gatherings are still banned in the US capital due to Covid-19, but federal property like the White House is exempt. How is Mr Trump’s health?Mr Trump - who was discharged from hospital on Monday after three nights - was asked in an interview with Fox News on Friday evening about the symptoms he had experienced.The president said he had not felt strong, but had found no problem breathing.Asked if he had re-tested for coronavirus on Friday, the president said he was at “either the bottom of the scale or free”, though he did not say his results were negative. What events does he have planned?On Saturday, which according to his doctors will be 10 days since his diagnosis, Mr Trump will give a speech from the White House balcony to a group gathered on the South Lawn.Hundreds of people have reportedly been invited.All attendees will be required to wear masks, will be given temperature checks and encouraged to social distance, said the White House.Mr Trump’s remarks will be on the subject of “law and order”, according to the White House, which adds that it is a presidential rather than a campaign event.There will also be an event by the group Blexit, a campaign urging black voters to reject the Democratic party.On Monday the Trump campaign is planning a big rally in Sanford, Florida. What about the debates?Next week’s second presidential debate between Mr Trump and his Democratic White House challenger Joe Biden is now officially cancelled.The Commission on Presidential Debates said in a statement on Friday that both campaigns had announced “alternate plans for that date”.Mr Trump had baulked at a request from the commission to hold the 15 October showdown virtually to minimise the risk of spreading coronavirus.The commission said it was still making arrangements for the third and final presidential debate in Nashville, Tennessee, on 22 October.The Trump campaign said the commission was “biased” towards Mr Biden, while the Democrat’s team accused the president of ducking the debate. Who has tested positive in Mr Trump’s circle?The announcement of Mr Trump’s first mass gathering since his infection triggered alarms in Washington, where officials are still attempting to contact trace attendees from the White House event.Mr Trump tested positive for Covid-19 last Thursday, according to his doctors, but he has not said when his last negative test was.As many as 34 White House aides and other contacts have tested positive for Covid-19 in recent days, according to US media.On Friday, the Minnesota Department of Health said nine infections have been tied to Mr Trump’s 18 September campaign rally in the state.At least one person was infectious when they attended, officials say, and two cases have led to hospital admissions, with one of those people in intensive care. 译： 福奇说，白宫发生了新冠病毒“超级传播者”事件美国顶尖病毒专家安东尼·福奇博士（Anthony Fauci）批评白宫上个月举办了一次与Covid-19爆发有关联的聚会。白宫冠状病毒特别工作组成员福奇博士表示，唐纳德·特朗普总统揭晓最高法院法官人选的仪式是一次“超级传播者事件”。9月26日参加活动的人中，至少11人检测呈阳性。特朗普先生本人正在从Covid-19中恢复。他的医生刚刚批准他举行公开活动，不到一个月，他将在总统选举中面对民主党候选人拜登。特朗普先生对口罩和封锁等措施遏制新冠病毒蔓延的效果表示怀疑，该疾病在美国已造成21.3万人死亡。尽管研究人员说在明年之前不可能用上疫苗，但他还是谈到了疫苗的前景。民调显示，拜登领先特朗普个位数，ABC新闻/益普索(ABC News/Ipsos)的民调发现，只有35%的美国人认可特朗普处理这场危机的方式。（has a single-digit lead over 是在个位上领先，还是指领先一位数呢？😳） 福奇博士说了什么？哥伦比亚广播公司（CBS）新闻周五询问福奇博士，对于白宫不愿坚持戴口罩和社交距离作为病毒预防措施，而是依赖定期检测的做法他有何看法。“数据已经说明了一切—白宫发生了一场超级传播者活动，当时人们挤在一起，没有戴口罩。”9月26日星期六在白宫举行了一场活动，艾米·康尼·巴雷特（Amy Coney Barrett）被总统提名为最高法院大法官，这被认为是局部爆发的根源。除了特朗普总统和他的妻子梅拉尼亚外，参加会议并随后被测试为阳性的人包括两名参议员：白宫新闻秘书和前特朗普顾问凯利安·康威。福奇博士还指出，过去6个月来，专家们一直建议戴口罩。他还谴责了有关冠状病毒“治愈”的言论—特朗普使用这个词是指他最近在一家军队医院接受新冠肺炎的实验性治疗。由于新冠病毒，美国首都至今仍禁止举行大型集会，但白宫却不需要理会禁令。 特朗普先生健康状况如何？特朗普在三晚后于周一出院，周五晚接受福克斯新闻采访时被问及他所经历的症状。总统说，他感觉身体不太强壮，但没有发现呼吸问题。当被问及他是否在周五重新检测过冠状病毒时，总统说他“要么处于很低的水平，要么是不必担心的”，尽管他没有说他的结果是阴性的。 特朗普有哪些计划周六，特朗普先生将在白宫阳台向聚集在白宫南草坪的一群人发表演讲。根据他的医生的说法，周六是他确诊后的第10天。据报道，已有数百人被邀请。白宫表示，所有与会者都将被要求戴口罩，并会被测温，并鼓励保持社交距离。白宫表示，特朗普的讲话将围绕“法律和秩序”这一主题，并补充说，这是一场总统活动，而不是竞选活动。还将有Blexit组织的一项活动，旨在敦促黑人选民拒绝民主党。周一，特朗​​普竞选活动计划在佛罗里达州桑福德举行一次大型集会。 关于选举…特朗普先生与他的民主党白宫挑战者乔·拜登之间下周的第二次总统辩论现已正式取消。总统辩论委员会在周五的一份声明中说，两个竞选团队都宣布了“这一天的替代计划”。委员会要求特朗普在10月15日摊牌，实际上是为了将冠状病毒传播的风险降至最低，但特朗普拒绝了这一要求。该委员会表示，他们仍在为10月22日在田纳西州纳什维尔举行的第三次也是最后一次总统辩论做安排。特朗普竞选活动说，该委员会”偏向”拜登，而民主党团队则指责总统回避辩论。 特朗普周围还有谁被检测为阳性？特朗普在确认感染后首次举行群众集会，这一消息在华盛顿引发了警觉，华盛顿的工作人员们仍在尝试联系和追踪白宫事件的参加者。据特朗普的医生称，他上周四的新冠肺炎检测呈阳性，但他没有说他最后一次阴性测试是什么时候。美媒称，在最近一段时间，多达34名白宫助手和其他有关联的人的新冠肺炎检测呈阳性。周五，明尼苏达州卫生部表示，9例感染与特朗普9月18日在该州举行的竞选集会有关。卫生部相关人员表示，至少有一个人在就诊时被传染，而且有两个病例导致入院，其中一个人接受了重症监护。","categories":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"BBC","slug":"英语新闻/BBC","permalink":"/categories/英语新闻/BBC/"}],"tags":[{"name":"BBC","slug":"BBC","permalink":"/tags/BBC/"}],"keywords":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"BBC","slug":"英语新闻/BBC","permalink":"/categories/英语新闻/BBC/"}]},{"title":"鱼书笔记 第三章 神经网络","slug":"鱼书笔记 第三章 神经网络","date":"2020-10-02T13:13:58.950Z","updated":"2020-10-04T13:26:03.353Z","comments":true,"path":"2020/10/02/鱼书笔记 第三章 神经网络/","link":"","permalink":"/2020/10/02/鱼书笔记 第三章 神经网络/","excerpt":"","text":"上一章谈到感知机。理论上感知机能表示任意的复杂函数，但是它有很明显的缺点：权重必须手动设定。而本章介绍的神经网络，它的一个重要性质就是可以自动地从数据中学习到合适的权重参数。 一、从感知机到神经网络1)神经网络的例子神经网络分为三层：分别为输入层、中间层、输出层。由于中间层是不可见的，也被称为“隐藏层”。本书把这三层依次称为第0层、第一层、第二层。在连接方式上，神经网络与感知机没有区别。 2)再论感知机感知机的函数可以表达为z = \\begin{cases}1, ux + vy + b > 0 \\\\0, ux + vy + b \\leq 0\\end{cases} 其中x、y为输入,b为偏置。这样的感知机在实现时便需要对x、 y、 b分开处理。其实我们可以将x、y、b 统一处理。假设b也是一个输出、并且它的值恒为b，权重恒为1。另外，我们可以引入函数h(x),h(x) = \\begin{cases}1, x > 0 \\\\ 0, x \\leq 0 \\end{cases}, 这样，上面的函数可以表示为$h(ux + vy + b)$. 3)激活函数登场上面提到的$h(x)$,它可以将输入信号的总和处理成输出信号，这个函数便称为激活函数。激活函数的计算过程也就可以拆分为： 计算 c = ux + vy + b. c 计算所有输入信号的加权和 计算 $h(c)$ 二、激活函数前面介绍的激活函数，以某个阈值为界，当输入超过阈值后就改变输出，这种函数称为阶跃函数，激活函数还有其他的类型 1)sigmoid函数神经网络中经常用到sigmiod函数 h(x) = \\frac{1}{1+e^{-x}}e即是自然对数的底数。感知机和神经元的主要区别就在于激活函数 2）阶跃函数的实现前面的阶跃函数只能处理数组。下面我们写一个能处理矩阵的阶跃函数: import numpy as np def step_function(x): y = x &gt; 0 return y.astype(np.int) x = np.array([-1.0, 1.0, 2.0]) print(step_function(x)) 输出为 [0 1 1] astyped()的方法可以将矩阵元素转换为期望的类型。上面是将bool型转换为np.int型 3）阶跃函数的图像运用matplotlib import numpy as np import matplotlib.pylab as plt def step_function(x): return np.array(x &gt; 0, dtype=np.int) x = np.array([-1.0, 1.0, 2.0]) x = np.arange(-5.0,5.0,0.1) y = step_function(x) plt.plot(x, y) plt.ylim(-0.1, 1.1) # 指定y轴范围 plt.show() 得到的图像如图： 它的函数值呈阶梯形变化，故称阶跃函数 4) sigmoid函数的实现import numpy as np import matplotlib.pylab as plt def sigmoid(x): return 1 / (1 + np.exp(-x)) x = np.arange(-5.0,5.0,0.1) y = sigmoid(x) plt.plot(x, y) plt.ylim(-0.1, 1.1) # 指定y轴范围 plt.show() 函数图像如图： 5）sigmoid函数和阶跃函数的比较 不同点：阶跃函数是“间断”的，sigmoid函数是连续变化的。 相同点：两者的函数值均在0和1之间 6）线性函数与非线性函数阶跃函数和sigmoid函数还有一个共同点：两者均是非线性函数。神经网络的激活函数必须是非线性函数。否则，加深神经网络的层数就没有意义了。线性函数无论如何叠加，其效果均为线性 7) ReLU函数ReLU函数最近被广泛用作激活函数，其表达式为： h(x) = \\begin{cases} x, (x > 0) \\\\0, ( x \\leq 0)\\end{cases}其代码实现： def relu(x): return np.maximum(0,x) 三、多维数组的运算1)多维数组import numpy as np A = np.array([[1,2],[1,4],[8,9]]) print(A) print(np.ndim(A)) # A的维数 print(A.shape) # A的形状 输出结果： [[1 2] [1 4] [8 9]] 2 (3, 2) 2）矩阵的点积（内积）运算：import numpy as np A = np.array([[1,2],[1,4],[8,9]]) B = np.array([[1,2,3],[1,3,4]]) print(np.dot(A,B)) 输出为： [[ 3 8 11] [ 5 14 19] [17 43 60]] 而矩阵运算在神经网络中有什么意义？以上面这段代码为例：A 相当于输入信号， B相当于权重A 有三组输入数据，每组分别有两个量（即为x, y）B 有三个神经元，第一个神经元的权重分别为1、1第二个神经元的权重分别为 2、3。而最后得到的是三个神经元的三次数据。 矩阵运算可以简洁地表示多个神经元、多组输入数据的结果 四、3层神经网络的实现我们要实现下图中的三层神经网络： 1) 符号确认我们先导入w_{12}^{(1)} 、 a_{1}^{(1)} 等符号。这些符号仅在本节中使用右上角的(1)表示这是第1层的神经元、第一层的权重w_{12}^{(3)} 表示从第2层（即第3层的前一层）第1个神经元到第(3)层第2个神经元的权重.a_{2}^{(1)}表示第1层第2个神经元 2)各层间信号传递的实现输入层到第一层其中注意偏置神经元“1”，而表示偏置的b右下角的索引号只有一个数字。此时 a_{1}^{(1)} = w_{11}^{(1)}x_1+w_{12}^{(1)}x_2+b_{1}^{(1)}表示成矩阵运算则为： A^{(1)}=XW^{(1)}+B^{(1)}其中：A^{(1)}=\\begin{pmatrix} a_{1}^{(1)} & a_{2}^{(1)} & a_{3}^{(1)}\\end{pmatrix}\\quad,X^=\\begin{pmatrix} x_{1} & x_{2} & x_{3}\\end{pmatrix}\\quad,B^{(1)}=\\begin{pmatrix} b_{1}^{(1)} & b_{2}^{(1)} & b_{3}^{(1)} \\end{pmatrix}\\quad,W^{(1)}=\\begin{pmatrix} w_{11}^{(1)} & w_{21}^{(1)} & w_{31}^{(1)} \\\\ w_{12}^{(1)} & w_{22}^{(1)} & w_{32}^{(1)}\\end{pmatrix}\\quad 下面我们用Numpy数组来实现 import numpy as np def sigmoid(x): return 1 / (1 + np.exp(-x)) X = np.array([1.0, 0.5]) W1 = np.array([[0.1,0.3,0.5],[0.2,0.4,0.6]]) B1 = np.array([0.1, 0.2, 0.3]) A1 = np.dot(X, W1) + B1 print(A1) print(sigmoid(A1)) 输出： [0.3 0.7 1.1] [0.57444252 0.66818777 0.75026011] 上面的代码中用到了先前的激活函数，实际上代码的过程如下图： 第1层到第2层# 继续使用前面的代码 W2 = np.array([[0.1, 0.4],[0.2, 0.5], [0.3, 0.6]]) B2 = np.array([0.1,0.2]) A2 = np.dot(Z1,W2) + B2 Z2 = sigmoid(A2) print(Z2) 输出： [0.3 0.7 1.1] 第2层到输出层 def identity_function(x): return x W3 = np.array([[0.1, 0.3],[0.2, 0.4]]) B3 = np.array([0.1, 0.2]) A3 = np.dot(Z2, W3) + B3 Y = identity_function(A3) 这里用到了船新的激活函数：identity_function，它其实啥也不干，单纯为了和前面格式统一另外，输出层的激活函数用 \\sigma表示，而不是h 3)代码小结import numpy as np def identity_function(x): return x def sigmoid(x): return 1 / (1 + np.exp(-x)) def init_network(): network = {} network[&#39;W1&#39;] = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]]) network[&#39;b1&#39;] = np.array([0.1, 0.2, 0.3]) #W1是第一层权重，b1是第一层偏置，可以看出第一层共有三个神经元，每个神经元接受两个输入信号 network[&#39;W2&#39;] = np.array([[0.1, 0.4],[0.2, 0.5], [0.3, 0.6]]) network[&#39;b2&#39;] = np.array([0.1, 0.2]) network[&#39;W3&#39;] = np.array([[0.1, 0.3], [0.2, 0.4]]) network[&#39;b3&#39;] = np.array([0.1, 0.2]) return network def forward(network, x): W1, W2, W3 = network[&#39;W1&#39;], network[&#39;W2&#39;], network[&#39;W3&#39;] b1, b2, b3 = network[&#39;b1&#39;], network[&#39;b2&#39;], network[&#39;b3&#39;] a1 = np.dot(x,W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1,W2) + b2 z2 = sigmoid(a2) a3 = np.dot(z2,W3) + b3 y = identity_function(a3) return y network = init_network() x = np.array([1.0, 0.5]) y = forward(network, x) print(y) 输出结果为：[0.31682708 0.69627909] 这里出现了“forward”函数，它表示从输入到输出方向的传递处理。之后会介绍后向（backward,从输出到输入方向的处理） 五、输出层的设计神经网络可以用在分类和回归问题上。一般而言，回归问题用恒等函数，分类问题用softmax函数。 补充：机器学习大致分为分类问题和回归问题分类问题举例：给一张图像，区分图像中的人是男性还是女性回归问题举例：给一张图像，估测图像中人的体重 1)恒等函数和softmax函数恒等函数前面已经接触到了，就是上面的identity_function函数。 softmax函数可以如下式这样表示 y_{k}=\\frac{e^{(a_{k})}}{\\sum_{i=1}^ne^{(a_{i})}}e是自然对数的底数。假设有n个神经元，计算第k个神经元的输出y_{k}.注意式子里面的a均为输入信号。softmax函数与之前的激活函数最大的不同在于它的输出受到所有输入信号的影响。 2)softmax函数的实现下面用python对softmax函数进行实现： import numpy as np def softmax(a): exp_a = np.exp(a) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y 不过，当使用指数运算时会面临数据溢出的问题。上面的的函数，尽管最后的返回值y数字不会太大，但运算过程中的中间量sum_exp_a可能会非常非常大，比如输入中某个值为1000……这样很容易不能正确得到结果，所有需要改进可以证明： \\frac{e^{(a_{k})}}{\\sum_{i=1}^ne^{(a_{i})}}=\\frac{e^{(a_{k}+C)}}{\\sum_{i=1}^ne^{(a_{i}+C)}}所以，输入矩阵中所有元素加/减某一常数，不影响最后的结果 改进如下： import numpy as np def softmax(a): c = np.max(a) exp_a = np.exp(a - c) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y 3）softmax函数的特征import numpy as np def softmax(a): exp_a = np.exp(a) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y a = np.array([0.3, 2.9, 4.0]) y = softmax(a) print(y)#输出：[0.01821127 0.24519181 0.73659691] print(np.sum(y))#输出： 1.0 我直观的感觉：softmax是统计概率的函数，只不过这里面的概率利用了指数运算。依照上面函数的输出结果，可以认为y[2]的概率最大（达到了0.73） 六、手写数字识别假设学习工作已经全部完成，我们通过得到的参数实现神经网络的“推理处理”，推理处理也被称为神经网络的“前向传播”(forward propagation)。 1）MINIST数据集关于MINIST数据集的介绍，请移步百度 加载：这里需要用到书中的源码。仅需要理解加载的结果是：60000张训练图，10000张测试图 import sys, os sys.path.append(os.pardir) from dataset.mnist import load_mnist (x_train, t_train),(x_test, t_test) = load_mnist(flatten=True,normalize=False，one_hot_label=False) print(x_train.shape) #(60000, 784) 60000张28×28像素的训练图 print(t_train.shape) #(60000,)训练图的标签 print(x_test.shape) #(10000, 784)10000张测试图 print(t_test.shape) #(10000,)测试图的标签 load_minist的参数： flatten：是否将图像表示为一维数组。若flatten=False,则图像是1×28×28的三维数组，flatten=True,图像是784个元素的一维数组 normalize：是否将图像正规化。若normalize=False，则数据的值为0~225，若normalize=True，则数据的值为0~1.0 one_hot_label: 当one_hot_label=True时，会将正确解的标签设为1，错误解设为0。 图像显示import sys, os sys.path.append(os.pardir) import numpy as np from dataset.mnist import load_mnist from PIL import Image def img_show(img): pil_img = Image.fromarray(np.uint8(img)) pil_img.show() (x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False) img = x_train[0] label = t_train[0] print(label) # 5 print(img.shape) # (784,) img = img.reshape(28, 28) # 把图像恢复为原来的尺寸 print(img.shape) # (28, 28) img_show(img) 这里用到PIL库。它的作用是将矩阵显示为图像可以看到，x_train[0]保存的是图像“5”，t_train[0]保存的是整数5 2) 神经网络的推理处理任务分析：我们要将MINIST数据集中的照片进行分类工作。神经网络的输入层有784个单元（28×28像素的图片），输出层有10个单元（数字共有0到9，10个类别）。 而神经网络的很多参数是通过训练得到的。这里直接使用训练完的参数: import sys, os sys.path.append(os.pardir) import numpy as np import pickle from dataset.mnist import load_mnist from common.functions import sigmoid, softmax def get_data(): (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, flatten=True, one_hot_label=False) return x_test, t_test def init_network(): with open(&quot;sample_weight.pkl&quot;, &#39;rb&#39;) as f: network = pickle.load(f) return network def predict(network, x): W1, W2, W3 = network[&#39;W1&#39;], network[&#39;W2&#39;], network[&#39;W3&#39;] b1, b2, b3 = network[&#39;b1&#39;], network[&#39;b2&#39;], network[&#39;b3&#39;] a1 = np.dot(x, W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, W2) + b2 z2 = sigmoid(a2) a3 = np.dot(z2, W3) + b3 y = softmax(a3) return y x, t = get_data() network = init_network() # 建立神经网络 accuracy_cnt = 0 for i in range(len(x)): y = predict(network, x[i]) #进行预测 p= np.argmax(y) # 获得概率最高的元素的索引，完成预测 if p == t[i]: accuracy_cnt += 1 #统计有多少张图片分类正确 print(&quot;Accuracy:&quot; + str(float(accuracy_cnt) / len(x))) # 0.9352 即该神经网络的精度是93.52% 3)批处理前面的代码进行了10000张784像素图片的分类工作。每张图片是逐个处理的。实际上完全可以把输入数据处理成10000×784的矩阵，这样就可以一次处理得到全部结果。这种打包式的输入数据称为批(batch)批处理可以节约计算机的运算成本批处理的代码： #x, t = get_data() #network = init_network() # 建立神经网络 #accuracy_cnt = 0 #for i in range(len(x)): # y = predict(network, x[i]) #进行预测 # p= np.argmax(y) # 获得概率最高的元素的索引，完成预测 # if p == t[i]: # accuracy_cnt += 1 #统计有多少张图片分类正确 x, t = get_data() network = init_network() # 建立神经网络 accuracy_cnt = 0 batch_size = 100 #设定批的大小 for i in range(0,len(x),batcg_size): x_batch = x[i : i + batch_size] y_batch = predict(network, x_batch) p = np.argmax(y_batch, axis=1) accuracy_cnt += np.sum(p == t[i:i+batch_size]) 书中源码把批的大小设定为100。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"},{"name":"鱼书笔记","slug":"深度学习/鱼书笔记","permalink":"/categories/深度学习/鱼书笔记/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"鱼书笔记","slug":"鱼书笔记","permalink":"/tags/鱼书笔记/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"},{"name":"鱼书笔记","slug":"深度学习/鱼书笔记","permalink":"/categories/深度学习/鱼书笔记/"}]},{"title":"leetcode91 解码方法","slug":"leetcode91","date":"2020-10-02T11:18:44.514Z","updated":"2020-10-02T11:55:04.801Z","comments":true,"path":"2020/10/02/leetcode91/","link":"","permalink":"/2020/10/02/leetcode91/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述： A message containing letters from A-Z is being encoded to numbers using the following mapping: ‘A’ -&gt; 1 ‘B’ -&gt; 2 … ‘Z’ -&gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. The answer is guaranteed to fit in a 32-bit integer. 示例1： Input: s = “12” Output: 2 Explanation: It could be decoded as “AB” (1 2) or “L” (12). 示例2： Input: s = “226” Output: 3 Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6). 示例3： Input: s = “0” Output: 0 Explanation: There is no character that is mapped to a number starting with ‘0’. We cannot ignore a zero when we face it while decoding. So, each ‘0’ should be part of “10” —&gt; ‘J’ or “20” —&gt; ‘T’. 示例4： Input: s = “1” Output: 1 注： &lt;= s.length &lt;= 100 s contains only digits and may contain leading zero(s). 入门级的dp+分治。但这方面的题我做的确实不太多… dp:对于仅包含’1’ ‘2’ 的字符串:“1” : 1种编码方式“12”：2种编码方式“111”：3种编码方式其实就是dp的入门题“爬楼梯”.假设长度为n的12串为steps[n] 则steps[n] = steps[n - 1] + steps[n - 2]; 为方便描述，现规定:对于编码“5”,5被称为“单”，对于编码“12”，1称作“头”，2称作“尾”。显然，1、2可作单、可做头、可作尾，因而1、2字符串可以直接dp 分治:当字符串中出现0、3、4…7、8这些字符时，可以发现，0只能作尾,其他字符只能作尾或作单。也就是说，当字符串是“121312”，3是不可能和后面的1混合编码的，那么可以将”1213”和”12”分开考虑，实际上”121312”的答案是”1213”与”12”的乘积。类推：”171921012319101”可以看成”17” “19” “210” “123” “19” “101”几个子串。而对于子串而言，末尾数字也需要分三种情况：”0”自成一类，”3~6”是一类，”7~9”是一类。 100%kill代码： class Solution { public: int steps[102]; int numDecodings(string s) { if(s[0] == &#39;0&#39;) return 0; steps[0] = 1; steps[1] = 1; steps[2] = 2; for(int i = 3; i &lt; 46; ++i)//为什么是46呢，因为47就超过int型上限了。。。按理，题目给的长度其实最大是100,这个只能自己试了 { steps[i] = steps[i - 1] + steps[i - 2]; }//建立dp数组 vector&lt;char&gt; tmp; int ans = 1; for(int i = 0; i &lt; s.size(); ++i) { tmp.push_back(s[i]); if((s[i] &lt; &#39;1&#39;)||(s[i] &gt; &#39;2&#39;)) { ans *= count(tmp); tmp.clear(); } } return ans*steps[tmp.size()]; } int count(vector&lt;char&gt;&amp; str)//这是处理子串的函数 { int sum = 0; if(str.back() == &#39;0&#39;)//对于0 { if(str.size() == 1) return 0; else return steps[str.size() - 2]; } if(str.back() &gt; &#39;6&#39;)//d对于7、8、9 { if(str.size() == 1) return 1; if(str[str.size()-2] == &#39;1&#39;) return steps[str.size()]; return steps[str.size()-1];//只能单着了 } //剩下3、4、5、6 return steps[str.size()]; } };","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}],"tags":[{"name":"dp","slug":"dp","permalink":"/tags/dp/"},{"name":"分治","slug":"分治","permalink":"/tags/分治/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}]},{"title":"鱼书笔记 第二章 感知机","slug":"鱼书笔记 第二章 感知机","date":"2020-09-27T12:00:00.000Z","updated":"2020-10-04T13:25:55.218Z","comments":true,"path":"2020/09/27/鱼书笔记 第二章 感知机/","link":"","permalink":"/2020/09/27/鱼书笔记 第二章 感知机/","excerpt":"","text":"1、 感知机是什么?感知机接收多个输入信号，输出一个信号。直观讲来，感知机类似数学上的“函数”,但是感知机的所有变量取值只有0和1。 可以假设函数z = ux+ vy，这里的x、y为自变量，u、v为权重（权重的取值是全体实数），并且设定阈值A，当ux+ vy &gt; A时z的值为1，否则为0. 2、 用感知机表示简单逻辑电路1） 与门把与门考虑成感知机：以z = ux+ vy（阈值为A）为例，可以认为它是一个(u, v, A) = (1, 1, 1.5)的感知机（当然还有很多其他取值方式） 2） 与非门和或门把与非门考虑成感知机：以z = ux+ vy（阈值为A）为例，可以认为它是一个(u, v, A) = (-1, -1, -1.5)的感知机(其实只要把与门的参数取值全部取反就可以)同样的，或门可以把参数设置为(u, v, A) = (1, 1, 0.8) 3、 感知机的实现1）简单的与门def AND(x, y): u, v, A = 1, 1, 1.5 tmp = u * x + v * y if tmp &gt; A: return 1 return 0 def main(): print(AND(0, 0)) # 输出0 print(AND(1, 0)) # 输出0 print(AND(1, 1)) # 输出1 print(AND(0, 1)) # 输出0 main() 2) 导入权重和偏置考虑最开始的感知机u x+ v y &gt; A, 这个式子也可以表示为u x+ v y - A &gt; 0. 所以也可以使用如下方式实现感知机：z = u x+ v y + b, 当u x+ v y + b &gt; 0时z取1， 否则取0这里的b称为偏置 下面使用NumPy实现感知机 import numpy as np def AND(x1, x2): x = np.array([x1, x2]) w = np.array([1, 1])# 权重 b = -1.5 # 偏置 if np.sum(x * w) + b &gt; 0: return 1 return 0 4、感知机的局限性及解决1）问题：简单感知机能实现异或门吗？答案时不能。感知机的表达式是线性的。而异或门的函数无法用线性表示。但是感知机可以叠加使用，“多层感知机”就可以实现异或门 3） 异或门的多层感知机实现由逻辑电路知识，异或门可以由与门、或门、与非门搭配实现。 import numpy as np def AND(x1, x2): # 与门 x = np.array([x1, x2]) w = np.array([1, 1])# 权重 b = -1.5 # 偏置 if np.sum(x * w) + b &gt; 0: return 1 return 0 def NAND(x1, x2): # 与非门 x = np.array([x1, x2]) w = np.array([-1, -1])# 权重 b = 1.5 # 偏置 if np.sum(x * w) + b &gt; 0: return 1 return 0 def OR(x1, x2): # 或门 x = np.array([x1, x2]) w = np.array([1, 1])# 权重 b = -0.5 # 偏置 if np.sum(x * w) + b &gt; 0: return 1 return 0 def XOR(x1, x2): # 异或门 s1 = NAND(x1, x2) s2 = OR(x1, x2) y = AND(s1, s2) return y def main(): print(XOR(0, 0)) #输出0 print(XOR(0, 1)) #输出1 print(XOR(1, 0)) #输出1 print(XOR(1, 1)) #输出0 main()","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"深度学习","slug":"编程/深度学习","permalink":"/categories/编程/深度学习/"},{"name":"鱼书笔记","slug":"编程/深度学习/鱼书笔记","permalink":"/categories/编程/深度学习/鱼书笔记/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"鱼书笔记","slug":"鱼书笔记","permalink":"/tags/鱼书笔记/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"深度学习","slug":"编程/深度学习","permalink":"/categories/编程/深度学习/"},{"name":"鱼书笔记","slug":"编程/深度学习/鱼书笔记","permalink":"/categories/编程/深度学习/鱼书笔记/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2020-09-24T10:27:36.434Z","updated":"2020-10-02T08:33:37.416Z","comments":true,"path":"2020/09/24/KMP算法/","link":"","permalink":"/2020/09/24/KMP算法/","excerpt":"","text":"KMP算法不算是多难的算法，它的困难之处在于没有人愿意将它讲清楚 先贴一个感觉比较清楚的教程：KMP算法最浅显理解——一看就明白。这里面的代码相对通俗易懂。 下面是自己实现时的感受：算法的原理还是比较好懂的，但在看别人代码时最最难受的事情就是next数组的确定…不同的人有不同的规则。比如next[i] 的值为 n，有可能是指前i+1个字符有长度为n的重复串，也有可能值前i+1个字符有长度为n+1的字符串，也有可能指前i个字符有长度为n的字符串，某些人还会特别的把next[0]设定为-1…关键的关键，是设定这种规则的人，还往往不把规则说清楚！！！（读这一大串字就够痛苦了，更别说我在阅读他人代码实现时是有多痛苦了☹） 下面的代码依照一般教科书上的官方版本，next[i] = n,表示前i+1个（注意下标从0到i共i+1）字符有长度为n+1的重复串，没有其他特殊约定。 #include&lt;string&gt; #include&lt;iostream&gt; using namespace std; int getNext(string target,int* next) { next[0] = -1; int k = -1; //重复子串长度为k for (int i = 1; i &lt; target.size(); ++i)//考虑：终点是target.size()-1还是target.size()-2 { while (~k &amp;&amp; (target[k + 1] != target[i]))//一定要注意条件~k，否则当没有重复子串时就会无限循环 k = next[k]; //k = next[k]是代码的核心 //循环跳出后，有两种可能：k=-1或target[k+1]==target[i] 这两种情况下，若target[k + 1] == target[i]，字串长度均要+1 if (target[k + 1] == target[i]) ++k; next[i] = k; } return 0; } /*上面这个函数函数处理的效果： 以target = &quot;abbcabbba&quot;为例，它的最终得到的next数组为：{-1,-1,-1,-1,0,1,2,-1,0} */ int KMP(string source, string target) { int* next = new int[target.size()]; getNext(target, next); int i = 0, j = -1;//j为target（模式串）的指针。 while (i &lt; source.size()) { if (source[i] == target[j+1])//若两指针所指元素相等，显然要右移。 { ++i; ++j; } else if (j == -1)//说明没有重合子串，只能让目标串的指针加1 ++i; else j = next[j];//source[i] != target[j]找到j的下一个位置 if (j == target.size()-1)//匹配完毕 break; } if (i &gt;= target.length()) { delete[]next; return i - target.length(); } else { delete[]next; return -1; } } int main() { int next[20]; getNext(&quot;ABACDABABC&quot;, next); for (int i = 0; i &lt; 10; ++i) cout &lt;&lt; &quot; &quot; &lt;&lt; next[i]; cout &lt;&lt; &quot;起始位置：&quot; &lt;&lt; KMP(&quot;abababc&quot;, &quot;bc&quot;); }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"算法","slug":"编程/算法","permalink":"/categories/编程/算法/"},{"name":"c++","slug":"编程/算法/c","permalink":"/categories/编程/算法/c/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"算法","slug":"编程/算法","permalink":"/categories/编程/算法/"},{"name":"c++","slug":"编程/算法/c","permalink":"/categories/编程/算法/c/"}]},{"title":"leetcode 90 Subsets II 求所有子集","slug":"leetcode90","date":"2020-09-23T01:44:00.000Z","updated":"2020-09-23T01:44:12.108Z","comments":true,"path":"2020/09/23/leetcode90/","link":"","permalink":"/2020/09/23/leetcode90/","excerpt":"","text":"原题传送门-&gt;&gt;&gt; 题目描述： Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets. 示例： Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 简单的回溯题，但是自己解决时遇到很多问题，记录一下。 AC代码 class Solution { public: vector&lt;vector&lt;int&gt;&gt;ans; vector&lt;int&gt; tmp; int* mark; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); mark = new int[nums.size()]; memset(mark, 0, 4 * nums.size()); for (int i = 0; i &lt; nums.size(); ++i) select(nums, i); delete[]mark; ans.push_back(vector&lt;int&gt;()); return ans; } void select(vector&lt;int&gt;&amp; nums, int pos)//将要取pos元素 { if (pos == nums.size()) return; if (pos &amp;&amp; (nums[pos] == nums[pos - 1]) &amp;&amp; (!mark[pos - 1])) return; else { tmp.push_back(nums[pos]); ans.push_back(tmp); mark[pos] = 1; for (int i = pos + 1; i &lt; nums.size(); ++i) select(nums, i); tmp.pop_back(); mark[pos] = 0; } } }; 去重的规则比较清楚：先进行排序。取规则：当多个相同数字连续出现，这几个相同数字必须从左到右取，不能有间隔。比如：array = [1，2，3，3，3] 假如不取array[2]，那么array[3],array[4]也不可以取。问题在于搜索上。 WA代码版本1 // for (int i = pos + 1; i &lt; nums.size(); ++i) // select(nums, i); select(nums, pos + 1); 这个版本是深搜时仅仅探测下一格。它不允许连续取元素。比如array = [1，2，3，3，3]，[1,3]不会出现在答案中 WA代码版本2 //if (pos &amp;&amp; (nums[pos] == nums[pos - 1]) &amp;&amp; (!mark[pos - 1])) // return; if (pos &amp;&amp; (nums[pos] == nums[pos - 1]) &amp;&amp; (!mark[pos - 1])) { for (int i = pos + 1; i &lt; nums.size(); ++i) select(nums, i); return; } 这种情况，当发现重复元素不符合取规则时,会对后面的所有元素进行探测。问题在于，当return之后，该点之后的所有元素会再被探测一遍，结果答案会有大量重复。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"},{"name":"c++","slug":"编程/leetcode/c","permalink":"/categories/编程/leetcode/c/"}],"tags":[{"name":"编程","slug":"编程","permalink":"/tags/编程/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"c++","slug":"c","permalink":"/tags/c/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"},{"name":"c++","slug":"编程/leetcode/c","permalink":"/categories/编程/leetcode/c/"}]},{"title":"鱼书笔记 第一章 NumPy和Matplotlib的使用","slug":"鱼书笔记 第一章 NumPy库和Matplotlib库的使用","date":"2020-09-22T01:58:44.466Z","updated":"2020-10-04T13:25:45.665Z","comments":true,"path":"2020/09/22/鱼书笔记 第一章 NumPy库和Matplotlib库的使用/","link":"","permalink":"/2020/09/22/鱼书笔记 第一章 NumPy库和Matplotlib库的使用/","excerpt":"","text":"一、NumPy库Numpy是一个封装了数组和矩阵运算的库 1、 导入import numpy as np 导入numpy，并给它起了一个小名“np” 2、 生成numpy数组x = np.array([1.0, 2.0, 3.0])#使用列表进行初始化&amp;赋值 y = np.array([2.0, 4.0, 6.0]) print(x + y) print(x * y) print(x / y) 输出为: [3. 6. 9.] [ 2. 8. 18.] [0.5 0.5 0.5] 注意这里的四则运算是“对应元素的”，相当于矩阵的点乘。假如两个数组的长度不相同，程序会报错。 数组也可以与数字进行线性运算 x = np.array([1.0, 2.0, 3.0]) print(2 * x) print(x / 2) print(2 / x) 输出为 [2. 4. 6.] [0.5 1. 1.5] [2. 1. 0.66666667] 3、NumPy的N维数组直接使用n维列表作参数 x = np.array([[1.0, 2.0, 3.0],[3.4, 2.0, 9.0]]) print(x) print(x.shape) # 返回x的形状 print(x.dtype) # 返回x的元素类型 输出结果为： [[1. 2. 3. ] [3.4 2. 9. ]] (2, 3) float64 N维数组的四则运算与向量运算规则相同 4、广播前面的例子中 x = np.array([1.0, 2.0, 3.0]) print(2 * x) 这句代码为什么能运行呢? 数字本质是1×1的矩阵，数字和向量为什么能相乘呢？这里用到广播，它会自动将小数组扩充为大数组比如 x = np.array([[1.0, 2.0, 3.0],[3.4, 2.0, 9.0]]) y = np.array([[1], [2]]) z = np.array([1,2,1]) print(x + y) print(x + z) y被扩充为[[1, 1, 1], [2, 2, 2]]z被扩充为[[1, 2, 1], [1, 2, 1]]输出结果： [[ 2. 3. 4. ] [ 5.4 4. 11. ]] [[ 2. 4. 4. ] [ 4.4 4. 10. ]] 5、元素访问1）使用[]print(x[0][0]) print(x[-1][-1]) print(x[0]) 输出为： 1.0 9.0 [1. 2. 3.] 2）简单遍历：x = np.array([[1.0, 2.0, 3.0],[3.4, 2.0, 9.0]]) for i in x: print(i) 输出结果： [1. 2. 3.] [3.4 2. 9. ] 3）将高维数组转化为一维数组x = np.array([[1.0, 2.0, 3.0],[3.4, 2.0, 9.0]]) y = x.flatten() print(y) 输出结果为： [1. 2. 3. 3.4 2. 9. ] 这与初始化的数据顺序是一致的。（与matlab有差异） 4）bool索引的使用x = np.array([[1.0, 2.0, 3.0],[3.4, 2.0, 9.0]]) print( x &gt; 2.5) print(x[x &gt; 2.5]) 输出为 [[False False True] [ True False True]] [3. 3.4 9. ] print(x[x &gt; 0]) 输出为： [1. 2. 3. 3.4 2. 9. ] bool索引返回的是一维数组 二、Matplotlib库Matplotlib是一个图形绘制库，可以将数据可视化 1、 绘制简单图形1）生成数据x = np.arange(0,6,0.1)#以0.1为步长，生成0到6的数据 y = np.sin(x) print(x) print(y) 输出结果为： [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2. 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3. 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4. 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5. 5.1 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9] [ 0. 0.09983342 0.19866933 0.29552021 0.38941834 0.47942554 0.56464247 0.64421769 0.71735609 0.78332691 0.84147098 0.89120736 0.93203909 0.96355819 0.98544973 0.99749499 0.9995736 0.99166481 0.97384763 0.94630009 0.90929743 0.86320937 0.8084964 0.74570521 0.67546318 0.59847214 0.51550137 0.42737988 0.33498815 0.23924933 0.14112001 0.04158066 -0.05837414 -0.15774569 -0.2555411 -0.35078323 -0.44252044 -0.52983614 -0.61185789 -0.68776616 -0.7568025 -0.81827711 -0.87157577 -0.91616594 -0.95160207 -0.97753012 -0.993691 -0.99992326 -0.99616461 -0.98245261 -0.95892427 -0.92581468 -0.88345466 -0.83226744 -0.77276449 -0.70554033 -0.63126664 -0.55068554 -0.46460218 -0.37387666] 2）绘制图形plt.plot(x, y) plt.show() 得到如下图形: 2、 其他功能的简单示例import numpy as np import matplotlib.pyplot as plt plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;] #加上这句可以正常显示中文 x = np.arange(0,6,0.1)#以0.1为步长，生成0到6的数据 y1 = np.sin(x) y2 = np.cos(x) plt.plot(x, y1, label=&quot;sin&quot;) plt.plot(x, y2, linestyle = &quot;--&quot;, label=&quot;cos&quot;) #用虚线绘制 plt.xlabel(&quot;x&quot;) #x轴标签 plt.ylabel(&quot;y&quot;) #y轴标签 plt.title(&quot;sin和cos函数&quot;) plt.legend() #显示图例 plt.show() 效果： 3、 显示图像import numpy as np import matplotlib.pyplot as plt from matplotlib.image import imread img = imread(&#39;timg.jfif&#39;) plt.imshow(img) plt.show() 显示效果：","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"},{"name":"鱼书笔记","slug":"深度学习/鱼书笔记","permalink":"/categories/深度学习/鱼书笔记/"}],"tags":[{"name":"编程","slug":"编程","permalink":"/tags/编程/"},{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"鱼书笔记","slug":"鱼书笔记","permalink":"/tags/鱼书笔记/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"},{"name":"鱼书笔记","slug":"深度学习/鱼书笔记","permalink":"/categories/深度学习/鱼书笔记/"}]},{"title":"leetcode 89.Gray Code（格雷码）","slug":"leetcode 89.Gray Code","date":"2020-09-18T08:20:00.000Z","updated":"2020-09-18T08:35:55.338Z","comments":true,"path":"2020/09/18/leetcode 89.Gray Code/","link":"","permalink":"/2020/09/18/leetcode 89.Gray Code/","excerpt":"","text":"原题传送门—&gt;&gt;题目描述： 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。格雷编码序列必须以 0 开头。 示例1： 输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1 示例2: 输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 一道背答案的题,记录一下.我先参考了下面这篇文章:原文链接:格雷码Gray Code详解 第一步，改变最右边的位元值； 第二步，改变右起第一个为1的位元的左边位元； 第三步，第四步重复第一步和第二步，直到所有的格雷码产生完毕（换句话说，已经走了(2^n) - 1 步）。 class Solution { public: vector&lt;int&gt; grayCode(int n) { vector&lt;int&gt; ans; if(!n) { ans.push_back(0); return ans; } int count = (1 &lt;&lt; (n-1));//共需要生成2*count个数字,循环count次 int num = 0; for(int i = 0; i &lt; count; ++i) { ans.push_back(num); num ^= 1; ans.push_back(num); change(num); } return ans; } void change(int &amp;n)//改变n右起第一个为‘1’的位的左位 { int i = 1; int flag = 0; while(!flag)//flag为1时退出循环 { flag = n &amp; i; i = i &lt;&lt; 1; } n = n ^ i; } }; 该方案仅仅击败了40% ,看到题解中有套更好的算法:原文链接:Gray Code （镜像反射法，图解） 所以用这种思想我又重写了代码: class Solution { public: vector&lt;int&gt; grayCode(int n) { vector&lt;int&gt; ans; ans.push_back(0); for(int i = 0; i &lt; n; ++i) { int start = ans.size() - 1; for(int j = start; j &gt;= 0; --j) { ans.push_back(ans[j] + (1 &lt;&lt; i)); } } return ans; } }; 果然100%kill","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"c++","slug":"c","permalink":"/tags/c/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}]},{"title":"leetcode 79. Word Search","slug":"leetcode 79. Word Search","date":"2020-09-17T15:00:00.000Z","updated":"2020-09-17T14:49:18.945Z","comments":true,"path":"2020/09/17/leetcode 79. Word Search/","link":"","permalink":"/2020/09/17/leetcode 79. Word Search/","excerpt":"","text":"原题传送门—&gt;题目描述：Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 示例 board = [ [‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’] ] Given word = “ABCCED”, return true. Given word = “SEE”, return true. Given word = “ABCB”, return false. 标准的深搜题，直接上代码 class Solution { public: int **mark; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { if(board.empty()) return false; mark = new int*[board.size()]; for(int i = 0; i &lt; board.size(); ++i) { mark[i] = new int[board[0].size()]; memset(mark[i], 0, board[0].size()*4); } bool ans = false; for(int i = 0; i &lt; board.size(); ++i) { for(int j = 0; j &lt; board[0].size(); ++j) { if(find(board, word, i, j, 0)) { for(int k = 0; k &lt; board.size(); ++k) { delete []mark[k]; } delete []mark; return true; } } } for(int k = 0; k &lt; board.size(); ++k) { delete []mark[k]; } delete []mark; return false; } bool find(vector&lt;vector&lt;char&gt;&gt; &amp; board, string &amp; word,int row, int column, int pos) { if((row &lt; 0)||(column &lt; 0)||(row == board.size())||(column == board[0].size())) return false; if((mark[row][column])||(board[row][column] != word[pos])) return false; if(pos == word.size() - 1) return true; bool ans = false; mark[row][column] = 1; if(find(board, word, row - 1, column, pos + 1)|| find(board, word, row, column - 1, pos + 1)|| find(board, word, row + 1, column, pos + 1)|| find(board, word, row, column + 1, pos + 1)) return true; mark[row][column] = 0; return ans; } }; 不过这道题有一点需要注意：第47行之后这一段：AC版本: bool ans = false; mark[row][column] = 1; if(find(board, word, row - 1, column, pos + 1)|| find(board, word, row, column - 1, pos + 1)|| find(board, word, row + 1, column, pos + 1)|| find(board, word, row, column + 1, pos + 1)) return true; mark[row][column] = 0; return ans; 原本我是这样写的，会超时：TLE版本： bool ans = false; mark[row][column] = 1; ans |= find(board, word, row - 1, column, pos + 1); ans |= find(board, word, row, column - 1, pos + 1); ans |= find(board, word, row + 1, column, pos + 1); ans |= find(board, word, row, column + 1, pos + 1); return true; mark[row][column] = 0; return ans; 这两段代码我之前以为是一样的，但其实效率差很多，看TLE版本的代码：假如ans在第一步之后就变成true，那么之后的递归已经没有意义了，直接return就可以了。而使用if判断时，对于||条件，当前一个条件值为1，便不会再执行之后的语句了，相当于直接return,所以效率要高很多。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"c++","slug":"c","permalink":"/tags/c/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"leetcode","slug":"编程/leetcode","permalink":"/categories/编程/leetcode/"}]},{"title":"爬虫实战 皇室战争部落管理 第一步：数据获取","slug":"py爬虫 皇室战争玩家信息获取","date":"2020-09-17T14:00:00.000Z","updated":"2020-09-17T14:31:38.072Z","comments":true,"path":"2020/09/17/py爬虫 皇室战争玩家信息获取/","link":"","permalink":"/2020/09/17/py爬虫 皇室战争玩家信息获取/","excerpt":"","text":"任务：从royaleapi.com上爬取皇室战争的部落信息，并保存在词典中任务分为两个模块： 1、获取html文件 2、解析html数据 需要用到的其他知识储备： 对html与css的有简单的了解 了解re、urllib、bs4库的主要函数 了解正则表达式 一、获取html文件直接上代码 import urllib.error, urllib.request def askURL(url): head1 = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&quot;} reque = urllib.request.Request(url,headers = head1); html = &quot;&quot; try: response = urllib.request.urlopen(reque) html = response.read().decode(&quot;utf-8&quot;) except urllib.error.URLError as e: if hasattr(e,&quot;code&quot;): print(e.code) if hasattr(e,&quot;reason&quot;): print(e.reason) return html 逐行解释： 1、本函数需要用到urllib库 2、head1时一个字典，中保存了用户信息User-Agent。（在访问一个网站时，浏览器会向网站发送自己的身份信息。这段信息便是作为身份信息，提取自我自己的火狐浏览器。假如不设置，浏览器会向网站发送的身份是“urllib”，等于告诉网站“我是爬虫🐶”） 3、try语句块中： response保存了打开的网页文件 html保存了以utf8编码的字符串 4、该函数返回值为网页信息的字符串 此时返回的字符串内容如下： &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;title&gt;任性小部落 #YJ0PPR8J | Clan - RoyaleAPI&lt;/title&gt; &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; href=&quot;https://royaleapi.com/static/img/favicon/apple-touch-icon.png?t=0647bd87d25109655af8f3e1e88c40a0ce2192c9&quot;&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=&quot;https://royaleapi.com/static/img/favicon/favicon-32x32.png?t=c98ef822a9cedab0fe9ee93478d40d899667c661&quot;&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=&quot;https://royaleapi.com/static/img/favicon/favicon-16x16.png?t=21c28d2951994ad25eb03db2315d82e2132d2678&quot;&gt; &lt;link rel=&quot;manifest&quot; href=&quot;/static/img/favicon/manifest.json?t=34423a0929bf95545ca783822157e9a2b5dd8ba2&quot;&gt; &lt;link rel=&quot;mask-icon&quot; href=&quot;https://royaleapi.com/static/img/favicon/safari-pinned-tab.svg?t=f09d05bf709e0166cade8ea86d08e805d87c1960&quot; color=&quot;#5bbad5&quot;&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://royaleapi.com/favicon.ico&quot;&gt; &lt;meta name=&quot;msapplication-config&quot; content=&quot;https://royaleapi.com/static/img/favicon/browserconfig.xml?t=31082b60c007fac280802a7cea7386a75d20e5d4&quot;&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.royaleapi.com&quot; crossorigin&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.googleapis.com&quot;&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://www.google-analytics.com&quot;&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://cdnjs.cloudflare.com&quot;&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.jsdelivr.net&quot;&gt; &lt;meta name=&quot;google&quot; content=&quot;notranslate&quot; /&gt; &lt;meta name=&quot;title&quot; content=&quot;任性小部落 #YJ0PPR8J | Clan - RoyaleAPI&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;The definitive source about decks, players and teams in Clash Royale. Explore advanced statistics about decks and cards based on millions of games per week.&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;Clash Royale, stats, analytics, decks, esports, API, strategy, guides, chests, Clash, Royale, RoyaleAPI, data, statistics, meta, best, cards, pro&quot;&gt; &lt;meta property=&quot;og:title&quot; content=&quot;任性小部落 #YJ0PPR8J | Clan - RoyaleAPI&quot;&gt; &lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt; &lt;meta property=&quot;og:site_name&quot; content=&quot;RoyaleAPI&quot;&gt; &lt;meta property=&quot;og:url&quot; content=&quot;https://royaleapi.com/clan/YJ0PPR8J&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.royaleapi.com/static/semantic/dist/semantic.min.css?t=32a6bbf4a921163b72ef7bc18a2eff658b0fcb16&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.royaleapi.com/static/scss/app.css?t=794ec8229089e2a68160fc83ea1d4f4554394872&quot; /&gt; &lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot; /&gt; &lt;meta name=&quot;twitter:site&quot; content=&quot;@RoyaleAPI&quot;&gt; &lt;meta name=&quot;twitter:creator&quot; content=&quot;@RoyaleAPI&quot;&gt; &lt;meta name=&quot;twitter:title&quot; content=&quot;任性小部落 #YJ0PPR8J | Clan - RoyaleAPI&quot;&gt; &lt;meta name=&quot;twitter:description&quot; content=&quot;The definitive source about decks, players and teams in Clash Royale. Explore advanced statistics about decks and cards based on millions of games per week.&quot;&gt; &lt;meta property=&quot;og:image:width&quot; content=&quot;127&quot;&gt; &lt;meta property=&quot;og:image:height&quot; content=&quot;151&quot;&gt; &lt;meta property=&quot;og:image&quot; content=&quot;https://cdn.royaleapi.com/static/img/badge/Cherry_Blossom_08.png?t=ede825cbfc9d9dec589c7284b72be82548937828&quot;&gt; &lt;meta property=&quot;og:description&quot; content=&quot;一起来玩耍呀 部落Q群683185709 捐卡500授长老 积极参加部落战 月亮不睡我不睡我是秃头小宝贝(⊙o⊙)！&quot;&gt; （以上显示的是一小部分） 二、将得到的数据进行处理from bs4 import BeautifulSoup import re findPlayerTag = re.compile(r&#39;data-tag=(.*)&quot;&#39;) findPlayerName = re.compile(r&#39;data-name=(.*)&quot;&#39;) findDonate = re.compile(r&#39;&lt;td class=&quot;donations right aligned mobile-hide&quot; data-sort-value=(.*)&gt;&#39;) def getdata(url): dic = {} html = askURL(url) soup = BeautifulSoup(html,&quot;html.parser&quot;) wholedata = soup.select(&#39;tbody &gt; tr&#39;) for item in wholedata: s = str(item) tag = re.findall(findPlayerTag,s)[0] name = re.findall(findPlayerName,s)[0] donate = re.findall(findDonate,s) info = [] info += [cutName(str(name))] info += [str(donate)] dic[str(tag)[1:]] = info print(dic) def cutName(str): end = str.find(&#39;&quot;&#39;,2) return str[1:end] 我需要提取到的信息：玩家标签(以变量名tag进行保存)、玩家游戏昵称（以变量名name进行保存）、玩家的捐赠量（以变量名donate进行保存）。逐行解释：1、需要使用bs4和re库2、soup = BeautifulSoup(html,”html.parser”) ，BeautifulSoup执行解析工作，可以将网页处理成树形结构，而html.parser是专门用于html文件的解析器 3、wholedata = soup.select(‘tbody &gt; tr’)， select执行搜索工作。这里使用的是css选择器模式，为什么是”tbody &gt; tr“呢？这里需要查看html文件的结构 &lt;tbody&gt; &lt;tr data-tag=&quot;28PVL00L2&quot; data-role=&quot;Member&quot; class=&quot;role-Member tr_member&quot;&gt; &lt;td data-sort-value=&quot;1&quot;&gt;1&lt;/td&gt; &lt;td data-sort-value=神奇哟&gt; &lt;a class=&quot;block member_link&quot; data-tag=&quot;28PVL00L2&quot; href=&quot;/player/28PVL00L2&quot;&gt; 神奇哟 &lt;div class=&quot;last_seen i18n_duration_short&quot; data-seconds=&quot;&quot; data-datetime=&quot;20200917T043248.000Z&quot;&gt; 3h 17m ago &lt;/div&gt; &lt;/a&gt; &lt;div class=&quot;mobile-show&quot;&gt; &lt;div class=&quot;meta&quot;&gt; Member &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mobile-show mobile-member-summary&quot;&gt; &lt;div&gt; &lt;i class=&quot;big icons&quot;&gt; &lt;img class=&quot;ui verytiny image&quot; src=&quot;https://cdn.royaleapi.com/static/img/icon/ic-cards.png?t=73da5b1cae92477331cfa0c20a422c6cd6fa45f6&quot; /&gt; &lt;i class=&quot;corner blue arrow up icon&quot;&gt;&lt;/i&gt; &lt;/i&gt; 58 &lt;/div&gt; &lt;div&gt; &lt;i class=&quot;big icons&quot;&gt; &lt;img class=&quot;ui verytiny image&quot; src=&quot;https://cdn.royaleapi.com/static/img/icon/ic-cards.png?t=73da5b1cae92477331cfa0c20a422c6cd6fa45f6&quot; /&gt; &lt;i class=&quot;corner orange arrow down icon&quot;&gt;&lt;/i&gt; &lt;/i&gt; 160 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;join_status&quot; id=&quot;join-28PVL00L2&quot;&gt;&lt;/div&gt; &lt;/td&gt; &lt;td class=&quot;inactivity_content inactivity in_trophies&quot;&gt; &lt;img class=&quot;inactive_bar&quot; style=&quot;display:none;&quot; src=&quot;https://cdn.royaleapi.com/static/img/ui/inactivity-trophies.png?t=2a9ca5964e11b039314532607f6924022cabfc58&quot; /&gt; &lt;/td&gt; &lt;td class=&quot;inactivity_content inactivity in_donations&quot;&gt; &lt;img class=&quot;inactive_bar&quot; style=&quot;display:none;&quot; src=&quot;https://cdn.royaleapi.com/static/img/ui/inactivity-donations.png?t=873649431655834474ce80d06a2d7cdcc251ac53&quot; /&gt; &lt;/td&gt; &lt;td class=&quot;mobile-hide tablet-hide&quot;&gt; &lt;a href=&quot;/player/28PVL00L2/battles&quot;&gt; &lt;img class=&quot;ui verytiny image&quot; src=&quot;https://cdn.royaleapi.com/static/img/ui/battle.png?t=b176e1aa36db187823a4a93069cba312e838df9b&quot; alt=&quot;Battles&quot;&gt; &lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;mobile-hide&quot; data-sort-value=&quot;3&quot;&gt;Member&lt;/td&gt; &lt;td class=&quot;mobile-hide tablet-hide&quot; data-sort-value=&quot;6325462410230&quot;&gt; 28PVL00L2 &lt;/td&gt; &lt;td class=&quot;&quot; data-sort-value=&quot;5167&quot;&gt; 5,167 &lt;img class=&quot;ui mini image arena_icon&quot; src=&quot;https://cdn.royaleapi.com/static/img/arenas-fs8/arena16-fs8.png?t=3b029e481bd4b71e7e2f5256452db7a032477a68&quot; alt=&quot;Arena_L4 / Master I&quot; /&gt; &lt;/td&gt; &lt;td class=&quot;right aligned mobile-hide&quot; data-sort-value=&quot;12&quot;&gt;12&lt;/td&gt; &lt;td class=&quot;donations right aligned mobile-hide&quot; data-sort-value=&quot;58&quot;&gt; 58 &lt;i class=&quot;big icons&quot;&gt; &lt;img class=&quot;ui verytiny image&quot; src=&quot;https://cdn.royaleapi.com/static/img/icon/ic-cards.png?t=73da5b1cae92477331cfa0c20a422c6cd6fa45f6&quot; /&gt; &lt;i class=&quot;corner blue arrow up icon&quot;&gt;&lt;/i&gt; &lt;/i&gt; &lt;/td&gt; &lt;td class=&quot;donations right aligned mobile-hide&quot; data-sort-value=&quot;160&quot;&gt; 160 &lt;i class=&quot;big icons&quot;&gt; &lt;img class=&quot;ui verytiny image&quot; src=&quot;https://cdn.royaleapi.com/static/img/icon/ic-cards.png?t=73da5b1cae92477331cfa0c20a422c6cd6fa45f6&quot; /&gt; &lt;i class=&quot;corner orange arrow down icon&quot;&gt;&lt;/i&gt; &lt;/i&gt; &lt;/td&gt; &lt;td class=&quot;mobile-hide&quot;&gt; &lt;div class=&quot;&quot;&gt; &lt;input id=&quot;compare-checkbox-28PVL00L2&quot; class=&quot;compareme&quot; type=&quot;checkbox&quot; data-tag=&quot;28PVL00L2&quot; data-name=&quot;神奇哟&quot; /&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr data-tag=&quot;29LV0UYYR&quot; data-role=&quot;Co-Leader&quot; class=&quot;role-Co-Leader tr_member&quot;&gt; &lt;td data-sort-value=&quot;2&quot;&gt;2&lt;/td&gt; 可以看到，我想要的信息全部都处在&lt;tbody&gt;下的&lt;tr&gt;标签中,使用tbody &gt; tr便能提取到我想要的信息4、re是一个正则搜索库,这里主要是用到了它的findall函数，至于它的参数findPlayerTag等其实是定义为全局变量了（关于怎样定义这些变量，请百度“正则表达式”）。观察html文件，标签保存在：data-tag=”28PVL00L2”（28PVL00L2是标签），findPlayerTag = re.compile(r’data-tag=(.*)”‘)就能找到类似的字段。 三、完整代码： import urllib.error, urllib.request from bs4 import BeautifulSoup import re findPlayerTag = re.compile(r&#39;data-tag=(.*)&quot;&#39;) findPlayerName = re.compile(r&#39;data-name=(.*)&quot;&#39;) findDonate = re.compile(r&#39;&lt;td class=&quot;donations right aligned mobile-hide&quot; data-sort-value=(.*)&gt;&#39;) def askURL(url): head1 = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&quot;} reque = urllib.request.Request(url,headers = head1); html = &quot;&quot; try: response = urllib.request.urlopen(reque) html = response.read().decode(&quot;utf-8&quot;) except urllib.error.URLError as e: if hasattr(e,&quot;code&quot;): print(e.code) if hasattr(e,&quot;reason&quot;): print(e.reason) return html def getdata(url): dic = {} html = askURL(url) soup = BeautifulSoup(html,&quot;html.parser&quot;) wholedata = soup.select(&#39;tbody &gt; tr&#39;) for item in wholedata: s = str(item) tag = re.findall(findPlayerTag,s)[0] name = re.findall(findPlayerName,s)[0] donate = re.findall(findDonate,s) info = [] info += [cutName(str(name))] info += [str(donate)] dic[str(tag)[1:]] = info return dic def cutName(str): end = str.find(&#39;&quot;&#39;,2) return str[1:end] def main(): url = &quot;https://royaleapi.com/clan/YJ0PPR8J&quot; dic = getdata(url) for key,value in dic.items(): print(key) print(value) print(&quot;\\n\\n&quot;) main() 输出结果： 28PVL00L2 [&#39;神奇哟&#39;, &#39;[\\&#39;&quot;58&quot;\\&#39;, \\&#39;&quot;160&quot;\\&#39;]&#39;] 29LV0UYYR [&#39;宇宙无敌&amp;amp;地表最强 超级麦麦！&#39;, &#39;[\\&#39;&quot;326&quot;\\&#39;, \\&#39;&quot;240&quot;\\&#39;]&#39;] JY289GJ [&#39;宗大宝&#39;, &#39;[\\&#39;&quot;1013&quot;\\&#39;, \\&#39;&quot;400&quot;\\&#39;]&#39;] Q9UY98L [&#39;:(*^﹏^*):&#39;, &#39;[\\&#39;&quot;259&quot;\\&#39;, \\&#39;&quot;240&quot;\\&#39;]&#39;] 2QRRR2JGV [&#39;吉吉思密达&#39;, &#39;[\\&#39;&quot;288&quot;\\&#39;, \\&#39;&quot;256&quot;\\&#39;]&#39;] (内容过长，仅展示一小部分)","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"python","slug":"编程/python","permalink":"/categories/编程/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"/tags/爬虫/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"python","slug":"编程/python","permalink":"/categories/编程/python/"}]},{"title":"《三体》《围城》词云","slug":"WordCloud 《围城》《三体》词云应用","date":"2020-09-09T14:16:01.000Z","updated":"2020-09-17T14:19:56.654Z","comments":true,"path":"2020/09/09/WordCloud 《围城》《三体》词云应用/","link":"","permalink":"/2020/09/09/WordCloud 《围城》《三体》词云应用/","excerpt":"","text":"wordcloud是python一个简单的词云生成库，使用教程请戳—&gt;所谓词云，就是将一大段文字（可能是一份报告、一本小说）中的词频作分析，将其中出现的关键词汇通过图片显示出来。本文利用wordcloud库，生成几本非常棒的小说的词云。 一、英文书举例：When Breath Becomes Air这本书的中译名是：《当呼吸化为空气》，强推的一本书。 简介：全世界只有万分之零点一二的人会在36岁前患上肺癌，保罗·卡拉尼什（Paul Kalanithi）是其中之一。当你读到这本书时，他已经不在人世。保罗曾获得过美国斯坦福大学英语文学及人体生物学双料学位，并于英国剑桥大学获得科学史与哲学研究硕士学位，以优异成绩获得美国耶鲁大学医学博士学位，即将获得斯坦福医学院外科教授职位并主持自己的研究室。2013年，即将抵达人生巅峰的保罗，忽然被诊断出患有第四期肺癌。自此，他开始以医生和患者的双重身份，记录自己的余生，反思医疗与人性。他的文章刊登在《纽约时报》《华盛顿邮报》等媒体，获得了全球读者关注。本书文笔优美，诚挚感人，书里有着对人性、生死、医疗的深沉思索，让全球无数读者为之动容。 *上代码import wordcloud pf = open(&quot;When-Breath-Becomes-Air-Paul-Kalanithi.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) txt = pf.read().lower() pf.close() w = wordcloud.WordCloud( width = 1000, height = 700, background_color = &quot;white&quot;, max_words = 20) w.generate(txt) w.to_file(&quot;when_breath.png&quot;) 生成效果如图 这些词和篇前的一首小诗有些重合之处，蛮有意思： You that seek what life is in death,Now find it air that once was breath.New names unknown, old names gone:Till time end bodies, but souls none.Reader! then make time, while you be,But steps to your eternity.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—Baron Brooke Fulke Greville, “Caelica 83” 二、中文书举例：《三体》 《围城》与英文书相比有以下区别： 英语单词间用空格分隔(wordcloud也是使用空格来区分单词)，而汉字的词语间并没有明显的分隔 这里需要用到中文分词库jieba wordcloud默认的字体不能显示中文 需要添加字体路径文件 这里用到的是微软雅黑”msyh.tcc” 《围城》《围城》是钱钟书所著的长篇小说，是中国现代文学史上一部风格独特的讽刺小说。被誉为“新儒林外史”。第一版于1947年由上海晨光出版公司出版。故事主要写抗战初期知识分子的群相。大部分人会把它当成爱情小说吧。 import jieba import wordcloud f = open(&quot;钱钟书《围城》.txt&quot;,&quot;r&quot;, encoding=&quot;ANSI&quot;) t = f.read() f.close() ls = jieba.lcut(t) txt = &quot; &quot;.join(ls) w = wordcloud.WordCloud( font_path = &quot;msyh.ttc&quot;, width = 1000, height = 700, background_color = &quot;white&quot;) w.generate(txt) w.to_file(&quot;《围城》.png&quot;) 生成效果如图 赵辛楣可能才是方鸿渐最重要的人，所以为什么要跟孙柔嘉结婚嘛？ 《三体》中国科幻里程碑之作，不用多描述了哈哈。 代码还是同样的配方 import jieba import wordcloud f = open(&quot;刘慈欣-三体.txt&quot;,&quot;r&quot;, encoding=&quot;utf-8&quot;) t = f.read() f.close() ls = jieba.lcut(t) txt = &quot; &quot;.join(ls) w = wordcloud.WordCloud( font_path = &quot;msyh.ttc&quot;, width = 1000, height = 700, background_color = &quot;white&quot;) w.generate(txt) w.to_file(&quot;《三体》.png&quot;) 但是可以发现，这些高频词语好多都是无意义的代词，所以进一步处理下。这里使用stopwords操作排除无意义词汇 import jieba import wordcloud f = open(&quot;刘慈欣-三体.txt&quot;,&quot;r&quot;, encoding=&quot;utf-8&quot;) t = f.read() f.close() ls = jieba.lcut(t) Stop_Words = [&quot;他们&quot;,&quot;一个&quot;,&quot;自己&quot;,&quot;没有&quot;,&quot;不是&quot;&quot;还有&quot;,&quot;可以&quot;,&quot;可能&quot;,&quot;什么&quot;,&quot;已经&quot;,&quot;这样&quot;,/ &quot;就是&quot;,&quot;只有&quot;,&quot;你们&quot;,&quot;这个&quot;,&quot;当然&quot;,&quot;我们&quot;,&quot;看到&quot;,&quot;知道&quot;,&quot;现在&quot;,&quot;这种&quot;,/ &quot;这里&quot;,&quot;不是&quot;,&quot;只是&quot;,&quot;还是&quot;,&quot;如果&quot;,&quot;那个&quot;,&quot;这些&quot;,&quot;出现&quot;,&quot;还有&quot;,&quot;这时&quot;,&quot;真的&quot;] #这个列表里的词汇不会在词云中显示 txt = &quot; &quot;.join(ls) w = wordcloud.WordCloud( font_path = &quot;msyh.ttc&quot;, width = 1000, height = 700, background_color = &quot;white&quot;, stopwords=Stop_Words) w.generate(txt) w.to_file(&quot;《三体》.png&quot;) 最终效果图","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"python","slug":"编程/python","permalink":"/categories/编程/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"wordcloud","slug":"wordcloud","permalink":"/tags/wordcloud/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"python","slug":"编程/python","permalink":"/categories/编程/python/"}]},{"title":"C++ 利用迭代器删除元素后会发生什么？（转载）","slug":"C++ 利用迭代器删除元素后会发生什么？","date":"2020-09-05T09:25:00.000Z","updated":"2020-09-05T09:28:03.096Z","comments":true,"path":"2020/09/05/C++ 利用迭代器删除元素后会发生什么？/","link":"","permalink":"/2020/09/05/C++ 利用迭代器删除元素后会发生什么？/","excerpt":"","text":"原文链接：C++中利用迭代器删除元素会发生什么？ （1）关联容器对于关联容器（如map，set，multimap，multiset），删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前的iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入，删除一个结点不会对其他结点造成影响。使用方式如下例子： set&lt;int&gt; valset = { 1,2,3,4,5,6 }; set&lt;int&gt;::iterator iter; for (iter = valset.begin(); iter != valset.end(); ) { if (3 == *iter) valset.erase(iter++); else ++iter; } 因为传给erase的是iter的一个副本，iter++是下一个有效的迭代器。 (2)顺序容器对于序列式容器（如vector，deque，list等），删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。不过erase方法可以返回下一个有效的iterator。使用方式如下,例如： vector&lt;int&gt; val = { 1,2,3,4,5,6 }; vector&lt;int&gt;::iterator iter; for (iter = val.begin(); iter != val.end(); ) { if (3 == *iter) iter = val.erase(iter); //返回下一个有效的迭代器，无需+1 else ++iter; }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C++","slug":"编程/C","permalink":"/categories/编程/C/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"STL","slug":"STL","permalink":"/tags/STL/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C++","slug":"编程/C","permalink":"/categories/编程/C/"}]},{"title":"leetcode 60 求第k个排列（全排列相关）","slug":"leetcode 60 求第k个排列（全排列相关）","date":"2020-09-03T01:40:00.000Z","updated":"2020-09-03T02:08:02.962Z","comments":true,"path":"2020/09/03/leetcode 60 求第k个排列（全排列相关）/","link":"","permalink":"/2020/09/03/leetcode 60 求第k个排列（全排列相关）/","excerpt":"原题传送门 —&gt;&gt;","text":"原题传送门 —&gt;&gt; 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123”“132”“213”“231”“312”“321”给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1: 输入: n = 3, k = 3输出: “213” 示例 2: 输入: n = 4, k = 9输出: “2314” 容易想到的是深搜（回溯），但 O(n!)的复杂度可以直接判死刑了。（但是我看题解里确实回溯+剪枝过了的）下面的是种偏向数学的解法。 思路： 对于4个数字（1，2，3，4），1开头的序列有3! 、即6个，2开头的同理，那么假如要求第15个，那么一定是3（(15-1)除以6 再加1）开头 继续，3已经确定是第一个数字，剩下的数字有1，2，4。我们接下来需要求1、3、4全排列的第3（(15-1) mod 6）个数字，规则同上，则需要以第2（3除以2再加1）个数字开头， 2是第二个数字 同上，1是第3个数字，4是第4个数字 答案为3214 15 - 1 = 6 × 2 + 2 × 1 + 1 × 0 （6、2、1分别是3、2、1的阶乘），每次取第3、2、1 个数字（剩下一个数字自动补上就可以）100% kill代码： class Solution { public: string getPermutation(int n, int k) { vector&lt;int&gt; a; vector&lt;int&gt; b; for(int i = 1; i &lt;= n; ++i) b.push_back(i); a.push_back(1); for(int i = 2; i &lt; n; ++i) { a.push_back(a[i-2]*i); } int kk = k - 1; string ans; for(int i = 0; i &lt; n-1; ++i) { int j = kk/a[n-2-i]; kk %= a[n-2-i]; ans.push_back(b[j] + &#39;0&#39;); b.erase(b.begin()+ j); } ans.push_back(b[0] + &#39;0&#39;); return ans; } };","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"题解","slug":"编程/题解","permalink":"/categories/编程/题解/"}],"tags":[{"name":"编程","slug":"编程","permalink":"/tags/编程/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"题解","slug":"编程/题解","permalink":"/categories/编程/题解/"}]},{"title":"CNN News 2020/8/25 特朗普 or 拜登？","slug":"CNNnews 8月25日 拜登？特朗普？","date":"2020-08-27T14:16:01.000Z","updated":"2020-08-31T11:53:41.482Z","comments":false,"path":"2020/08/27/CNNnews 8月25日 拜登？特朗普？/","link":"","permalink":"/2020/08/27/CNNnews 8月25日 拜登？特朗普？/","excerpt":"","text":"Trump or Biden, which candidate does China want in the White House? Analysis by Selina Wang, CNNUpdated 0950 GMT (1750 HKT) August 25, 2020 Hong Kong (CNN) — US President Donald Trump recently claimed that if his Democratic rival Joe Biden wins this November’s presidential election, China will “own” the United States and Americans will have to learn to speak Chinese.The suggestion that Democrats are soft on China is a reoccurring policy theme that the President has returned to throughout his four years in oce. Now, as Trump prepares to take on Biden in a bid to secure a second term, his administration is once again amping up the anti-China rhetoric.Ahead of this week’s Republican National Convention, Trump’s campaign announced its second term agenda. The short document sets out 10 core priorities. Near the top of the agenda is “End our reliance on China,” listed right after “Jobs” and “Eradicate Covid-19.”The campaign said it plans to bring back 1 million manufacturing jobs from China and hold the country “fully accountable for allowing the virus to spread around the world.”Since Trump took oce, relations between the two countries have spiraled to their lowest point in decades. Trump has waged a tari war, sanctioned Chinese ocials, angered Beijing with his support for Taiwan, and banned Chinese technology companies, including prized telecommunications giant Huawei.Though concerns about China have become decidedly more bipartisan in recent years, there remains a view among many in Washington that Chinese leaders would prefer a President Biden come 2021. It’s an idea that was given fresh impetus, after William Evanina, a top US intelligence ocial, said in a statement last month that Beijing would rather Trump lose the election.During a key note address at the opening night of the Republican convention, Monday, former ambassador to the United Nations and former governor of South Carolina Nikki Haley said Biden would be “great for Communist China.”But experts say the reality is far more complex, and China’s leadership remains decidedly split on which candidate would better align with the country’s long-term strategic aims. Social media mockeryFrom Beijing’s perspective, Trump appears to have weakened America’s traditional alliances and international reputation. Chinese propaganda has cited Trump’s response to the pandemic, which has now killed more than 177,000 Americans, as proof of the US’ failing political system and faltering global leadership. On Chinese social media, Trump has been mockingly named “Chuan Jianguo,” or “Build up the Country Trump,” with online users positing that Trump is bolstering Chinese President Xi Jinping’s regime by wrecking America. Although Trump has unleashed an onslaught of attacks on China in the form of taris, sanctions and bans, he has largely acted unilaterally, without the support of key allies.“They know Biden will be a multilateralist, whether it’s on trade, whether it’s on security, whether it’s even on human rights,” said Stephen Orlins, president of the National Committee on US-China Relations. “He will have a multilateral approach to China and those people are fearful of a Biden presidency.” Chinese President Xi Jinping and US President Donald Trump on the sidelines of the G20 Summit in Osaka on June 29, 2019.During Trump’s presidency, China has been given a window to be more assertive on the international stage. After Trump announced America’s withdrawal from the World Health Organization (WHO), Xi said China would provide $2 billion over two years to help with the global pandemic response. China has pressed ahead with a national security law in Hong Kong, hardened its stance on self-governing Taiwan, which China views as an inseparable part of its territory, and continued to aggressively push its claims of sovereignty in the disputed waters of the South China Sea. According to Minxin Pei, professor of government at Claremont McKenna College and author of “China’s Crony Capitalism,” Biden would reinstate America’s support for multilateral organizations, including the WHO, while strengthening trade and North Atlantic Treaty Organization (NATO) military alliances — all of which would constrain China. Though Biden only mentioned China once in his acceptance speech at the Democratic National Convention last week, he has repeatedly condemned Trump for being weak on China. He’s called Xi a “thug” and his campaign ads have claimed Trump hasn’t held China accountable for the spread of the pandemic, amid suggestions Chinese ocials covered up the initial outbreak. Democratic presidential candidate Joe Biden speaks at the Democratic National Convention on August 20 in Wilmington, Delaware. In the Democrats’ sweeping 92-page party platform outlining policies including health care, climate change and the economy, China is mentioned 22 times. The document outlines how “Democrats will take aggressive action against China or any other country that tries to undercut American manufacturing,” work with “allies to stand up to China,” condemn “China’s mass internment of Uyghurs and other ethnic minorities” in Xinjiang, and enforce sanctions on entities “responsible for undercutting Hong Kong’s autonomy.” Biden wrote in a Foreign Aairs article earlier this year that, “China can’t aord to ignore more than half the global economy. That gives us substantial leverage to shape the rules of the road on everything from the environment to labor, trade, technology, and transparency, so they continue to reflect democratic interests and values.”Susan Shirk, chair of the 21st Century China Center at UC San Diego and former Deputy Assistant Secretary of State during the Clinton administration, said China has “lost a lot of friends in Asia” by using its economic power to coerce other countries into endorsing the Chinese line. “If there is a Biden administration, building a stronger coalition in Asia will be a lot easier.” Trump’s ‘unpredictability’But whereas a Biden presidency would be challenging for Beijing, Trump presents something altogether dierent for risk-averse leaders in Beijing: volatility. In a recent US intelligence report compiled by top ocial Evanina, Trump’s “unpredictability” was cited as a reason why China would prefer Biden.When Trump first took oce, he sang Xi’s praises after they dined together at his Mar-a-Lago estate in Florida. But that hasn’t stopped him alternating between aiming threats at China and announcing that he and Xi “love each other.” Experts say that this type of unpredictability increases the risk of military escalation, in areas where interests overlap, such as the South China Sea, East China Sea, and Taiwan. “We do not have a good communications and crisis prevention with China the way we had with the Soviet Union during the Cold War,” Shirk said. “So it’s a very dangerous situation.” Chinese state media has called Biden “smoother” to deal with, creating room to cooperate on major international issues like climate change and nuclear non-proliferation. Henry Wang, an adviser to China’s cabinet and founder of the Center for Globalization, said that under a Biden administration, there would be more opportunities for dialogue. Pei said the split in Chinese attitudes toward Trump and Biden depend on whether ocials in Beijing are taking a short- or long-term view. Those who take a long-term view prefer Trump, since they view him as being incompetent and unable to get allies on board, thus giving China more room to maneuver. Another four years of Trump would lead to more internal divisions within America, reducing its ability to successfully wage a long-term struggle against China, Pei said. “The Biden administration can devise a long-term strategy that is sustainable, that is multilateral with ally support, that will actually contain Chinese power, much more eectively for the next two to three decades,” Pei said. Those focused on the near-term would prefer Biden, since he would put a pause in the rapidly deteriorating relations. “A Biden administration will most likely have a pause in what I call this demolition process, Pei said. “It’s not in the US’ fundamental interest to demolish the most important relationship in the world.” 中国希望谁赢得大选？特朗普？拜登？作者: Selina Wang, CNN最后更新于 GMT 2020年 8月25日 CNN记者香港报道—— 美国总统唐纳德-特朗普声称，假如他的民主党对手拜登当选，中国将“战胜”美国,并且美国人将不得不学习汉语。 在奥巴马执政时期，特朗普就在他的政治口号中反复强调民主党对中国软弱。 而如今，在与拜登竞争以争取连任之际，特朗普再次鼓吹中国的威胁。 在本周的共和党全国代表大会之前，川普的竞选团队宣布了他们第二个任期的计划，这份简短的文件列出了十项核心计划，排在最前面便有“摆脱对中国的依赖”，这一项紧跟“工作”和“根除新冠病毒”之后，列在第三位。 川普的竞选团队称，他们计划把一百万个工作岗位从中国带回来，并认为中国对冠状病毒在世界的传播负有全责。 自特朗普接替奥巴马以来，两个国家的关系慢慢下降到了数十年的最低水平。特朗普发动了一场针锋相对的战争，对中国政府进行了制裁，他对台湾的支持激怒了北京，并且禁止了中国的科技公司，包括著名电信巨头华为。 尽管近年来两党对于中国问题的看法越来越趋于一致，仍有意见认为北京希望拜登赢得大选。在美国高级情报社会威廉·伊万尼纳(William Evanina)上个月在一份声明中表示，北京方面宁愿特朗普输掉选举后，这一想法得到了新的推力。 周一，前驻联合国大使、南卡罗来纳州前州长尼基·黑利(Nikki Haley)在共和党全国代表大会开幕当晚的一次重要讲话中表示，拜登将“对共产主义中国非常有利”。 然而专家们说情况远比这复杂，中国的领导层对于谁当选对中国的战略规划更有利这个问题上存在分歧。 社交媒体上的嘲弄从中国的角度来说，川普的表现削弱了美国的传统联盟，损坏了美国的国际声誉。中国的宣传中引用了特朗普对冠状病毒传播的应对，这场疾病流行现在已经杀死了超过17.7万美国人，这证明了美国政治体系的失败和全球领导力的削弱。 在中国的社交媒体中，特朗普被戏称为“川建国”或者“建立国家的川普”， 网友们认为特朗普正在通过破坏美国来巩固习近平主席的政权。尽管特朗普以恐怖袭击，制裁和禁令的形式对中国发动了猛烈攻击，但他基本上在单独行动，没有得到主要盟友的支持。 美中关系全国委员会(National Committee on US-China Relations)主席斯蒂芬·奥尔林斯(Stephen Orlins)表示：“他们知道拜登将是一个多边主义者，无论是在贸易、安全、甚至是人权方面。” “他将以多边的方式来对待，那些人担心拜登当选总统。” （图）2019年6月29日，中国国家主席习近平和美国总统唐纳德 · 特朗普在大阪出席 G20峰会 在特朗普的任期内，中国被给予了在世界舞台更加自信地展现自己的窗口。在特朗普宣布退出世卫组织（WHO）之后，习近平主席宣布将在未来两年内提供二十亿美元资金，以帮助应对世界疾病流行。中国已经在香港颁布了国安法，强调了对于“台独“的立场——台湾是中国领土不可分割的一部分，并继续在南海有争议海域强调自己的主权。克莱蒙特·麦肯纳学院教授、《中国的裙带资本主义》作者Minxin Pei说，拜登（上台后）将会恢复对各种组织、包括WHO、北约，这些将会约束中国。 尽管拜登在上周的总统提名演讲上仅仅提到了中国一次，但他反复谴责特朗普对中国的软弱，他称习近平主席为“暴徒”，并且他的竞选广告声称特朗普没有追究中国对疫情蔓延的责任，因为有传言称中国官员掩盖了最初的疫情。 (图)民主党总统候选人乔·拜登8月20日在特拉华州威明顿市举行的民主党全国代表大会上发表讲话。 在民主党人长达92页的政党纲领中，概述了包括医疗保健，气候变化和经济在内的政策，“中国”被提到了22次，这份文件概述了“民主党人将如何对中国或任何其他试图削弱美国制造业的国家采取积极行动”，如何与“盟友合作对抗中国”，如何谴责“中国在新疆大规模关押维吾尔族人和其他少数民族”，以及如何对“破坏香港自治”的实体实施制裁。 在今年早些时候，拜登在《外国航空》上刊文道：“中国不能忽视全球一半以上的经济。 这给了我们很大的筹码来塑造从环境到劳动力、贸易、技术和透明度等方方面面的规则，以此让它们它们继续反映民主国家的利益和价值观。苏珊·希尔克（Susan Shirk）是加州大学圣地亚哥分校21世纪中国中心主席，克林顿政府时期任美国副国务卿。他说，中国已经“利用其经济实力迫使其他国家认可‘中国路线’，从而失去了很多亚洲朋友”。 “如果有拜登政府，在亚洲建立更强大的联盟将容易得多。” 特朗普的“不可预测性”但是，尽管拜登担任总统对北京而言是具有挑战性的，但特朗普对北京的规避风险的领导人们带来了完全不同的东西：动荡。 在由高级社会人士埃文娜（Evanina）编制的最新美国情报报告中，特朗普的“不可预测性”被认为是中国偏爱拜登的原因。 特朗普刚刚接替奥巴马后，他在习近平在佛罗里达州Mar-a-Lago庄园共进晚餐后唱赞歌。 但这并没有阻止他在针对中国发动威胁与宣布他与习近平“彼此相爱”之间不停转换态度。 专家说，在诸如南中国海，东中国海和台湾等利益重叠的地区，这种不可预测性增加了军事升级的风险。 Shirk说：“与冷战时期相比，我们与中国之间的沟通和危机预防不如当时和苏联那样好。” “所以这是非常危险的情况。” 中国官方媒体称应对拜登“更为容易”，为在气候变化和核不扩散等重大国际问题上开展合作创造了空间。 中国内阁顾问、全球化中心(Center For Globalization)创始人亨利·王(Henry Wang)表示，在拜登政府的领导下，将有更多对话机会。 Pei说，中国对特朗普和拜登的态度分歧取决于北京的社会主义者是短期还是长期地看待这个问题。 那些从长远眼光看事情的人更喜欢特朗普，因为他们认为特朗普不能胜任这个位置而且无法招募盟友，从而为中国提供了更大的回旋余地。 Pei说，特朗普再任四年将导致美国内部出现更多分歧，从而降低其成功与中国进行长期斗争的能力。 Pei还说：“拜登政府可以制定一项可持续的长期战略，这是在盟友支持下的多边战略，实际上将遏制中国的力量，在接下来的两到三十年中将更加有效。” 那些关注近期局势的人更喜欢拜登，因为他会暂停迅速恶化的关系。”,Pei说：“拜登政府很可能会暂停我所说的“拆除”过程。”,“摧毁世界上最重要的关系不符合美国的根本利益。”","categories":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"CNN news","slug":"英语新闻/CNN-news","permalink":"/categories/英语新闻/CNN-news/"}],"tags":[{"name":"英语新闻","slug":"英语新闻","permalink":"/tags/英语新闻/"},{"name":"CNN","slug":"CNN","permalink":"/tags/CNN/"}],"keywords":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"CNN news","slug":"英语新闻/CNN-news","permalink":"/categories/英语新闻/CNN-news/"}]},{"title":"C++ 一个对象占用的空间大小计算（转载）","slug":"2020-8-12-cpp-class-space","date":"2020-08-12T14:16:01.000Z","updated":"2020-08-27T04:53:54.807Z","comments":false,"path":"2020/08/12/2020-8-12-cpp-class-space/","link":"","permalink":"/2020/08/12/2020-8-12-cpp-class-space/","excerpt":"一个class对象需要占用的内存空间大小，最权威的结论是： 非静态成员变量总合 加上编译器为了CPU计算，作出的数据对齐处理 加上为了支持虚函数，产生的额外负担 可以分为基类和派生类两种情况来查看一个类占用的内存空间大小。","text":"一个class对象需要占用的内存空间大小，最权威的结论是： 非静态成员变量总合 加上编译器为了CPU计算，作出的数据对齐处理 加上为了支持虚函数，产生的额外负担 可以分为基类和派生类两种情况来查看一个类占用的内存空间大小。 原文链接：https://blog.csdn.net/u011012049/article/details/48767917 基类(一)class CBase { }; sizeof(CBase)=1； c++要求每个实例在内存中都有独一无二的地址，空类也会被实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1。 (二)class CBase { private: int a; char p; }; sizeof(CBase)=8; 记得对齐的问题。int 占4字节，char占一字节，补齐3字节。 (三)class CBase { private: int a; char p; static int b; } sizeof(CBase)=8; 静态成员变量属于整个类，不单独属于某个对象。 (四)class CBase { public: void func(); private: int a; char p; }; sizeof(CBase)=8; 成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table，table里面记录的各个成员函数的地址. (五)class CBase { public: CBase(void); virtual ~CBase(void); private: int a; char *p; }; sizeof(CBase)=12 C++类中有虚函数的时候有一个指向虚函数表的指针（vptr），在32位系统分配指针大小为4字节。一个基类对象无论有多少个虚函数，只有这一个指针，4字节。在内存布局中，C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 派生类派生类的大小是本身成员变量的大小加上基类的大小。如果派生类继承了多个基类的虚函数，那个这个派生类的所有虚函数所占用的内存空间等于4*（基类个数），即为每个拥有虚函数的基类维护一张虚函数表。 class B1 { public: int x; virtual void v1(){ cout &lt;&lt; &quot;B1::v1&quot; &lt;&lt; endl; } void f1(){cout &lt;&lt; &quot;B1::f1&quot; &lt;&lt; endl; } }; class B2 { public: int y; virtual void v2(){ cout &lt;&lt; &quot;B2::v2&quot; &lt;&lt; endl; } void f2(){ cout &lt;&lt; &quot;B2::f2&quot; &lt;&lt; endl; } }; class B3 { public: int z; virtual void v3(){ cout &lt;&lt; &quot;B3::v3&quot; &lt;&lt; endl; } void f3(){ cout &lt;&lt; &quot;B3::f3&quot; &lt;&lt; endl; } }; class D : public B1, public B2, public B3 { public: int a; void v3(){ cout &lt;&lt; &quot;D::v3&quot; &lt;&lt; endl; } virtual void vD(){ cout &lt;&lt; &quot;D::vD&quot; &lt;&lt; endl; } }; 内存布局为： 与单继承相同的是所有的虚函数都包含在虚函数表中，所不同的是多重继承有多个虚函数表，当子类对父类的虚函数有重写时，子类的函数覆盖父类的函数在对应的虚函数位置，当子类有新的虚函数时，这些虚函数被加在第一个虚函数表的后面。 参考：http://blog.sina.com.cn/s/blog_69c189bf0100mkeuhttp://www.cnblogs.com/itech/archive/2009/02/28/1399995","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C++","slug":"编程/C","permalink":"/categories/编程/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"/tags/编程/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C++","slug":"编程/C","permalink":"/categories/编程/C/"}]},{"title":"The Guardian 2020/8/4 Tiktok被强制拆分","slug":"The Guardian Tiktok被强制拆分","date":"2020-08-04T13:32:00.000Z","updated":"2020-08-30T00:41:50.851Z","comments":true,"path":"2020/08/04/The Guardian Tiktok被强制拆分/","link":"","permalink":"/2020/08/04/The Guardian Tiktok被强制拆分/","excerpt":"“Forced acquisition + only 45 days + intermediary fees are not comparable to Google. It is incredible,” he said.“强制收购+仅有45天期限+收取中介费用的行径与谷歌退出中国绝不是一回事。这太不可思议了，” 他说","text":"“Forced acquisition + only 45 days + intermediary fees are not comparable to Google. It is incredible,” he said.“强制收购+仅有45天期限+收取中介费用的行径与谷歌退出中国绝不是一回事。这太不可思议了，” 他说本文在卫报当天的阅读量在全站第5位，内容均为原文原图（但是原文没有图哈哈） TikTok row: China hits out at US ‘smash and grab’ as tech dispute deepensForeign affairs spokesman accuses US of hypocrisy and editorial in state-run newspaper decries choice between submission at ‘mortal combat’ Helen Davidson Tue 4 Aug 2020 07.18 BST The US has offered China the “choice of submission or mortal combat in the tech realm”, state media in Beijing have said, as the two rival powers manoeuvred on the thorny issue of splitting up TikTok. The popular video-sharing app has joined Huawei to become a technology flashpoint, with Chinese officials and media rushing to defend it following Donald Trump’s threat of a US ban. The US president later gave Microsoft until 15 September to make an acquisition deal with TikTok’s parent company, ByteDance, and said the US Treasury should receive payment as part of the deal. As with his declaration on banning the app, he did not explain if, or how, this was possible. An editorial in the official state paper, China Daily, said China would not accept the “theft” of one of its technology companies, “and it has plenty of ways to respond if the administration carries out its planned smash and grab”. The US actions were driven by the profits in data, it said, and offered “an either-or choice of submission or mortal combat in the tech realm”. On Monday, a spokesman for China’s ministry of foreign affairs said China firmly opposed any US action against Chinese software companies over national security concerns. “The US generalises the concept of national security and, without any evidence, presumptions of guilt and threats against relevant companies,” said Wang Wenbin. “This violates the principles of market economy and exposes the hypocrisy and typical double standards of the US in maintaining fairness and freedom. It also violates the World Trade Organisation’s principles of openness, transparency and non-discrimination.” China’s ambassador to the UK, Liu Xiaoming, also accused the US of hypocrisy. “It is the US that has politicised economic issues and abused the concept of national security to pursue discriminatory and exclusive policies,” he said. Kai-Fu Lee, the former president of Google China, said the US treatment of TikTok was “unbelievable”. Lee said China set out clear rules for tech companies to comply with if they wanted to do business in the country, and Google had decided not to stay on that basis. He accused the US of giving no parameters for TikTok to work with, or providing any evidence for their national security claims “Google didn’t want to comply with Chinese laws &amp; regulations, so it quit,” said Lee, who added he had left the company prior to its exit from China. “Forced acquisition + only 45 days + intermediary fees are not comparable to Google. It is incredible,” he said. An editorial in China’s state-owned 21st Century Business Herald said forcing the sale would set a “dangerous precedent”. “For this transaction, the Chinese government may also consider reviewing whether the technology transfer in it violates Chinese laws and harms China’s national interests.” ByteDance has not confirmed any discussions with Microsoft, but an internal staff memo from founder Zhang Yiming addressed the speculation on Monday. Separately on Monday the company also said it was considering establishing TikTok’s headquarters outside the US. The reports prompted some backlash on Chinese social media, with some accusing the company of surrendering to the US, which was akin “to being anti-China”. “Choose wisely on selling to the United States or becoming an enemy at home,” wrote one user. Additional reporting by Pei Lin Wu Topics: China TikTok Asia Pacific news 译文： Tiktok之争： 科技争端加剧之下，中国谴责美国的破坏与劫掠行径外交部发言人指责美国虚伪，官方社论谴责在“殊死搏斗”中选择屈服的行为 作者：Helen Davidson英国时间 2020/8/4/ 星期二 7:18 中国官媒报道称，美国要让中国在科技领域内做出选择——“是屈服还是抗争？”。这两个敌对大国正在就拆分 TikTok 这一棘手问题上周旋。 在特朗普威胁要实行禁令后，这款广受欢迎的视频分享应用和先前的华为一样，成为科技领域的冲突中心，中国官员和媒体争相为其辩护。 之后，美国总统要求微软在9月15日之前与TikTok的母公司ByteDance达成收购协议，并表示，作为这场交易的助推者，美国财政部也应获得回报。至于他关于禁止该应用程序的声明，他没有解释这是否可行，或者如何可行。 中国官方报纸《中国日报》的一篇社论说，中国不会接受一家科技公司遭受“盗窃”，“如果（美国）政府有预谋地实施破坏和掠夺，中国有很多办法应对”。 报告称，美国的行为是受数据利润的驱动，并给中国了一个“在科技领域要么屈服要么殊死搏斗的选择”。 周一，中国外交部发言人表示，中国坚决反对美国出于国家安全考虑而对中国软件公司采取任何行动。王文彬表示：“美国滥用国家安全的概念，在没有任何证据的情况下，无端猜测相关公司违反法律或威胁国家安全。” “这违反了市场经济原则，暴露了美国在维护公平与自由方面的虚伪和典型双标。 这也违反了世界贸易组织的开放，透明和不歧视原则。 中国驻英国大使刘晓明也指责美国虚伪。 他说：“正是美国将经济问题政治化，滥用了国家安全的概念，奉行歧视性和排他性政策。” 谷歌中国前总裁李开复表示，美国对待TikTok的方式“令人难以置信”。 李表示，中国为科技公司在中国开展业务制定了明确的规则，这也是谷歌决定不在中国继续开展业务的原因。他指责美国没有告诉TikTok需要遵守怎样的规则，也没有为他们的国家安全主张提供任何证据。 李开复说，谷歌不想遵守中国的法律法规，所以退出了。李开复还说，他在谷歌退出中国之前就离开了该公司。强制收购+仅有45天期限+收取中介费用的行径不能与谷歌退出相提并论。这太不可思议了，他说。 中国国有报纸《21世纪经济报道》（21st Century Business Herald）的一篇社论说，强行收购将树立“危险先例”。 “对于这笔交易，中国政府还可以考虑审查其中的技术转让是否违反中国法律，是否损害中国的国家利益。” 字节跳动尚未证实与微软进行了任何讨论，但创始人张一鸣周一的一份内部员工信回应了这一猜测。 另外，该公司周一还表示，正在考虑在美国以外设立TikTok总部。 这些报道引发了中国社交媒体的强烈反对，有人指责该公司向美国投降，这类似于“反华”。 一位用户写道：“做出明智的选择：要么向美国出售，要么成为国内的公敌。”（这句应该有语病，但我是按英语原文翻译的，不知道是不是我理解错了。） Pei Lin Wu补充报道 主题： 中国 字节跳动 亚太 新闻 严格说来，字节跳动的遭遇算不得什么突发事件——之前华为问题时，所有人都明白华为之后必然是字节跳动。 华为和字节跳动，作为中国“走出去”最成功的民营企业，受到美国政府打压是必然的。但我也没想到特朗普政府这么“无赖”吧...（得是有多无赖才能明目张胆地收取“中介费”？） 之前有很多人说字节跳动会成为下一个互联网巨头，BAT中的B变成Byte dance（我也是这个想法）现在看来是过于乐观吧。 我也不想站在道德制高点上谴责张一鸣，他只是个商人，但我真的希望他能强硬一些，给国内一个惊喜。（现在看来不大可能啦）","categories":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"The Guardian","slug":"英语新闻/The-Guardian","permalink":"/categories/英语新闻/The-Guardian/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"The Guardian","slug":"英语新闻/The-Guardian","permalink":"/categories/英语新闻/The-Guardian/"}]},{"title":"STL map随机读取效率测试","slug":"STL map的插入与随机读取效率测试","date":"2020-07-28T02:30:00.000Z","updated":"2020-08-27T04:55:06.800Z","comments":true,"path":"2020/07/28/STL map的插入与随机读取效率测试/","link":"","permalink":"/2020/07/28/STL map的插入与随机读取效率测试/","excerpt":"背景：map是STL中的重要关联容器，可以根据key值来进行有序插入、随机读取。 map的随机读取很特殊：可以通过中括号访问。 比如map&lt;int,int&gt;sample中有一个元素为pair&lt;4,6&gt;，则可以通过sample[4]的形式访问到这个元素","text":"背景：map是STL中的重要关联容器，可以根据key值来进行有序插入、随机读取。 map的随机读取很特殊：可以通过中括号访问。 比如map&lt;int,int&gt;sample中有一个元素为pair&lt;4,6&gt;，则可以通过sample[4]的形式访问到这个元素但由于map为用AVL树存储的关联容器，而不是顺序容器，它的随机读取效率应该只有O(logn),下面进行验证。 下列测试比较了以int和string类型作key值时，插入与随机读取效率。 测试代码： #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;string&gt; #include&lt;ctime&gt; #include&lt;iomanip&gt; using namespace std; const int length_of_str = 5;//字符串长度 map&lt;string,int&gt;StringMap; map&lt;int,int&gt;IntMap; void InsertString(string &amp;str) { StringMap.insert(pair&lt;string,int&gt;(str,1)); return; } void InsertInt(int num) { IntMap.insert(pair&lt;int,int&gt;(num,1)); return; } int main() { string base = &quot;hfauiehlkesadolaijeqpjioehfuoaiyeufhesufhuiesaueiry77861423yeyadhasd73y2ade43derduisadhwuduahdjsdkajhdygyegskfdjskfaugeyrkhdagydgeygyegf&quot;; string s[100];//存储100个随机字符串 int nums[100];//存储100个随机数 for(int i = 0; i &lt; 100; ++i) { s[i] = base.substr(i,length_of_str); nums[i] = (i*762921372)%1000; } clock_t StartTime, EndTime; StartTime = clock(); for(int i = 0; i &lt; 100; ++i) { for(int i = 0; i &lt; 100; ++i) { InsertString(s[i]); } } EndTime = clock(); cout &lt;&lt; &quot;string插入时间&quot; &lt;&lt; setprecision(3) &lt;&lt; setiosflags(ios::fixed)&lt;&lt;(double)EndTime - StartTime &lt;&lt; endl; StartTime = clock(); for(int i = 0; i &lt; 100; ++i) { for(int i = 0; i &lt; 100; ++i) { InsertInt(nums[i]); } } EndTime = clock(); cout &lt;&lt;&quot;int插入时间&quot;&lt;&lt; setprecision(3) &lt;&lt; setiosflags(ios::fixed)&lt;&lt;(double)EndTime - StartTime &lt;&lt; endl; StartTime = clock(); for(int i = 0; i &lt; 100; ++i) { for(int i = 0; i &lt; 100; ++i) { int j = StringMap[s[i]]; } } EndTime = clock(); cout &lt;&lt;&quot;map:string读取时间&quot;&lt;&lt; setprecision(3) &lt;&lt; setiosflags(ios::fixed)&lt;&lt;(double)EndTime - StartTime &lt;&lt; endl; StartTime = clock(); for(int i = 0; i &lt; 100; ++i) { for(int i = 0; i &lt; 100; ++i) { int j = IntMap[nums[i]]; } } EndTime = clock(); cout &lt;&lt;&quot;map:Int读取时间&quot;&lt;&lt; setprecision(3) &lt;&lt; setiosflags(ios::fixed)&lt;&lt;(double)EndTime - StartTime &lt;&lt; endl; StartTime = clock(); for(int i = 0; i &lt; 100; ++i) { for(int i = 0; i &lt; 100; ++i) { int j = nums[i]; } } EndTime = clock(); cout &lt;&lt;&quot;顺序存储:Int读取时间&quot;&lt;&lt; setprecision(3) &lt;&lt; setiosflags(ios::fixed)&lt;&lt;(double)EndTime - StartTime &lt;&lt; endl; return 0; } 程序运行结果： string插入时间72.000 int插入时间23.000 map:string读取时间30.000 map:Int读取时间12.000 顺序存储:Int读取时间0.000 可以发现，map的随机存取与插入的时间复杂度大致是在同一级复杂度（O(logn)），在使用map的下标访问功能时，应考虑操作的时间代价。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C++","slug":"编程/C","permalink":"/categories/编程/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"/tags/STL/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C++","slug":"编程/C","permalink":"/categories/编程/C/"}]},{"title":"?:条目运算符","slug":"？：条目运算符","date":"2020-07-26T03:40:24.000Z","updated":"2020-08-27T04:54:05.680Z","comments":true,"path":"2020/07/26/？：条目运算符/","link":"","permalink":"/2020/07/26/？：条目运算符/","excerpt":"参考自: www.runoob.com 格式：Exp1 ? Exp2 : Exp3;","text":"参考自: www.runoob.com 格式：Exp1 ? Exp2 : Exp3; 其中，Exp1、Exp2 和 Exp3 是表达式。请注意冒号的使用和位置。? : 表达式的值取决于 Exp1 的计算结果。如果 Exp1 为真，则计算 Exp2 的值，且 Exp2 的计算结果则为整个 ? : 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，且 Exp3 的计算结果则为整个 ? : 表达式的值。 ? 被称为三元运算符，因为它需要三个操作数，可以用来代替如下所示的 if-else 语句： if(condition){ var = X; }else{ var = Y; } 例如，请看下面这段代码： if(y &lt; 10){ var = 30; }else{ var = 40; } 上面的代码可以写成以下语句： var = (y &lt; 10) ? 30 : 40; 在这里，如果 y 小于 10，则 var 被赋值为 30，如果 y 不小于 10，则 var 被赋值为 40。请看下面的实例： #include &lt;iostream&gt; using namespace std; int main () { // 局部变量声明 int x, y = 10; x = (y &lt; 10) ? 30 : 40; cout &lt;&lt; &quot;value of x: &quot; &lt;&lt; x &lt;&lt; endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： value of x: 40; 注意点： ?: 表达式返回值是变量本身，而不是变量的副本。也就是说，被选择的变量不止可以返回一个值，也可以直接修改这个值 如以下代码： int a = 1, b = 2； ++((a &gt; b)? a : b); 执行以后，a = 1, b = 3;","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C++","slug":"编程/C","permalink":"/categories/编程/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"C++","slug":"编程/C","permalink":"/categories/编程/C/"}]},{"title":"The Forbes 2020/7/18 特朗普使华为受重创，但这远不是结束","slug":"The Forbes 特朗普使华为受重创，但这远不是结束","date":"2020-07-21T12:40:24.000Z","updated":"2020-08-26T14:30:58.880Z","comments":true,"path":"2020/07/21/The Forbes 特朗普使华为受重创，但这远不是结束/","link":"","permalink":"/2020/07/21/The Forbes 特朗普使华为受重创，但这远不是结束/","excerpt":"Hawkish U.S. politicians come and go, this Chinese giant is playing a much longer game.美国的鹰派政客来来往往，而这个中国巨头正在玩一个更长的游戏。”","text":"Hawkish U.S. politicians come and go, this Chinese giant is playing a much longer game.美国的鹰派政客来来往往，而这个中国巨头正在玩一个更长的游戏。” 截止7月21日，本文在Forbes阅读量为37435人次 Yes, Trump Just Seriously Damaged Huawei—But This Isn’t Over YetContributor: Zak Doffman VCG VIA GETTY IMAGES We now have confirmation, if any was needed, that the U.K.’s decision to ban Huawei from its 5G network came as a direct result of pressure from U.S. President Trump and his security team. There was also the non-trivial issue of an about-turn in the advice from Britain’s spooks to its politicians—the risks with Huawei equipment could no longer be mitigated. This, again, was directly attributable to America’s campaign against the Chinese tech giant. On the surface, this may look like a victory for Washington, but it’s not that simple—Huawei is far from defeated. The clear implication in the U.K. is that the Huawei decision is all about politics and has little to do with security. The U.K. cyber team charged with defending the realm from the threats associated with Chinese equipment have only changed their view because, at America’s insistence, U.S. components inside Huawei equipment are being replaced by (likely) Chinese equivalents. A change in the political winds—there’s a U.S. election now just a few months away —and both the lobbying and the supply chain restrictions could easily fall away. This context behind the U.K.’s “materially” changed security report, that the change was fabricated by the U.S., is critical. Absent the latest sanctions, the U.K. advice would not have changed and the reason driving the U.K.’s reversal would not exist. The confirmation from leading chip supplier TSMC, that it will cease supplying Huawei in September per new U.S. rules, was also steeped in the implication that were those rules to soften or change, or were the company to successfully apply for a license to supply, than we’d be quickly back to normal. Even the structure of the U.K.’s newly announced reversal is all about the detail. The decision to bar purchases of 5G equipment from next January leaves a sizeable procurement window wide open, and is designed to restrict the acquisition of standalone 5G kit rather than LTE-to-5G upgrades. The long grace period (until 2027) before a rip and replace is mandatory, and the silence on existing 3G and 4G equipment already deployed, have left many options on the table. If a week is a long time in politics, seven years is a lifetime. Trump was quick to take credit for the U.K. decision, personalizing the victory, and it’s true that the president has campaigned long and hard to persuade his key defense and intelligence ally to toe the U.S. line. But Washington’s relationship with Beijing is starkly different to London’s. The U.S. can brush aside economic threats from China—neither can live without the other. A U.K. facing up to the harsh realities of a post-COVID Brexit is not in such a fortunate position. China issued further threats of “retaliation” in the wake of the Huawei decision. And that carries some weight in a country reliant on Chinese investments in infrastructure and technology, and with a huge install base of Huawei equipment. Huawei’s U.K. PR chief, Ed Brewster, stressed during a charged BBC Newsnight interview last week, that the company’s mission in the U.K. continues. R&D investments and the decision, announced post the 5G reversal, to open new flagship stores should tell you all you need to know about where Huawei stands on its U.K. future. “We know that millions of people here in the U.K. love our products,” the company said on announcing the £10 million (\\$12.5 million) investment. Hawkish U.S. politicians come and go, this Chinese giant is playing a much longer game. The group of U.K. politicians that has lobbied its government hard for tougher sanctions on Huawei knows there is a risk of further changes as this story runs through November’s U.S. election and whatever fallout we see from inquiries into the origins of coronavirus and Beijing’s alleged misinformation. There is also a much wider technology stand-off, one that has now dragged the TikTok into the mix. The U.S. is fast approaching a decision point as to just how far it wants to take this, before the implications on its own technology sector become much harder to sell back home. The headlines might be filled these days with news of new investments into India, but China is China, and it’s not going to be easily displaced as the world’s centre of tech manufacturing and the world’s hottest consumer market. Stepping back from this seminal week in the battle between the U.S. and Huawei, it’s hard not to think that the U.K. has left the door ajar for further twists and turns. The decision is solely based on U.S. lobbying and sanctions, and the U.K. does not want to be left holding the check should the U.S. change its tone. # 是的，特朗普刚刚重创了华为，但这远还没有结束... 作者：Zak Doffman 已经确认：在美国总统特朗普和他的安全团队压力下，英国决定会在时机恰当时禁止华为参与其5G网络建设。还有一个非常重要的问题，那就是英国的情报人员给政府提供的建议发生了180度转变，即华为设备的风险无法得到缓解。这又一次的胜利直接归因于美国对中国科技巨头的打击。从表面上看，这似乎是属于华盛顿的胜利，但真相没有那么简单——华为远未被击败。 英国方面的意思很清楚：针对华为的决定完全是出于政治，与安全几乎没有什么关系。英国负责保卫国家免受与中国设备相关的威胁的网络团突然改口否认华为，原因其实是在美国的坚持下，华为设备中的美国组件被中国的相似产品所替代（可能是）。然而，政治风向却会改变，美国大选近在眼前，政治游说和对实体管制清单都很容易消失。 更重要的是英国对安全报告做出“实质性”改变的背景——这一改变是由美国捏造的。假如没有最新的制裁措施，英国的态度就不会改变，推动英国逆转的原因将不复存在。领先的芯片供应商台积电（TSMC）确认将根据美国新规定于9月停止向华为供货，这也暗示着,倘若这些规定有丝毫松动，或者该公司成功申请了供应许可证，一切又会恢复常态。 甚至连英国最新宣布的反转都是关于具体的细节。 从明年1月起禁止购买5G设备的决定，留下了一个相当长的时间窗口用于采购。这项政策旨在限制购买完整的5G套件，但不包括从4G到5G的升级。设备的更新和更换需要足够长的时间，政策也必须要给足够长的缓冲期限（直到2027年）。已经部署好的3G和4G设备，则给了通信商很多选择空间。如果对于政治来说，七天是很长的一段时间，那么七年已经相当于一辈子了。 特朗普很快将赞扬了英国的决定，并认为这场胜利也是他的外交成果，诚然，总统已经做出长期而艰难的努力，以说服他的国防和情报盟友站到美国的战线上，但是华盛顿和北京的关系与北京和伦敦的关系截然不同。美国可以无视来自中国的经济威胁ーー两者都离不开对方。而英国没有那么幸运，在脱欧以及新冠病毒之后，英国正面对着严酷的现实。在英国做出对华为的决定之后，中国威胁会进行进一步的“报复”。对于一个依赖中国对基础设施和技术的进行投资，并且拥有庞大的华为设备安装基础的国家中，这个威胁具有一定的分量。 华为英国公关负责人埃德·布鲁斯特(Ed Brewster)上周在接受BBC新闻之夜(BBC Newsnight)采访时强调，该公司在英国的使命仍在继续。在5G问题的反转之后，华为宣布了研发投资并决定开设新旗舰店——关于华为在英国未来的立场，我想已经不言而喻了。该公司在宣布投资1000万英镑（折合1250万美元）时说：“我知道在英国有数百人喜爱我们的产品”。美国的鹰派政客来来往往，这个中国巨头正在玩一个更长的游戏。” 一直在努力游说政府对华为实施更严厉制裁的英国政界人士知道，事态有发生变化的危险。一方面11月即将进行美国大选，另一方面，我们在调查冠状病毒来源和以及北京所谓的虚假信息所导致的任何后果，都给未来埋下隐患。另外还有一场更广泛的技术对峙，这场对峙已经将字节跳动公司（TikTok）也拖入了泥潭。 这个问题（中美对峙）对美国国科技行业的影响使会使得美国的政策难以在国内继续推行，这迫使美国必须快速做出决定：在这个问题上美国究竟要走多远？ 这些天的头条新闻可能充斥着对印度的新投资，但中国就是中国，它不会轻易取代中国，成为世界科技制造业中心和世界上最热门的消费市场。 最后，我们再回头看看美国与华为战斗的这重要一周，我们很难不去想：英国已经为未来的混乱打开了半扇大门。这一决定完全基于美国的游说和制裁，如果美国变卦，英国不希望看到自己承担后果。 唠两句： 最近英国“反戈”，台积电断供，国人又把目光投向华为。 我找了找国外相关报道，结果充斥各个新闻门户的全是关于美国大选和新冠病毒，关于华为的只有几则简讯。大部分简讯其实是反华的，“义正言辞”地扯一些关于“国家安全”，“情报”之类的犊子。而长篇的文章很少，只看到这么一篇还算像样的。 中美对峙正影响到我们每一个人。 华为以及文中提到的字节跳动，是我不少学长的毕业去向。尤其是字节跳动，今年扩招4w员工让很多人意外，不少大四甚至大三学长已经拿到offer（我甚至怀疑字节跳动提供这么多岗位是在争取政府对它的支持）。而华为和字节跳动的未来是扑朔迷离的，这和中美关系息息相关。 中国的科技巨头们不大可能倒下，毕竟国内市场这么大，不至于被美国扼住喉咙，但是肯定会有波折，也许会裁员，也许会业绩下滑...中国能够对抗美国，但是对国内的公司（其实也包括美国一些公司），生存下来未必轻松。","categories":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"Forbes","slug":"英语新闻/Forbes","permalink":"/categories/英语新闻/Forbes/"}],"tags":[{"name":"英语新闻","slug":"英语新闻","permalink":"/tags/英语新闻/"}],"keywords":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"Forbes","slug":"英语新闻/Forbes","permalink":"/categories/英语新闻/Forbes/"}]},{"title":"The Guardian 2020/7/18 被撕裂的美国","slug":"The Guardian 7月18日 被撕裂的美国","date":"2020-07-18T13:40:24.000Z","updated":"2020-08-26T14:36:59.671Z","comments":true,"path":"2020/07/18/The Guardian 7月18日 被撕裂的美国/","link":"","permalink":"/2020/07/18/The Guardian 7月18日 被撕裂的美国/","excerpt":"With flu season on the horizon and Donald Trump demanding that millions of students return to school in the fall – not to mention a presidential election quickly approaching – the country appears at risk of being torn apart.流感季节即将到来、大选临近、总统又要求学校秋季开学——美国正面临被撕裂的危险。","text":"With flu season on the horizon and Donald Trump demanding that millions of students return to school in the fall – not to mention a presidential election quickly approaching – the country appears at risk of being torn apart.流感季节即将到来、大选临近、总统又要求学校秋季开学——美国正面临被撕裂的危险。本文在卫报当天的阅读量在全站第2位，内容均为原文原图 The virus doesn’t care about excuses’:US faces terrifying autumn as Covid19 urgesThe breathing space afforded by lockdowns in the spring has been squandered, with new cases running at five times the rate ofthe whole of Europe. Things will only get worse, experts warn by Tom McCarthy in New YorkCoronavirus latest global updatesMain image: Composite: Guardian Design/Getty/ShutterstockSat 18 Jul 2020 06.00 BST In early June, the United States awoke from a months-long nightmare.Coronavirus had brutalized the north-east, with New York City alone recording more than 20,000 deaths, the bodies piling up in refrigerated trucks. Thousands sheltered at home. Rice, flour and toilet paper ran out. Millions of jobs disappeared. But then the national curve flattened, governors declared success and patrons returned to restaurants, bars and beaches. “We are winning the fight against the invisible enemy,” vicepresident Mike Pence wrote in a 16 June op-ed, titled, “There isn’t a coronavirus ‘second wave’.” Except, in truth, the nightmare was not over – the country was not awake – and a new wave of cases was gathering with terrifying force. As Pence was writing, the virus was spreading across the American south and interior, finding thousands of untouched communities and infecting millions of new bodies. Except for the precipitous drop in New York cases, the curve was not flat at all. It was surging, in line with epidemiological predictions. Now, four months into the pandemic, with test results delayed, contact tracing scarce， protective equipment dwindling and emergency rooms once again filling, the United States finds itself in a fight for its life: swamped by partisanship, mistrustful of science, engulfed in mask wars and led by a president whose ncompetence is rivaled only by his indifference to Americans’ suffering. With flu season on the horizon and Donald Trump demanding that millions of students return to school in the fall – not to mention a presidential election quickly approaching – the country appears at risk of being torn apart. “I feel like it’s March all over again,” said William Hanage, a professor of epidemiology at the Harvard TH Chan School of Public Health. “There is no way in which a large number of cases of disease, and indeed a large number of deaths, are going to be avoided.” The problem facing the United States is plain. New cases nationally are up a remarkable 50% over the last two weeks and the daily death toll is up 42% over the same period. Cases are on the rise in 40 out of 50 states, Washington DC and Puerto Rico. Last week America recorded more than 75,000 new cases daily – five times the rate of all Europe. “We are unfortunately seeing more higher daily case numbers than we’ve ever seen, even exceeding pre-lockdown times,” said Jennifer Nuzzo, an epidemiologist at the Johns Hopkins Center for Health Security. “The number of new cases that occur each day in the US are greater than we’ve yet experienced. So this is obviously a very worrisome direction that we’re headed in.” Donald Trump speaks to the media before boarding Marine One on 10 July to head to coronavirus-stricken Florida as he ramps up public appearances ahead of the election. Photograph: Shawn Thew/Bloomberg/Getty Images The mayor of Houston, Texas, proposed a “two-week shutdown” last week after cases in the state climbed by tens of thousands. The governor of California reclosed restaurants, churches and bars, while the governors of Louisiana, Alabama and Montana made mask-wearing in public compulsory.“Today I am sounding the alarm,” Governor Kate Brown said. “We are at risk of Covid-19 getting out of control in Oregon.” As dire as the current position seems, the months ahead look even worse. The country anticipates hundred of thousands of hospitalizations, if the annual averages hold, during the upcoming flu season. Those hospitalizations will further strain the capacity of overstretched clinics. But a flu outbreak could also hamper the country’s ability to fight coronavirus in other ways. Because the two viruses have similar symptoms – fever, chills, diarrhea, fatigue – mistaken diagnoses could delay care for some patients until it’s too late, and make outbreaks harder to catch, one of the country’s top health officials has warned. “I am worried,” Dr Robert Redfield, the director of the Centers for Disease Control (CDC), said last week. “I do think the fall and the winter of 2020 and 2021 are probably going to be one of the most difficult times that we have experienced in American public health because of … the co-occurrence of Covid and influenza.” Other factors will be in play. A precipitous reopening of schools in the fall, as demanded by Trump and the education secretary, Betsy DeVos, without safety measures recommended by the CDC, could create new superspreader events, with unknown consequences for children. “We would expect that to be throwing fuel on the fire,” said Hanage of blanket school reopenings. “So it’s going to be bad over the next month or so. You can pretty much expect it to be getting worse in the fall.” The list of aggravating circumstances goes on and on. A federal unemployment assistance program that gave each claimant an extra 600 a month is set to expire at the end of July. A new coronavirus relief package is being held up in Congress by Republicans’ accusations that states are wasting money, and their insistence that any new legislation include liability protections for businesses that reopen during the pandemic. Customers shop for fruit at a street vendor in the Corona neighborhood in Queens, New York, on 27 June. Photograph: Amir Hamja/Bloomberg/Getty Images Cable broadcasts and social media have been filled, meanwhile, with video clips of furious confrontations on sidewalks, in stores and streets over wearing facial masks. In Michigan, a sheriff’s deputy shot dead a man who had stabbed another man for challenging him about not wearing a mask at a convenience store. In Georgia, the Republican governor sued the Democratic mayor of Atlanta for issuing a city-wide mask mandate. The partisan divide on masks is slowly closing as the outbreaks intensify. The share of Republicans saying they wear masks whenever they leave home rose 10 points to 45% in the first two weeks of July, while 78% of Democrats reported doing so, according to an Axios-Ipsos poll. Another divide has proven tragically resilient. As hotspots have shifted south, the virus continues to affect Black and Latinx communities disproportionately. Members of those communities are three times as likely to become infected and twice as likely to die from the virus as white people, according to data from early July. The raging virus has prompted speculation in some corners that the only way out for the United States is through some kind of “herd immunity” achieved by simply giving up. But that grossly underestimates the human tragedy such a scenario would involve, epidemiologists say, in the form of tens of millions of new cases and unknown thousands of deaths. “I think that every single serology study that’s been done to date suggests that the vast majority of Americans have not yet been exposed to this virus,” Nuzzo said. “So we’re still very much in the early stages. “Which is good, that’s actually really good news. I don’t want to strive for herd immunity, because that means the vast majority of us will get sick and that will mean many, many more deaths. The point is to slow the spread as much as possible, protect ourselves as much as possible, until we have other tools.” But the ability of the US to take that basic step – to slow the spread, as dozens of other countries have done – is in perilous doubt. After half a year, the Trump administration has made no effort to establish a national protocol for testing, contact tracing and supported isolation – the same proven three-pronged strategy by which other countries control their outbreaks. Critics say that instead, Trump has dithered and denied as the national death toll climbed to almost 140,000. The Democratic presidential candidate, Joe Biden, who is hoping to unseat Trump in November, blasted the president for refusing until recently to wear a mask in public. “He wasted four months that Americans have been making sacrifices by stoking divisions and actively discouraging people from taking a very basic step to protect each other,” Biden said in a statement last weekend. A healthcare worker talks to a patient in the ER at Oakbend medical center in Richmond, Texas, on 15 July. Photograph: Mark Felix/AFP/Getty Images Meanwhile the White House has attacked Dr Anthony Fauci, the country’s foremost expert on infectious diseases whose refusal to lie to the public has enraged Trump, by publishing an oped signed by one of the president’s top aides titled “Anthony Fauci has been wrong about everything I have interacted with him on” and by releasing a file of opposition research to the Washington Post. Trump claimed the number of cases was a function of unusually robust testing, though experts said that positivity rates of 20% in multiple states suggested that the United States is testing too little – and that in any case closing one’s eyes to the problem by testing less would not make it go away. “We’ve done 45 million tests,” Trump said this week, padding the figure only slightly. “If we did half that number, you’d have half the cases, probably around that number. If we did another half of that, you’d have half the numbers. Everyone would be saying we’re doing well on cases.” Such statements by Trump have encouraged unfavorable comparisons of the US pandemic response with those in countries such as Italy, which recorded just 169 new cases on Monday after a horrific spring, and South Korea, which has kept cases in the low double-digits since April. The Senate majority leader, Mitch McConnell, walks to his office from the Senate floor on 13 May. Photograph: Shawn Thew/EPA But the United States could also look to many African countries for lessons in pandemic response, said Amanda McClelland, who runs a global epidemic prevention program at Resolve to Save Lives. “We’ve seen some good success in countries like Ghana, who have really focused on contact tracing, and being able to follow up superspreading events,” said McClelland. “We see Ethiopia: they kept their borders open for a lot longer than other countries, but they have really aggressive testing and active case-finding to make sure that they’re not missing cases. “I think what we’ve seen is that you need not just a strong health system but strong leadership and governance to be able to manage the outbreak, and we’ve seen countries that have all three do well.” Factory workers produce personal protective equipment for coronavirus frontline health workers at a factory commissioned by the government, in Accra, Ghana, on 17 April. The US pandemic response compares unfavorably with a number of African countries. Photograph: Nipah Dennis/AFP/Getty Images But in America, the large laboratories that process Covid-19 tests are unable to keep up with demand. Quest Diagnostics announced on Tuesday that its average turnaround time for test results was a minimum of seven days for most patients. “We want patients and healthcare providers to know that we will not be in a position to reduce our turnaround times as long as cases of Covid-19 continue to increase dramatically,” the lab said. “You can’t have unlimited lab capacity, and what we’ve done is allow, to some extent, cases to go beyond our capacity,” said McClelland. “We’re never going to be able to treat and track and trace uncontrolled transmission. This outbreak is just too infectious.” Public health experts emphasize that the United States does not have to accept as its fate a cascade of tens of millions of new cases, and tens of thousands of deaths, in the months ahead. Focused leadership and individual resolve could yet help the country follow in the footsteps of other nations that have successfully faced serious outbreaks – and brought them under control. But it is clear that the most vulnerable Americans, including the elderly and those with preexisting conditions, face grave danger. Republicans have argued in recent weeks that while cases in the US have soared, death rates are not climbing so quickly, because the new cases are disproportionately affecting younger adults. That is a false reassurance, health experts say, because deaths are a lagging indicator – cases necessarily rise before deaths do – and because large outbreaks among any demographic group speeds the virus’s ability to get inside nursing homes, care facilities and other places where residents are most vulnerable. “If we don’t do anything to stop the virus, it’s going to be very difficult to prevent it from getting to people who will die,” said Nuzzo. A United States flag flies at half-mast outside the Hammonton center for rehabilitation and healthcare in Hammonton, New Jersey, on 19 May. Photograph: Lucas Jackson/Reuters There is a question of whether the United States, for all its wealth and expertise – and its selfregard as an exceptional actor on the world stage – can summon the will to keep up the fight. People are tired of fighting the virus, and of fighting each other. “I think unfortunately people are emotionally exhausted from having to think about and worry about this virus,” said Nuzzo. “They feel like they’ve already sacrificed a lot. So the worry that I have is, what willingness is there left, to do what it takes?” It is as if the country is “treading water in the middle of the ocean”, Hanage said. “People tend to be shuffling very quickly between denial and fatalism,” he said. “That’s really not helpful. There are a number of things that can be done. “What I would hope is that this marks a point when the United States finally wakes up and realizes that this is a pandemic and starts taking it seriously. “Folks tend to look at what has happened elsewhere and then they make up some kind of magical reason why it’s not going to happen to them. “People keep making these excuses, and the virus doesn’t care about the excuses. The virus just keeps going. If you give it the opportunity, it will take it.” America faces an epic choice …… in the coming months, and the results will define the country for a generation. These are perilous times. Over the last three years, much of what the Guardian holds dear has been threatened – democracy, civility, truth. The country is at a crossroads. Science is in a battle with conjecture and instinct to determine policy in the middle of a pandemic. At the same time, the US is reckoning with centuries of racial injustice – as the White House stokes division along racial lines. At a time like this, an independent news organisation that fights for truth and holds power to account is not just optional. It is essential. 译文：病毒才不会听你的借口： Covid使美国面临可怕的秋季春季的封锁所争取到的机会已经被浪费，病例的增长速度是整个欧洲的五倍。专家警告说，情况只会变得更糟… 作者：纽约记者Tom McCarthy栏目：病毒最新讯息主要图片来源 Guardian Design/Getty/Shutterstock时间：英国时间2020年7月18日 星期六 6：00 6月初，美国从长达数月的噩梦中醒来。 冠状病毒使东北部遭受重创，仅纽约市就有2万多人死亡，冷藏卡车中尸体堆积如山。 数千人躲在家里，用光了大米，面粉和纸巾。 数以百万计的岗位消失了。 但随后，全国病例增长曲线变得平坦，州长们宣布了胜利的消息，人们又回到了餐馆、酒吧和海滩。 副总统迈克·彭斯(Mike Pence)在6月16日发表的题为“不会出现‘第二波’冠状病毒”的专栏文章中写道：“我们正在赢得这场与看不见的敌人的战斗。” 但是，事实上，噩梦还没有结束——这个国家还没有醒来——新一波的病例正以可怕的力量涌现。 就在彭斯写这篇文章的时候，病毒正在美国南部和内陆蔓延，它找到了数千个之前未受影响的社区，并感染了数百万新的宿主。 除了纽约的病例急剧下降外，这条曲线根本不是平坦的。 与流行病学预测一致，感染者的数量正在激增。 现在，病毒已经肆虐四个月了，检测排查被推迟、对接触者的追踪几乎没有、防护设备越来越少、急诊室又一次挤满了人，美国发现自己陷入了一场关乎生存的战斗：既有党派之争，又有对科学的不信任，并身陷口罩战争（即：戴口罩还是不戴口罩在美国引起的政治/社会冲突，有点儿滑稽）的泥潭，而领导这场战斗的总统，既无能又对美国人们毫不关心。 流感季节即将到来、特朗普要求数百万学生在秋季重返校园——再加上总统选举的迅速临近——这个国家似乎面临被撕裂的风险。 哈佛大学公共卫生学院流行病学教授William Hanage说，“三月的情况又要重现。” “我们没有办法避免大量的病例，甚至是大量的死亡。” 美国面临的问题是显而易见的。在过去的两周里，全国的新病例上升了50%，而同时每天的死亡人数上升了42%。在50个州中的40个州，华盛顿特区和波多黎各的病例呈上升趋势。上周，美国每天记录到75000多个新病例，是整个欧洲病例增长速度的五倍。 约翰 · 霍普金斯健康安全中心(Johns Hopkins Center for Health Security)的流行病学家珍妮弗 · 努佐(Jennifer Nuzzo)说，“不幸的是，我们每天看到的病例数量比以往任何时候都多，甚至超过了封锁前。“美国每天的新病例数量正在刷新之前的记录。因此，我们显然正朝着一个非常令人担忧的方向前进。 (图片:7月10日，唐纳德·特朗普登上“海军一号”，前往遭受冠状病毒袭击的佛罗里达州，在大选前增加在公众的露面，在此之前他接受了媒体采访。图片来源：Shawn Thew/彭博社/盖蒂图像） 上周，得克萨斯州休斯敦市长提议“一切活动中止两周” ，此前该州的病例增加了数万例。加利福尼亚州州长重新关闭了餐厅、教堂和酒吧，而路易斯安那州、阿拉巴马州和蒙大拿州的州长则强制要求在公共场合戴口罩。 “今天我敲响警钟，”州长 Kate Brown 说，“我们正面临着新冠肺炎在俄勒冈州失控的危险。” 尽管目前的形势看起来很可怕，但未来几个月的情况或许更糟。 该国预计，在即将到来的流感季节，按照往年的平均水平，将有数十万人住院，这些人的住院将使本就超负荷运转的诊所更加不堪重负。 并且流感的爆发也会以其他方式阻碍该国抗击新冠病毒。该国一位高级卫生官员警告说，由于这两种病毒有相似的症状——发烧、发冷、腹泻、疲劳——错误的诊断可能会延误对一些病人的治疗，直到错过最佳治疗时期，并使新疫情的爆发更难被发现。 “我很担心，”疾病控制中心(CDC)Robert Redfield博士上周说。 “我认为2020年和2021年的秋天和冬天可能会是我们在美国公共卫生领域经历的最艰难的时期之一，因为… 冠状病毒和流感并存。” 其他因素也将发挥作用。 在没有采取疾控中心建议的安全措施的情况下，特朗普和教育部长贸然要求学校在秋季开学。这可能会引发新的超级传播事件，给孩子们带来未知的后果。 “我们预计这是火上浇油，” Hanage在谈到全日制学校重新开学时说,“所以下个月左右的情况会很糟糕。 并且几乎可以肯定，秋季会更糟糕。” 形势急转直下。 一项联邦失业援助计划将在7月底到期，该计划每月为每名索赔人补助600美元。 共和党人指责各州在浪费资金，并坚持要求任何新的立法都包括对在大流行期间重新营业的企业的责任保护，这是国会提出的一项新的冠状病毒救助方案。 图片：6月27日，在纽约皇后区科罗纳社区，顾客在街头小贩处选购水果 图片来源：Amir Hamja/彭博社/盖蒂图片社 与此同时，在人行道上、商店和街道上因戴不戴口罩而引起了激烈对抗，这类视频充斥于有线广播和社交媒体上。在密歇根州，一名警长的副手开枪打死了一名男子，该男子刺伤了另一名男子，起因是他因为不戴口罩而被这名被刺伤的男子责备。 在佐治亚州，共和党州长起诉亚特兰大民主市长，理由是他发布了在全市范围内佩戴口罩的命令。 随着疫情的加剧，党派在口罩问题上的分歧正在慢慢弥合。根据Axios-Ipsos的一项民意调查，在7月的前两周，共和党人说他们每次出门都戴口罩的比例上升了10个百分点，达到45%，而民主党人为78%。 另一个分歧在悲剧性地在现实中重演。 随着感染中心向南转移，该病毒继续不成比例地影响到黑人和拉丁裔社区。 根据7月初的数据，这些社区的成员被感染的几率是白人的三倍，死亡率是白人的两倍。 肆虐的病毒在一些角落引发了人们的猜测：美国唯一的出路就是通过简单的放弃来实现某种“群体免疫”。但流行病学家说，这严重低估了这种情况将导致的人类悲剧，即数以千万计的新病例和不可估计的死亡人数。 Nuzzo说：“我认为迄今为止进行的每项血清学研究都表明，绝大多数美国人尚未接触过这种病毒。” “因此，我们仍处于开始阶段。 “这很好，这实际上真的是个好消息。 我不想争取群体免疫力，因为这意味着我们中的绝大多数人会生病，这意味着会有更多的人死亡。 关键是要在找到新的手段前，尽可能地减缓扩散，尽可能地保护自己。” 但美国是否有能力采取基本措施，如数十个其他国家所做的那样，减缓扩散，这一点令人怀疑。疫情已经扩散半年，特朗普政府没有努力建立任何一项用于检测新病例、接触者追踪和支持隔离的政策——这套“三管齐下”的措施在其他国家已经被证明行之有效。 批评者说，随着全国死亡人数攀升至近14万人，特朗普不仅没有采取这些措施，并且犹豫不决甚至予以否认。民主党总统候选人Joe Biden希望在11月让特朗普下台，他抨击总统直到最近才拒绝在公共场合戴口罩。 拜登在上周末的一份声明中说：“他浪费了四个月的时间，一直在煽动分裂和积极劝阻人们采取基本的自我保护手段，这造成了人民不必要的牺牲” 图片：7月15日，在德克萨斯州里士满的奥克本德医疗中心，一名医护人员在急诊室与一名患者交谈。图片来源：Mark Felix/法新社/盖蒂图片社 与此同时，白宫抨击了美国最重要的传染病专家安东尼·福奇(Anthony Fuci)博士。原因是他拒绝对公众撒谎激怒了特朗普。他之前发表了一篇由总统的一名高级助手签名的专栏文章，题为“安东尼·福奇在我与他互动的一切问题上都是错误的”，并向华盛顿邮报公布了一份反对党的研究文件。 特朗普声称，病例数量庞大是因为美国做了强有力的检测，尽管专家表示，多个州20%的阳性率表明美国检测太少——无论如何，通过减少检测而对问题视而不见并不能让问题消失。 “我们已经做了4500万次测试，”特朗普本周说，这个数字仅有略微的夸张。 “如果我们做这个数字的一半，病例就会减少一半，大约就是这个数字。 如果我们再做一半，你就有一半的数字。 每个人都会说我们在控制病例上做得很好。“ 特朗普的这种言论助长了社会将美国的应对措施与其他国家的对比。在经历了一个可怕的春季之后，意大利周一仅出现169例新病例。而韩国，自4月份以来病例数一直维持在两位数。 （图片：5月13日，参议院多数党领袖米奇·麦康奈尔(Mitch McConnell)从参议院走到他的办公室。图片来源：Shawn Thew/EPA） 但Amanda McClelland说，美国也可以向许多非洲国家学习应对大流行的经验教训。McClelland负责一个全球流行病预防项目，名为Resolve To Save Life。 “在加纳这样的国家，我们已经看到了不错的成功，这些国家非常专注于联系追踪，并且能够跟进超级传播事件。” McClelland说，“我们看到埃塞俄比亚：他们的边境开放时间比其他国家长了很多，但他们确实积极地检测、主动地寻找病例，以确保不会遗漏病例。” “我认为我们看到的情况是，你不仅需要强大的卫生系统，还需要强有力的领导和治理，才能控制疫情，我们已经看到这三个国家都做得很好。” （图片：4月17日，在加纳阿克拉政府委托的一家工厂里，工厂工人为冠状病毒前线卫生工作者生产个人防护设备。 与许多非洲国家相比，美国的大流行应对措施并不让人满意。 图片来源Nipah Dennis /法新社/盖蒂图片社） 但在美国，处理新冠肺炎检测的大型实验室跟不上需求。 Quest Diagnostics周二宣布，对于大多数患者来说，得到测试结果的平均周期至少为7天。 该实验室表示：“我们希望患者和医疗服务提供者知道，只要新冠肺炎的病例继续大幅增加，我们就无法缩短检测周期。” “你不可能拥有无限的实验室容量，我们所做的就是在某种程度上允许病例超出我们的能力。” McClelland说，“我们永远无法追踪和控制失控的传播，这次爆发的传染性太强了。” 公共卫生专家强调，在接下来的几个月中，美国不必认为数千万的新病例和数千人的死亡是已经注定的。 专注的领导力量和个人决心仍可帮助该国效仿成功应对严重疫情的其他国家，并使疫情受到控制。 但很明显，最脆弱的美国人，包括老年人和有既往疾病的人，面临着严重的危险。 共和党人最近几周辩称，尽管美国的病例激增，但死亡率并没有上升得那么快，因为新病例对年轻人的影响不成比例。 卫生专家表示，共和党人的保证是错误的，因为死亡率是一个滞后指标——病例必然先于死亡率上升——还因为任何大规模疫情爆发都会加速病毒进入疗养院、护理机构和其他居民最易感染的地方的能力。 Nuzzo说：“如果我们不采取任何措施来阻止这种病毒，将很难阻止它传播给将要死亡的人。” （图5月19日，在新泽西州哈蒙顿的哈蒙顿康复和医疗中心外，一面美国国旗降半旗。图片来源: Lucas jackson/路透社） 有一个问题是，尽管美国拥有财富和专业知识，而且自诩为世界舞台上的杰出角色，但它是否能够鼓起继续战斗的勇气？人们厌倦了与病毒作斗争，也厌倦了相互斗争。 “我认为不幸的是，人们已经因为不得不思考和担心这种病毒而精疲力竭，” Nuzzo 说,“他们觉得自己已经牺牲了很多。因此，我担心的是，他们还有什么意愿去做需要做的事情呢? ” Hanage说，这个国家仿佛正在“大洋中央涉水”。 “人们往往在肯定和否定宿命之间摇摆不定，”他说， “这真的没有什么用，有很多事情是可以做的。” “我希望这标志着美国终于醒来，意识到这是一场流行病，并开始认真对待它。” 人们倾向于看看其他地方发生了什么，然后他们会编出某种神奇的理由，来说明为什么不会发生在他们身上。 美国面临史诗般的选择……在接下来的几个月里，选举结果将定义这个国家的一代人。 这是一个危险的时代， 在过去的三年里，“卫报”珍视的许多东西都受到了威胁——民主、文明、真理。 这个国家正处于十字路口。 科学正在与猜想和本能作斗争，以便在大流行期间决定政策。与此同时，美国正在重新考虑几个世纪以来的种族歧视，因为白宫加剧了种族分歧。在这样的时候，一个为真理而战并拥有问责权的独立新闻机构不仅是可选的,更是必不可少的。","categories":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"The Guardian","slug":"英语新闻/The-Guardian","permalink":"/categories/英语新闻/The-Guardian/"}],"tags":[{"name":"英语新闻","slug":"英语新闻","permalink":"/tags/英语新闻/"}],"keywords":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"The Guardian","slug":"英语新闻/The-Guardian","permalink":"/categories/英语新闻/The-Guardian/"}]},{"title":"音乐 • Down • 杂想","slug":"Music-Down","date":"2020-07-14T13:55:24.000Z","updated":"2020-10-20T12:35:18.435Z","comments":true,"path":"2020/07/14/Music-Down/","link":"","permalink":"/2020/07/14/Music-Down/","excerpt":"I’m not ready to let go我还没有准备好放手Cause then I’d never know因为我永远无法得知What I could be missing我会错过些什么","text":"I’m not ready to let go我还没有准备好放手Cause then I’d never know因为我永远无法得知What I could be missing我会错过些什么 But I’m missing way too much但是我已经错过太多太多太多So when do I give up所以当我真正要放弃的时候What I’ve been wishing for我还在渴望什么？ I shot for the sky我努力飞向天空I’m stuck on the ground却被困在地上So why do I try所以我为什么还在挣扎I know I’m gonna fall down我知道我即将沉沦I thought I could fly我以为我能够飞翔So why did I drown所以我为什么还要争取Never know why我永远都不知道为什么It’s coming down, down, down我一直都在坠落、坠落、坠落 几天前的某次班会，几个快毕业的学长说：想好自己要干什么，好钢要用到刀刃上。没能让我对未来思考得更清楚，反而搞得我心里很乱。 核心问题是要不要考研：考研与直接工作走的是两条不太相似的路：一条偏理论，一条偏实践。尽管两者都很重要，但是总要有一个权衡，知识确实没有高低，但是在不同的场合，知识会发挥不同的作用。 本来，所有的任课老师都告诉我们：一定要读研，最好争取保研。这条路确实没有问题。读研做的确实是更有知识深度的工作，但是“有知识深度”与“有创造力”未必是一回事，甚至是毫不相干的事情。 并且，直接工作才不是停止学习——工作中的学习会更多。 或许两条路没什么区别。但我还有另外的因素吧：比如我有没有魄力进入职场呢？读研或许能给我几年缓冲期。比如——家里人都是希望我读研的，部分人甚至让我读博…（哦我是山东人） 有人教我“有的放矢”，有人教我“好钢用在刀刃上”可是，我真的只能不停选择，不停犯错，才能找到一条路吧。 *写于7月14日夜*","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"音乐","slug":"音乐","permalink":"/tags/音乐/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"BBC news 2020/7/12 国安法颁布 离开的香港人","slug":"BBC news 7月12日 国安法颁布 离开的香港人","date":"2020-07-12T13:55:24.000Z","updated":"2020-08-25T14:44:14.591Z","comments":true,"path":"2020/07/12/BBC news 7月12日 国安法颁布 离开的香港人/","link":"","permalink":"/2020/07/12/BBC news 7月12日 国安法颁布 离开的香港人/","excerpt":"The UK now wants to offer BNO passport holders citizenship rights after six years of stay, arguing that China has breached the Sino-British Joint Declaration by enacting the national security law, which violates the city’s high degree of autonomy and infringes the civil liberties of Hong Kong residents.英国现在希望给予英国护照持有者在居留六年后的公民权利，解释称香港国安法违反了“中英联合声明”，破坏了城市的高度自治，侵犯了香港公民自由。","text":"The UK now wants to offer BNO passport holders citizenship rights after six years of stay, arguing that China has breached the Sino-British Joint Declaration by enacting the national security law, which violates the city’s high degree of autonomy and infringes the civil liberties of Hong Kong residents.英国现在希望给予英国护照持有者在居留六年后的公民权利，解释称香港国安法违反了“中英联合声明”，破坏了城市的高度自治，侵犯了香港公民自由。 本文在BBC news 当天的阅读量排在第 5位，内容均为原文原图。仅用于深入了解事件，西方与国内的价值观不同，请时刻保持理性,“人权”和“自由”绝不是干涉中国内政的正当理由 图片在手机页面经常不能加载，推荐移步PC端 Hong Kong security law: Why we are taking our BNOs and leavingBy Grace Tsoi BBC News, Hong Kong12 July 2020 &nbsp;Since China imposed a draconian national security law on Hong Kong, a lot of dinner party chatter in this protest-minded city has been about personal exit strategies. For up to three million Hongkongers, the exit could come in the form of a British National (Overseas) passport. Will they really leave - and what of those left behind? Michael and Serena have decided to leave Hong Kong for good and settle in the UK, a country they have never set foot in.The couple have British National (Overseas) - or BNO - passports, which were issued to Hong Kong residents that registered before the city was handed back to China on July 1997.Essentially a travel document with rights for some consular assistance, its usefulness seemed limited to many for anything but easier access to the UK and European travel. Some people went for it anyway. Why not, went the thinking for many Hongkongers. Michael and Serena are the embodiment of the comfortable prosperity common in Hong Kong: well-travelled with a 13-year-old daughter, they are both middle managers in a bank and bought a flat many years ago. It is a lot to give up. They say that Hong Kong has become unrecognisable in its handling of the months-long protests triggered by a bill which proposed to allow extradition to mainland China. What the couple saw was a government which did not listen to the people, and police force that showed little restraint.Their daughter has been deeply affected by the protests, even though the family did not take part because the couple work at a Chinese bank, where an employee was fired for protesting.“She has been very angry and upset. She kept asking why the authorities could treat us like that?” Serena said, adding that their daughter had told them she wanted to study abroad.The controversial national security law, which took effect last week, was the last straw.“The articles of the national security law are outrageous,” said Michael. Serena said she did not believe Beijing’s claims that the claim that law would only target “a tiny number of people”. The UK now wants to offer BNO passport holders citizenship rights after six years of stay, arguing that China has breached the Sino-British Joint Declaration by enacting the national security law, which violates the city’s high degree of autonomy and infringes the civil liberties of Hong Kong residents.Michael and Serena’s original plan was to only send their daughter to study abroad, but now moving to the UK as a family has become their first choice. Last November, they renewed their long-expired BNO passports, thinking that it could become useful - a hedge against an uncertain future.“I thought the UK would only offer citizenship to BNO passport holders as a last resort. I didn’t think it would happen so soon, but all of a sudden great changes are happening,” Michael said.In the week since China announced the new security law, the story of Michael and Serena has become more common. The people without BNO passports BNO passports were issued to people who registered before the former British colony was handed back to China Currently, there are about 350,000 BNO passport holders in Hong Kong, and the UK government estimates that there are about 2.9 million BNOs in total.Hong Kong residents born after the 1997 handover are not eligible for the BNO passport - and those who did not apply for one before the handover are not allowed to do so now.Helen was born in 1997 before the handover, but her parents did not apply for a BNO passport for her because she was a baby.“I am not sure if I want to go. But this is my right. Compared to the UK, I like Hong Kong more. But I should have had a BNO passport,” she said, admitting that she blamed her parents a little for not applying for one for her back then. About 350,000 Hong Kong residents are BNO passport holders as of February It is difficult to gauge the number of Hong Kong residents who will take up the UK's offer at this moment - but interest is running high, especially after the UK's announcement on July 1. On that day, Mr Raab told the House of Commons: \"We will not look the other way on Hong Kong, and we will not duck our historic responsibilities to its people.\" Ben Yu, who works for an immigration consultancy in the UK, said: \"My Hong Kong-based colleague receives 30 to 40 messages on Facebook every day. His WhatsApp has received hundreds of messages asking about moving to the UK by all routes, including BNOs and other visas. The messages come in 24/7 non-stop since then.\" The number of BNO renewals appears to be driven by political upheavals in Hong Kong. In 2018, about 170,000 BNO passports were in circulation. The next year, the number jumped to more than 310,000. During the colonial days, Hong Kong was always described as a borrowed place on borrowed time - and it is no stranger to waves of emigration. Between 1984 and 1997, between about 20,000 and 66,000 people left the city every year. The imminent wave of emigration will also likely look different to those in the past. \"A lot of them returned to Hong Kong either before 1997 or after 1997, when they had seized their safety outlets when they had got their foreign passports, when they saw that the political nightmare had not occurred as predicted,\" said Professor Ming Sing, who teaches politics at the Hong Kong University of Science and Technology. \"For the current wave, should it happen, I guess we will see a higher proportion of them is going to be a one-way ticket，\" he said. \"A lot of them see that the legislation of the national security law which has been imposed from the top is not only draconian in nature, but it also reflects Beijing reneging on its promise. Not only its failure to protect Hong Kong's freedoms under the Joint Declaration and under the Basic Law,\" he said, adding that he thinks more young people, many of them are protesters, will exit Hong Kong. ## What comes next? In the city of 7.5 million, about 800,000 people have British, Australian, Canadian, or American passports - including expats. Beijing has expressed anger over the UK's plan to offer citizenship to BNO passport holders in Hong Kong. China's Ambassador to the UK Liu Xiaoming said on Monday the move constitutes **\"gross interference in China's internal affairs\"** \"No one should underestimate the firm determination of China to safeguard its sovereignty, security and development interests,\" he said. The Chinese Embassy also said in a statement all \"Chinese compatriots residing in Hong Kong are Chinese nationals\". In an earlier interview with ITV, Mr Raab said there is little the UK could do if China doesn't allow Hong Kong residents to come to the UK. \"It is hard to predict what consequences Beijing has in mind. Probably more diplomatic ones in the form of a counter-measure, which does not necessarily need to be in the same form but should not be disproportionate,\" said Simon Young, a legal scholar at the University of Hong Kong. Benedict Rogers, co-founder and chair of advocacy group Hong Kong Watch, described the BNO offer as \"generous, courageous and welcome\". (video: Hong Kongers with British passports are divided over whether to leave the country) But the rescue element should be a last resort, Mr Rogers said. \"We should be working to ensure the conditions are met whereby HongKongers can continue their way of life, with the freedoms they were promised, without having to flee their homes. But the reality is that now, for some, it is already too late and they will need a place of sanctuary.\" Michael and Serena are making preparations for a new life in the UK, but they did not succeed at convincing their older son, who is turning 18 soon, to leave with them. He will live with his grandparents after the rest of the family has moved. \"My son says he doesn't want to leave Hong Kong, because he thinks Hong Kong belongs to him,\" Serena said. *Some names have been changed.* *----end---* 香港国安法：我们为何拿着英国护照离开自中国对香港实施了最严格的国安法以来，在这座充满抗议意识的城市，讨论退出香港的策略变成了市民晚宴聊天上的重要话题。对于至多三百万香港人来说，凭借英国国际护照离开或许是一种选择，但他们真的能离开吗？那些留下来的人又将面对什么呢？ Michael与Serena两人已决定离开香港定居英国，在那个从未涉足的国家度过余生。（leave …for good 意为：永久离开）这对夫妇拥有英国海外国民身份——或者说拥有BNO护照。在1997年中国政府收回香港前，英国将这种护照发予当时的香港居民。从本质上说，这（BNO）是一份具有领事协助权的旅行证件，其作用似乎仅限于更容易进入英国以及更方便欧洲旅行。 无论如何，有些人确实凭借它去了英国，为什么不借助它呢？许多香港人开始思考了。（这段俺翻译的很难受，仅供参考）迈克尔Michael和塞雷娜Serena是香港辉煌的体现：他们都是银行的中层管理人员，很多年前买了一处公寓，并带着一个13岁的女儿四处旅行。 离开香港，他们要放弃很多。他们说，香港在处理长达数月的抗议活动中已经变得面目全非。这场抗议活动源自于一向法律提案，该法案允许将香港居民引渡到中国大陆。 夫妇们看到的是一个不听人民意见的政府，而警察部队做事几乎没有克制。他们的女儿深受抗议活动的影响，尽管其他家庭成员没有参加。因为这对夫妇在一家中资银行工作，那里的一名员工因抗议而被解雇。“她一直非常生气和沮丧。她​​一直在问，当局为什么可以这样对待我们？”Serena说，她还补充说，他们的女儿已经告诉他们她想出国学习。上周生效的、备受争议的国家安全法是压死骆驼的最后一根稻草。“国家安全法的条款非常过分，”Michael说。 Serena说她没有相信大陆政府的说法，即法律只会针对“极少数人”。英国现在希望给予英国护照持有者在居留六年后的公民权利，解释称香港国安法违反了“中英联合声明”，破坏了城市的高度自治，侵犯了香港公民自由。Michael和Serena原本的计划是只送女儿出国学习，但现在一家人搬到英国已成为他们的首选。 去年11月，他们续签了长期过期的BNO护照，认为它对不确定性的未来可能会有用。“我原以为英国只会在万不得已的情况下向英国护照持有人提供公民身份。我没有预料到情况会变化得这么快。”Michael说。 那些没有英国公民护照的人（图片）（图片标题：BNO护照当时发给了英国在香港殖民时期的香港居民）目前，香港约有35万人持有BNO护照，而英国政府估计，BNO护照的总数约为290万。（看不太明白，不过中国统计的数据是：约300万香港人有BNO护照，而香港总人口约750万）在1997年移交后出生的香港居民没有资格获得BNO护照,那些在移交之前没有申请的人现在也不能再申请。海伦在香港主权移交前于1997年出生，但她的父母没有为她申请BNO护照，因为她还是婴儿。“我不确定我是否想去，但我有选择的权利。与英国相比，我更喜欢香港，但我本应该拥有BNO护照。”她说，并承认自己对父母当时没有为她申请有些指责。很难估计有多少香港居民会在这个时候接受英国的提议。但香港人的兴趣正在高涨，尤其是在英国7月1日宣布这一消息后。当天，Raab先生告诉下议院：“我们不会抛弃香港，我们不会逃避对人民的历史责任”。在英国一家移民咨询公司工作的Ben Yu说:“我的总部在香港，同事每天在Facebook上收到30到40条信息。他的WhatsApp已收到数百条消息询问有关通过所有路线（包括BNO和其他路线）前往英国的方式。 从那时起，他们的消息提醒几乎是每天24小时都在响。续签BNO的数量似乎是由香港的政治动荡推动的。 在2018年，市面上流通的英国国民(海外)护照约有17万本。 第二年，这一数字忽然猛增到超过31万本，在殖民地时代，香港总是被形容为：在借来的时间上的借来的地方。它对一波又一波的移民并不陌生。 在1984年到1997年之间，每年大约有两万到六万六千人离开这座城市。即将到来的移民潮也可能与过去不同。香港科技大学(Hong Kong University of Science and Technology)政治学教授明星(Ming Sing)说，“他们中的很多人在1997年之前或1997年之后回到了香港，当时他们拿到外国护照后，他们发现政治噩梦并没有如预期的那般发生，便关闭了预留的‘安全出口’。”。他表示: “就目前的浪潮而言，如果发生这种情况，更高比例的人将成为单程票。”。“他们中的很多人看到，由高层强加的《国家安全法》未能在《联合声明》和《基本法》下保护香港的自由，不仅性质严厉，而且反映了大陆政府背弃承诺。他还认为，更多的年轻人，其中许多是抗议者，将退出香港。 那么，接下来会发生什么？在这座拥有750万人口的城市，大约有80万人持有英国、澳大利亚、加拿大或美国护照-包括外籍人士。北京对英国向香港的BNO护照持有人提供公民身份的计划表示愤怒。 中国驻英国大使刘晓明周一表示，此举构成“对中国内政的严重干涉”。他说：“任何人都不应低估中国维护其主权，安全与发展利益的坚定决心。”中国大使馆还在一份声明中表示，“所有居住在香港的中国同胞都是中国公民”。拉伯在接受ITV采访时说，如果中国不允许香港居民来英国，英国将无能为力。 “很难预言北京将带来什么后果。 很可能采取的外交上的反击手段，不一定采取相同的形式，但也不应不相称。”香港大学法律学者西蒙·杨说。“香港观察”(Hong Kong Watch)的联合创始人兼主席本尼迪克特•罗杰斯(Benedict Rogers)形容 BNO 的提议是“慷慨、勇敢和欢迎的”。但罗杰斯表示，救援措施应该是最后的手段。“我们应该努力创造条件来使香港人能够继续他们的生活方式，享有承诺的自由，而不必逃离家园。但现实是，对一些人来说，现在已经太晚了，他们需要一个避难所。”迈克尔和塞雷纳正在为英国的新生活做准备，但他们未能说服即将年满18岁的大儿子与他们一起离开。 家庭其他成员搬迁后，他将与祖父母同住。瑟琳娜说：“我儿子说他不想离开香港，因为他认为香港属于他。” *文中所用部分名字为化名*","categories":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"BBC","slug":"英语新闻/BBC","permalink":"/categories/英语新闻/BBC/"}],"tags":[{"name":"英语新闻","slug":"英语新闻","permalink":"/tags/英语新闻/"}],"keywords":[{"name":"英语新闻","slug":"英语新闻","permalink":"/categories/英语新闻/"},{"name":"BBC","slug":"英语新闻/BBC","permalink":"/categories/英语新闻/BBC/"}]},{"title":"洛谷P4447 [AHOI2018初中组] 分组","slug":"洛谷P4447 [AHOI2018初中组]分组","date":"2020-07-12T11:11:00.000Z","updated":"2020-08-27T04:51:19.698Z","comments":true,"path":"2020/07/12/洛谷P4447 [AHOI2018初中组]分组/","link":"","permalink":"/2020/07/12/洛谷P4447 [AHOI2018初中组]分组/","excerpt":"题目描述：小可可的学校信息组总共有n 个队员，每个人都有一个实力值a[i]。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的n 个队员分成若干个小组去参加这场比赛。这是道类似玩斗地主的题","text":"题目描述：小可可的学校信息组总共有n 个队员，每个人都有一个实力值a[i]。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的n 个队员分成若干个小组去参加这场比赛。这是道类似玩斗地主的题 原题传送门-&gt;-&gt; 输入格式输入有两行： 第一行一个正整数n，表示队员数量。第二行有n 个整数，第i 个整数a[i]表示第i 个队员的实力。 输出格式输出一行，包括一个正整数，表示人数最少的组的人数最大值。 输入输出样例输入 #1 74 5 2 3 -4 -3 -5 输出 #1 3 说明/提示【样例解释】 分为2 组，一组的队员实力值是{4, 5, 2, 3},一组是{-4, -3, -5}其中最小的组人数为3，可以发现没有比3 更优的分法了。 【数据范围】对于100%的数据满足：1≤n≤10^5，∣a[i]∣≤ 10^9。 本题共10 个测试点，编号为1~10，每个测试点额外保证如下： 1~2 n≤6,1≤a[i]≤1003~4 n ≤ 10^3 ,1≤a[i]≤ 10^5, 且a[i]互不相同5~6 n≤ 10^5,a[i]互不相同 7~8 n≤ 10^5, 1≤a[i]≤10^59~10 n≤ 10^5,∣a[i]∣≤ 10^9 —————————————-分割线———————————————- 分析：大学生还在做初中组的题。。。好吧我一直知道自己是个菜鸡分组规则：要满足递增序列，并且还要保证最小组成员数最大————俺联想到打斗地主里面的连对。问题转化为：手里有一堆牌，怎样才能组成合适的连对？ 比如：五张牌：3、4、5、6、7,可以凑成连对，所以最基本的首先要找递增序列。但是找递增序列显然不能盲目，假如你手里牌是：3、4、5、6、7、7、8、9、10、J（J就是11）。怎么出牌比较好呢？答案应该是：3、4、5、6、7和7、8、9、10、J。这道题的贪心核心就在这里：当发现有相同的数字时，要在合适的地方拆解。再举个例子：3,4,5,6,7,7,8,8,9,9,10,J应该分成：3，4，5，6，7，8，9以及7，8，9，10，J其实就是在从n张到n-1张过渡的地方截取。 我是用map来存储的，第一个值为实力值，第二个值是频次。比如有3人实力为8，那么这个结点就是，当某个小组需要一名实力为8的成员，这个结点就变成， 直到降为后把这个结点删除。 #include&lt;map&gt; #include&lt;iostream&gt; using namespace std; map&lt;int,int&gt; Stu;//实力值，频次 void Input() { int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) { int a; cin &gt;&gt; a; pair&lt;map&lt;int,int&gt;::iterator,int&gt; flag = Stu.insert(pair&lt;int,int&gt;(a,1)); if(!flag.second) ++(flag.first-&gt;second); } } void solve() { int ans = (1 &lt;&lt; 30); while(!Stu.empty()) { int tmp = 1;//tmp记录小组长度 map&lt;int,int&gt;::iterator i = Stu.begin(); pair&lt;int,int&gt;pre = *i; --(i-&gt;second); if(!i-&gt;second) i = Stu.erase(i); else ++i; while(i != Stu.end()) { if(i-&gt;first != ( pre.first + 1)) break; if(i-&gt;second == (pre.second-1)) break; pre = *i; ++tmp; --(i-&gt;second); if(!i-&gt;second) i = Stu.erase(i); else ++i; } if(tmp &lt; ans) ans = tmp; } cout &lt;&lt; ans &lt;&lt; endl; } int main() { Input(); solve(); return 0; }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"题解","slug":"编程/题解","permalink":"/categories/编程/题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"/tags/题解/"},{"name":"贪心","slug":"贪心","permalink":"/tags/贪心/"},{"name":"map","slug":"map","permalink":"/tags/map/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"题解","slug":"编程/题解","permalink":"/categories/编程/题解/"}]},{"title":"洛谷P3879 [TJOI2010] 阅读理解","slug":"洛谷P3879 [TJOI2010] 阅读理解","date":"2020-07-09T15:18:00.000Z","updated":"2020-08-27T04:51:29.705Z","comments":true,"path":"2020/07/09/洛谷P3879 [TJOI2010] 阅读理解/","link":"","permalink":"/2020/07/09/洛谷P3879 [TJOI2010] 阅读理解/","excerpt":"题目描述：英语老师留了 N 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过","text":"题目描述：英语老师留了 N 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过 原题传送门-&gt;-&gt; 输入格式第一行为整数 N ，表示短文篇数，其中每篇短文只含空格和小写字母。 按下来的 N 行，每行描述一篇短文。每行的开头是一个整数 L ，表示这篇短文由 L 个单词组成。接下来是 L 个单词，单词之间用一个空格分隔。 然后为一个整数 M ，表示要做几次询问。后面有 M 行，每行表示一个要统计的生词。 输出格式对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。 输入输出样例输入 #1 3 9 you are a good boy ha ha o yeah 13 o my god you like bleach narutoone piece and so do i 11 but i do not think you will get all thepoints 5 you i o all naruto 输出 #1 1 2 3 2 3 1 2 3 2 说明/提示 对于 30% 的数据， 1 ≤ M ≤ $10^3$。 对于 100%100\\%100% 的数据，1 ≤ M ≤ $10^4$1 ≤ N ≤ $10^3$ 。 每篇短文长度（含相邻单词之间的空格）≤ $5×10^3$字符，每个单词长度 ≤ 20 字符。 每个测试点时限 2 秒。 —————————————-分割线———————————————- 第一反应是用桶排，如果能把单词表示成一个编码，直接用int数组就可以做了，但是显然，20个字母组成的单词编码的数据会很大。 但我可以想到可以退而求其次：对字母的前两个字母进行编码，编码相同的单词存储到同一个map&lt; string , list&gt;中,string记录单词，list记录单词在哪几个文章中出现。这样的由于前两个字母都一样的单词很少，查找几乎是线性时间就能结束。 建立一个这样的数组存储所有的单词。map","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"题解","slug":"编程/题解","permalink":"/categories/编程/题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"/tags/题解/"},{"name":"哈希排序","slug":"哈希排序","permalink":"/tags/哈希排序/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"题解","slug":"编程/题解","permalink":"/categories/编程/题解/"}]},{"title":"洛谷P1127 词链","slug":"洛谷 P1127 词链","date":"2020-07-09T07:40:24.000Z","updated":"2020-08-27T04:51:37.751Z","comments":true,"path":"2020/07/09/洛谷 P1127 词链/","link":"","permalink":"/2020/07/09/洛谷 P1127 词链/","excerpt":"题目描述：如果单词 X 的末字母与单词 Y 的首字母相同，则 X 与 Y 可以相连成 X.Y。（注意：X、Y 之间是英文的句号 .）。例如，单词 dog 与单词 gopher，则 dog 与 gopher 可以相连成 dog.gopher","text":"题目描述：如果单词 X 的末字母与单词 Y 的首字母相同，则 X 与 Y 可以相连成 X.Y。（注意：X、Y 之间是英文的句号 .）。例如，单词 dog 与单词 gopher，则 dog 与 gopher 可以相连成 dog.gopher 原题传送门-&gt;-&gt; 另外还有一些例子：• dog.gopher• gopher.rat• rat.tiger• aloha.aloha• arachnid.dog连接成的词可以与其他单词相连，组成更长的词链，例如：aloha.arachnid.dog.gopher.rat.tiger注意到，. 两边的字母一定是相同的。现在给你一些单词，请你找到字典序最小的词链，使得这些单词在词链中出现且仅出现一次。 输入格式：第一行是一个正整数 n（1≤n≤1000），代表单词数量。接下来共有 n 行，每行是一个由 1 到 20 个小写字母组成的单词。 输出格式：只有一行，表示组成字典序最小的词链，若不存在则只输出三个星号 *。 输入输出样例输入 #16alohaarachniddoggopherrattiger输出 #1aloha.arachnid.dog.gopher.rat.tiger 说明/提示• 对于 40% 的数据，有 n≤10；• 对于 100% 的数据， n≤1000。 分析：每个单词都有头字母和尾字母，不难发现，每条词链都有这样的特点：除第一个单词外，其余单词的头字母必然有一个尾字母与其对应。除最后一个单词外，其余单词的尾字母必然有一个头字母与其对应。显然是一个欧拉路问题。 问题转化为： 一张图中有26（即26个字母，允许有孤立点）个结点，n条有向路（即n个单词），寻找一条欧拉路，使得经过的词链最短。 解决前思考的几个小问题：问题1：是否有解？记录每个字母的入度和出度，按照欧拉路的判断方法就可以判断，但是要注意环的存在。 问题2：何时词链字典序最小？注意到”.”的ASCII码为46，小于所有字母的ASCII码，所以ab.ba&lt;ba.ab abcd.de &lt; abcdd.de 其实只要把字典序小的尽量排在前面就OK 问题3：如何快速找到某个点的后继边？最好建立一个索引集。在按字典序将所有字母排序之后，以某个字母为首字母的所有单词都在一个固定区间上 问题4：如何遍历？类似深度优先搜索，每次尽量选择字典序最小的边进行递归。 伪代码： /*伪代码：*/ int main() { Input();//输入数据 sort();//排序 SetPtr();//建立索引集 if(! IsEulerRoad()) //假如不是欧拉路（但由于环的存在，其实并非充分条件,后面还要判断） { cout &lt;&lt; “***” &lt;&lt; endl; return 0; } Travel(); //遍历，并记录答案 Output();//输出 return 0; } 完整AC代码： #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;algorithm&gt; #include&lt;list&gt; using namespace std; string words[1002];//记录所有单词 int mark[1001];//遍历时作标记 int num = 0;//边（即单词）的总数 int Ptr[28]; //索引集，记录words[] 中以26个字母为首字母的第一个单词下标 int Begin;//遍历起点 int ans[1002];//存储遍历路径 int flag = false;//标记是否遍历结束 void SetPtr(); //初始化Ptr void travel(int s,int depth); int InDegree[28];//26个字母的入度 int OutDegree[28];//26个字母的出度 bool IsEulerRoad(); int main() { cin &gt;&gt; num; for(int i = 0; i &lt; num; ++i) { cin &gt;&gt; words[i]; char apple = words[i][0]; char banana = words[i][words[i].size()-1]; ++OutDegree[apple - &#39;a&#39;]; ++InDegree[banana - &#39;a&#39;]; } sort(words,words+num);//按字典序排序 SetPtr(); if(!IsEulerRoad()) { cout &lt;&lt; &quot;***&quot; &lt;&lt; endl; return 0; } travel(Begin,1); if(!flag)//排除回路的干扰。比如输入数据为：2 a b。 { cout &lt;&lt; &quot;***&quot; &lt;&lt;endl; return 0; } cout &lt;&lt; words[ans[0]]; for(int i = 1; i &lt; num; ++i) { cout &lt;&lt; &quot;.&quot; &lt;&lt; words[ans[i]]; } cout &lt;&lt; endl; return 0; } void SetPtr() { int j = 0; for(int i = 0; i &lt; num; ++i) { int k = (char)(words[i][0]) - &#39;a&#39;; if(k &lt; j) continue; while(k &gt; j) { Ptr[j] = i; ++j; } Ptr[j] = i; ++j; } for(;j &lt; 27;++j ) Ptr[j] = num; return; } void travel(int s,int depth) { ans[depth - 1] = s; if(depth == num) { flag = true; return; } mark[s] = 1;//标记 int next = (words[s][words[s].size()-1])-&#39;a&#39;; int start = Ptr[next]; int end = Ptr[next+1];//索引集派上用场 for(int itr = start; itr &lt; end; ++itr)//遍历所有边 { if(!mark[itr]) { travel(itr,depth+1); mark[itr] = 0; if(flag) return;//防止继续循环覆盖掉正确答案 } } } bool IsEulerRoad() { int Count = 0; int In = 0, Out = 0; for(int i = 0; i &lt; 26; ++i) { if(OutDegree[i] != InDegree[i]) { ++Count; if(OutDegree[i] &gt; InDegree[i]) { Out = OutDegree[i] - InDegree[i]; Begin = Ptr[i];//出度大的点应该为起点。假如这句没有执行，说明这张图可能是欧拉图，Begin=0也是正确的; } else { In = InDegree[i] - OutDegree[i]; } } } if(!Count) return true; if(Count != 2) return false; return ((Out == 1)&amp;&amp;(In == 1)); }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"题解","slug":"编程/题解","permalink":"/categories/编程/题解/"}],"tags":[{"name":"欧拉路","slug":"欧拉路","permalink":"/tags/欧拉路/"},{"name":"离散数学","slug":"离散数学","permalink":"/tags/离散数学/"},{"name":"题解","slug":"题解","permalink":"/tags/题解/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"题解","slug":"编程/题解","permalink":"/categories/编程/题解/"}]},{"title":"第二类Stirling数","slug":"第二类斯特林数","date":"2020-07-09T07:40:24.000Z","updated":"2020-08-27T04:53:38.163Z","comments":true,"path":"2020/07/09/第二类斯特林数/","link":"","permalink":"/2020/07/09/第二类斯特林数/","excerpt":"第二类Stirling数实际上是集合的一个拆分，表示将n个不同的元素拆分成m个集合的方案数，","text":"第二类Stirling数实际上是集合的一个拆分，表示将n个不同的元素拆分成m个集合的方案数，本文将其记为S(n,m)={n\\brace m} 求解S(n,m)的问题可以等价为解决以下问题：将n个不同的球放入m个无差别的盒子中，要求盒子非空，有几种方案？ 容易得到以下式子：1、{n \\brace 0}=02、{n \\brace 1}=13、{n \\brace n} = 14、{n \\brace 2}= 2^{n-1} - 15、{n \\brace n-1}= C _n^2 这五个式子不足以求解，还需要下面的递推公式：{n\\brace r} = r {n-1 \\brace r} + {n-1\\brace r-1} 如何理解这个公式呢？ 1、我们先将n个球随机标记为1、2、3…n。 2、先将前n-1个球放入r个盒子。放置完成后有两种情况：①每个盒子都有球{n-1\\brace r}②只有一个盒子没有球。{n-1\\brace r-1} 3、再放第n个球①每个盒子已经有球了，由于每个球都是不同的，这r个盒子每个都是独一无二的，所以需要乘以rr {n-1 \\brace r} ②有一个空盒，那么第n个球只能放在这个空盒里 ，不需要再作运算{n-1\\brace r-1}因此得出最后结果{n\\brace r} = r {n-1 \\brace r} + {n-1\\brace r-1}我觉得需要注意的点是：第n个球是随机得来的，没有任何特殊性，所以取球的过程是不需要运算的。 C语言实现： long long Stirling2(int n,int m) { if(n &lt; m) return 0; if(!m) return 0; if(m == 1) return 1; if(m == n) return 1; if(m == 2) return (1 &lt;&lt; (n - 1)) - 1; if(n == m + 1) return n * m / 2; return m * (Stirling2(n - 1,m)) + Stirling2(n - 1,m - 1); }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"集合论","slug":"编程/集合论","permalink":"/categories/编程/集合论/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"/tags/离散数学/"},{"name":"集合论","slug":"集合论","permalink":"/tags/集合论/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"},{"name":"集合论","slug":"编程/集合论","permalink":"/categories/编程/集合论/"}]}]}