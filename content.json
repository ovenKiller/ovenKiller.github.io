{"meta":{"title":"DayDream","subtitle":null,"description":null,"author":"断梦三生","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-08-26T14:44:03.238Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"聊会儿天？ 对话中... bot_ui_ini()","keywords":"关于"},{"title":"categories","date":"2021-02-07T02:46:00.000Z","updated":"2021-02-07T02:46:28.172Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":"","keywords":null},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-02-08T14:37:00.554Z","comments":false,"path":"book/index.html","permalink":"/book/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-09-26T02:45:19.287Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"2019——2020 最近常听~ 2018 2016——2017 2013——2015 Sun Cloud 一事无成 永恒废青 Rain Storm","keywords":"音乐盒"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-09-26T02:39:47.021Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"修改自Sakura主题hexo提供博客渲染支持","keywords":"Hexo 主题 Sakura 🌸"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-08-28T03:15:50.367Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"tags","date":"2021-02-07T02:03:12.000Z","updated":"2021-02-07T02:03:54.766Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":"","keywords":null},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"数据库笔记（七）SQL的查询操作","slug":"databaseNote-7","date":"2021-02-07T12:07:00.000Z","updated":"2021-02-08T02:09:11.331Z","comments":true,"path":"2021/02/07/databaseNote-7/","link":"","permalink":"/2021/02/07/databaseNote-7/","excerpt":"","text":"先建立完整的表： create database SCT1 use SCT1 create table Student (S# char(8), Sname char(10), Ssex char(2), Sage integer, D# char(2),Sclass char(6)) insert into Student values (&#39;98030101&#39;,&#39;张三&#39;,&#39;男&#39;,20,&#39;03&#39;,&#39;980301&#39;) insert into Student values (&#39;98030102&#39;,&#39;张四&#39;,&#39;女&#39;,20,&#39;03&#39;,&#39;980301&#39;) insert into Student values (&#39;98030103&#39;,&#39;张五&#39;,&#39;男&#39;,19,&#39;03&#39;,&#39;980301&#39;) insert into Student values (&#39;98040203&#39;,&#39;王三&#39;,&#39;男&#39;,20,&#39;04&#39;,&#39;980402&#39;) insert into Student values (&#39;98040203&#39;,&#39;王四&#39;,&#39;男&#39;,21,&#39;04&#39;,&#39;980402&#39;) insert into Student values (&#39;98040203&#39;,&#39;王五&#39;,&#39;女&#39;,19,&#39;04&#39;,&#39;980402&#39;) select * from Student Student表: create table Dept(D# char(2),Dname char(10),Dean char(10)) create table Dept(D# char(2),Dname char(10),Dean char(10)) insert into Dept values (&#39;01&#39;,&#39;机电&#39;,&#39;李三&#39;) insert into Dept values (&#39;02&#39;,&#39;能源&#39;,&#39;李四&#39;) insert into Dept values (&#39;03&#39;,&#39;计算机&#39;,&#39;李五&#39;) insert into Dept values (&#39;04&#39;,&#39;自动控制&#39;,&#39;李六&#39;) select * from Dept Dept表（专业） insert into Teacher values(&#39;001&#39;,&#39;赵三&#39;,&#39;01&#39;,1200.0) insert into Teacher values(&#39;002&#39;,&#39;赵四&#39;,&#39;03&#39;,1400.0) insert into Teacher values(&#39;003&#39;,&#39;赵五&#39;,&#39;03&#39;,1000.0) insert into Teacher values(&#39;004&#39;,&#39;赵六&#39;,&#39;04&#39;,1100.0) select * from Teacher Course表(课程) create table Course ( C# char(3), Cname char(12), Chours integer, Credit float(1), T# char(3) ) insert into Course values (&#39;001&#39;,&#39;数据库&#39;,40,6,&#39;001&#39;) insert into Course values (&#39;003&#39;,&#39;数据结构&#39;,40,6,&#39;003&#39;) insert into Course values (&#39;004&#39;,&#39;编译原理&#39;,40,6,&#39;001&#39;) insert into Course values (&#39;005&#39;,&#39;C语言&#39;,30,4.5,&#39;003&#39;) insert into Course values (&#39;002&#39;,&#39;高等数学&#39;,80,12,&#39;004&#39;) select * from Course SC表(选课) create table SC ( S# char(8), C# char(3), Score float(1) ) insert into SC values(&#39;98030101&#39;,&#39;001&#39;,92) insert into SC values(&#39;98030101&#39;,&#39;002&#39;,85) insert into SC values(&#39;98030101&#39;,&#39;003&#39;,88) insert into SC values(&#39;98040202&#39;,&#39;002&#39;,90) insert into SC values(&#39;98040202&#39;,&#39;003&#39;,80) insert into SC values(&#39;98040202&#39;,&#39;001&#39;,55) insert into SC values(&#39;98040203&#39;,&#39;003&#39;,56) insert into SC values(&#39;98030102&#39;,&#39;001&#39;,54) insert into SC values(&#39;98030102&#39;,&#39;002&#39;,85) insert into SC values(&#39;98030102&#39;,&#39;003&#39;,48) select * from SC 一、普通查询查询’张三’和’张四’ select * from Student where Sname = &#39;张三&#39; or Sname =&#39;张四&#39; 二、in 子查询1、什么时候需要子查询？ 集合成员资格 某一元素是否是某一个集合的成员 集合之间的比较 某一个集合是否包含另一个集合等 集合基数的测试 测试集合是否为空 测试集合是否存在重复元组 和python中的in很类似。 2、基础版select * from Student where Sname in(&#39;张三&#39;,&#39;张四&#39;) 3、嵌套查询in中的内容也可以是查询得来的：如：列出选修了001号课程的学生的学号和姓名 select Sname S# from Student where S# in(select S# from SC where C# = &#39;001&#39;) 谓词查询:列出没学过赵四老师讲授课程的所有同学的姓名? 可以一步步筛选出赵四老师的所有学生:1、从Teacher表中找到赵四老师的教师编号 T#2、根据T# 在SC表中找到所有学生的学号S# 也可以采用谓词逻辑: Select SnameFrom Student WhereS# not in( Select S# From SC, Course C, Teacher TWhereT.Tname = &#39;赵四&#39; and SC.C# = C.C# and T.T# = C.T# )","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"leetcode 279 完全平方数","slug":"leetcode279","date":"2021-02-07T05:40:24.000Z","updated":"2021-02-08T04:45:15.191Z","comments":true,"path":"2021/02/07/leetcode279/","link":"","permalink":"/2021/02/07/leetcode279/","excerpt":"","text":"给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 给你一个整数 n ，返回和为 n 的完全平方数的最少数量 。 完全平方数是一个整数其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而3和 11 不是。 示例 1： 输入：n = 12输出：3解释：12 = 4 + 4 + 4示例 2： 输入：n = 13输出：2解释：13 = 4 + 9 提示： 1 &lt;= n &lt;= 104 思路1：dfs嗯显然我除了深搜就啥也不会了 class Solution: def __init__(self): self.nums = [] self.ans = 10000 def numSquares(self, n: int) -&gt; int: self.nums = [i*i for i in range(100,0,-1)] self.dfs(n,0,0) return self.ans def dfs(self,remain,step,itr_start):#剪枝1 if step &gt;= self.ans: #剪枝2 return if remain == 0: self.ans = step return for i in range(itr_start,len(self.nums)): if self.nums[i] &lt;= remain: self.dfs(remain-self.nums[i],step+1,i) 不过这个深搜不算特别无脑，还是有两处剪枝的。(数据量这么大用脚想也知道直接dfs会超时) 第一处剪枝:保留上一次访问的下标。因为在这个下标之前的一定已经深搜过一遍了。第二处剪枝:当step已经大于ans，就肯定更新不了ans的值了，所以直接return 用时大概在前44%，其实效果还不错 思路2：dp比较简单的dp，我以为会超时，但其实还好。 class Solution: def __init__(self): self.squre_nums = [] self.dp = [] def numSquares(self, n: int) -&gt; int: self.squre_nums = [i*i for i in range(1,101)] self.dp = [i for i in range(n+1)] for i in range(n+1): for squre_num in self.squre_nums: if squre_num &gt; i: break self.dp[i] = self.dp[i] if (self.dp[i] &lt; (self.dp[i-squre_num]+1)) else (self.dp[i-squre_num]+1) return self.dp[n] 初始值:dp[i] = i:即仅使用1相加的情况。转移方程：dp[i] = min(dp[i], dp[i-squre_num]+1)注意这里的squre_num是完全平方数，需要遍历100个数才能确定用时在前70%","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"/tags/动态规划/"},{"name":"DFS","slug":"DFS","permalink":"/tags/DFS/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"pytorch(4)： Tensor的线性代数运算/ 实践","slug":"pytorch-note-4","date":"2021-02-07T02:10:00.000Z","updated":"2021-02-08T13:38:35.301Z","comments":true,"path":"2021/02/07/pytorch-note-4/","link":"","permalink":"/2021/02/07/pytorch-note-4/","excerpt":"","text":"测试环境版本: torch1.7.1 + CPUpython 3.6 一、线性代数import torch as t a = t.arange(0,9).view(3,3) b = t.arange(0,12).view(3,4) 求矩阵的迹(主对角线元素之和) print(a) a.trace() tensor([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) tensor(12) print(b) b.trace() tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) tensor(15) 非方阵也可以求迹！取主对角线元素 b.diag() tensor([ 0, 5, 10]) 包含了矩阵的所有常用操作,使用时再百度吧。 注意矩阵存储的连续性问题:当取转置后，矩阵的存储就不再连续。 b = b.t() b tensor([[ 0, 4, 8], [ 1, 5, 9], [ 2, 6, 10], [ 3, 7, 11]]) 当矩阵的存储不再连续之后，某些函数就不能正常使用，比如view方法。下面注释掉的代码会报错需要使用contiguous()方法使矩阵连续存储 # b.view(3,4) b.contiguous().view(3,4) tensor([[ 0, 4, 8, 1], [ 5, 9, 2, 6], [10, 3, 7, 11]]) 二、Tensor与Numpytensor与numpy的转化共享内存，简单高效。两者可以相互转化来灵活使用 import numpy as np a = np.ones([2,3],dtype=np.float32) a array([[1., 1., 1.], [1., 1., 1.]], dtype=float32) b = t.from_numpy(a) b tensor([[1., 1., 1.], [1., 1., 1.]]) 也可以用b = t.Tensor(a)创建，但假如a不是float32型，b会新建一个张量。 tip:尽量避免for循环，而是要采用内建的函数。 这些内建函数算法很高效 很多函数底层是用C++写的，速度远高于python 三、实践：线性回归我们要求的方程形式为: y=wx+b+e其中e为正态分布的误差。损失函数采用均方误差 import torch as t %matplotlib inline from matplotlib import pyplot as plt from IPython import display t.manual_seed(1000)# 设置随机数种子，保证代码在不同计算机上运行结果相同 def get_data(batch_size=8): x = t.rand(batch_size,1)*20 y = x * 2 + (1 + t.randn(batch_size,1)) * 3 return x , y # 模拟的是y = 2x + 3,只是增加了噪声 x,y = get_data() plt.scatter(x.squeeze().numpy(),y.squeeze().numpy()) &lt;matplotlib.collections.PathCollection at 0x151ef632908&gt; #初始化权重参数 w = t.rand(1,1) b = t.zeros(1,1) lr = 0.001 # 学习率 for i in range(20000): x,y = get_data() # 前向传播 y_pred = x.mm(w) + b.expand_as(y) # tensor.mm是矩阵乘法 loss = 0.5 * ((y_pred - y) ** 2) # 均方误差，loss是一个1*8的矩阵 loss = loss.sum() dy_pred = y_pred - y # 这里是不严谨地求梯度 dw = x.t().mm(dy_pred) db = dy_pred.sum() # 更新参数 w.sub_(lr*dw) b.sub_(lr*db) print(w) print(b) tensor([[2.0513]]) tensor([[3.0743]]) 拟合效果比较好！","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"pytorch","slug":"pytorch","permalink":"/tags/pytorch/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"leetcode 518 零钱兑换","slug":"leetcode518","date":"2021-02-06T03:40:24.000Z","updated":"2021-02-08T04:45:23.743Z","comments":true,"path":"2021/02/06/leetcode518/","link":"","permalink":"/2021/02/06/leetcode518/","excerpt":"","text":"原题传送门 -&gt;518. 零钱兑换 II 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1: 输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1示例 2: 输入: amount = 3, coins = [2]输出: 0解释: 只用面额2的硬币不能凑成总金额3。示例 3: 输入: amount = 10, coins = [10]输出: 1 注意: 你可以假设： 0 &lt;= amount (总金额) &lt;= 50001 &lt;= coin (硬币面额) &lt;= 5000硬币种类不超过 500 种结果符合 32 位符号整数 第一想法无脑dfs: class Solution: def __init__(self): self.counter = 0 def change(self, amount: int, coins: List[int]) -&gt; int: coins.sort() coins.reverse() self.dfs(amount,coins,0) return self.counter def dfs(self,amount,coins,step): if amount == 0: self.counter += 1 return if step == len(coins): return k = amount // coins[step] amount_tmp = amount for i in range(k,-1,-1): self.dfs(amount_tmp - i*coins[step],coins,step+1) return 不过写这个代码的时候遇到的问题也挺多，脑子确实不太好用。 但是直接TLE了，一看题解，嚯，这也能动归？ 自己按照题解思路写了代码： class Solution: def __init__(self): self.path = [] def change(self, amount: int, coins: List[int]) -&gt; int: self.path = [0 for i in range(amount+1)] self.path[0] = 1 for step in coins: for i in range(1,amount+1): if i &gt;= step: self.path[i] += self.path[i-step] return self.path[amount] 原来无论是排列问题还是组合问题，都可以用动归实现，无非是内外循环的嵌套顺序不一样。 下面是我参照的写得很棒的题解：零钱兑换II和爬楼梯问题到底有什么不同？","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"/tags/动态规划/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"pytorch(3)： Tensor的元素访问/常用方法","slug":"pytorch-note-3","date":"2021-02-06T02:10:00.000Z","updated":"2021-02-08T13:38:39.223Z","comments":true,"path":"2021/02/06/pytorch-note-3/","link":"","permalink":"/2021/02/06/pytorch-note-3/","excerpt":"","text":"测试环境版本: torch1.7.1 + CPUpython 3.6 import torch as t a = t.randn(3,4) a tensor([[-1.0903, -0.1344, -0.5718, 1.2680], [ 0.5682, -0.1281, 0.5143, -0.7280], [-1.5264, 0.2746, 0.4163, -1.2645]]) 一、Tensor的访问与索引1、整行/整列的访问a[1] # 第1行 tensor([ 0.5682, -0.1281, 0.5143, -0.7280]) a[:2] # 前两行 tensor([[-1.0903, -0.1344, -0.5718, 1.2680], [ 0.5682, -0.1281, 0.5143, -0.7280]]) a[:,0]# 第0列 tensor([-1.0903, 0.5682, -1.5264]) a[:,-1]# 最后一列 tensor([ 1.2680, -0.7280, -1.2645]) a[1:3,0:2]#1、2行，0、1列 tensor([[ 0.5682, -0.1281], [-1.5264, 0.2746]]) 特别注意下面这两行：两者是有区别的前者会保持在矩阵中的形状后者会处理成一维数据 print(a[0:1,:2]) print(a[0,:2]) tensor([[-1.0903, -0.1344]]) tensor([-1.0903, -0.1344]) 2、条件筛选如：筛选出大于1的数据 a&gt;1 # 返回一个byteTensor（布尔型数组） tensor([[False, False, False, True], [False, False, False, False], [False, False, False, False]]) a[a&gt;1] # 筛选出大于1的数据 tensor([1.2680]) a.masked_select(a &gt; 1) # 与前面的写法等效 tensor([1.2680]) 选择结果与原tensor不共享内存 3、gather/scatter_比较复杂：我比较浅显的理解是：将input矩阵利用index矩阵映射到output矩阵上 &#39;out[i][j] = input[index[i][j]][j] dim=0,此时index[i][j]充当行下标&#39; &#39;out[i][j] = input[i][index[i][j]] dim=1，此时index[i][j]充当列下标&#39; a = t.arange(0,16).view(4,4) a tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1)取对角线上的元素# index = t.Tensor([[0,1,2,3]])报错，index必须是长整型(int64) index = t.LongTensor([[0,1,2,3]]) a.gather(0,index) tensor([[ 0, 5, 10, 15]]) 2)取反对角线上的元素index = t.LongTensor([[3,2,1,0]]) a.gather(0,index) tensor([[12, 9, 6, 3]]) 这是一个错误例子: index = index.t() a.gather(0,index) tensor([[12], [ 8], [ 4], [ 0]]) a.gather(1,index) tensor([[ 3], [ 6], [ 9], [12]]) scatter_这是gather的逆操作，不再介绍 4、高级索引：和numpy类似高级索引的结果一般不和原张量共享内存 a = t.arange(0,27).view(3,3,3) a tensor([[[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8]], [[ 9, 10, 11], [12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23], [24, 25, 26]]]) a[[0,1],[1,2],[1,2]]# a[0][1][1]和a[1][2][2] tensor([ 4, 17]) a[[0,1,2],[1],[1]]# a[0][1][1],a[1][1][1],a[2][1][1] tensor([ 4, 13, 22]) a[[0,2],...] # 居然还能用省略号...miao~ tensor([[[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8]], [[18, 19, 20], [21, 22, 23], [24, 25, 26]]]) a[[1],[1],...] tensor([[12, 13, 14]]) 二、 数据类型 三、逐元素操作绝大多数数学运算都有对应的方法，这里不一一列举，使用的时候直接百度吧。 a = a[0] a tensor([[[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8]], [[ 9, 10, 11], [12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23], [24, 25, 26]]]) 1、举例：#t.cos(a) 这句报错,原因是长整形不能进行cos运算 a.type() torch.Tensor t.cos(a.float()) tensor([[[ 1.0000, 0.5403, -0.4161], [-0.9900, -0.6536, 0.2837], [ 0.9602, 0.7539, -0.1455]], [[-0.9111, -0.8391, 0.0044], [ 0.8439, 0.9074, 0.1367], [-0.7597, -0.9577, -0.2752]], [[ 0.6603, 0.9887, 0.4081], [-0.5477, -1.0000, -0.5328], [ 0.4242, 0.9912, 0.6469]]]) a**2 #等价于t.pow(a,2) tensor([[[ 0, 1, 4], [ 9, 16, 25], [ 36, 49, 64]], [[ 81, 100, 121], [144, 169, 196], [225, 256, 289]], [[324, 361, 400], [441, 484, 529], [576, 625, 676]]]) a % 3 # 等价于a.fmod(a,3) tensor([[[0, 1, 2], [0, 1, 2], [0, 1, 2]], [[0, 1, 2], [0, 1, 2], [0, 1, 2]], [[0, 1, 2], [0, 1, 2], [0, 1, 2]]]) 2) clamp 数据截断clamp(x,min,max)的取值如下： f(x)=\\left\\{ \\begin{aligned} min & ,& if x_i max \\end{aligned} \\right.t.clamp(a,5,10) tensor([[[ 5, 5, 5], [ 5, 5, 5], [ 6, 7, 8]], [[ 9, 10, 10], [10, 10, 10], [10, 10, 10]], [[10, 10, 10], [10, 10, 10], [10, 10, 10]]]) t.clamp(a,min=10) tensor([[[10, 10, 10], [10, 10, 10], [10, 10, 10]], [[10, 10, 11], [12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23], [24, 25, 26]]]) t.clamp(a,max=10) tensor([[[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8]], [[ 9, 10, 10], [10, 10, 10], [10, 10, 10]], [[10, 10, 10], [10, 10, 10], [10, 10, 10]]]) 四、归并操作此类操作使输出形状小于输入。一般是在某一维度上执行求和、求均值等操作。 a = t.arange(0,24).view(2,3,4) a tensor([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) a.sum(dim=0) tensor([[12, 14, 16, 18], [20, 22, 24, 26], [28, 30, 32, 34]]) 1)dim介绍：一般该类方法均有一个dim参数（对应numpy的axis参数）从空间坐标轴上考虑，归并就像是投影操作假设输入为(x,y,z) dim=0 则输出为(1,y,z)或(y,z) dim=1 则输出为(x,1,z) dim=2 则输出为(x,y,1)2）其他的几个常用方法在某一维度上累加： a = t.ones(3,3,3) print(a) print(a.cummax(dim=1)) tensor([[[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], [[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], [[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]]) torch.return_types.cummax( values=tensor([[[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], [[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], [[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]]), indices=tensor([[[0, 0, 0], [1, 1, 1], [2, 2, 2]], [[0, 0, 0], [1, 1, 1], [2, 2, 2]], [[0, 0, 0], [1, 1, 1], [2, 2, 2]]])) 求标准差： a = t.randn(2,2,2) print(a) print(a.std()) print(a.std(dim=0)) tensor([[[-0.4520, 0.1512], [-0.3901, -1.9218]], [[ 0.9360, 1.1693], [ 1.4220, 0.0201]]]) tensor(1.0842) tensor([[0.9814, 0.7199], [1.2813, 1.3731]]) 可以看出，torch.randn生成的并不是严格的正态分布，仅仅是接近1","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"pytorch","slug":"pytorch","permalink":"/tags/pytorch/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"数据库笔记（六）SQL语言概览","slug":"databaseNote-6","date":"2021-02-05T03:40:24.000Z","updated":"2021-02-08T02:09:10.786Z","comments":true,"path":"2021/02/05/databaseNote-6/","link":"","permalink":"/2021/02/05/databaseNote-6/","excerpt":"","text":"简介SQL语言是集DDL(数据定义语言)、DML(数据操纵语言)和DCL(数据控制语言)于一体的数据库语言SQL语言是集DDL、DML和DCL于一体的数据库语言 有9个引导词： DDL语句引导词：Create(建立),Alter(修改),Drop(撤消) DML语句引导词：Insert(插入),Delete(删除), Update(更新), Select(选择) DCL语句引导词：Grant(授权),Revoke(取消授权) 建立数据库1）建立一个学生选课数据库(SCT)这个数据库由很多表组成：学生：学号S#, 姓名Sname, 性别Ssex, 年龄Sage, 所属系别D#，班级SclassStudent ( S# char(8), Sname char(10), Ssex char(2),Sage integer, D# char(2), Sclass char(6) ) 院系：系别D#，系名Dname, 系主任DeanDept ( D# char(2), Dname char(10), Dean char(10) ) 课程：课号C#, 课名Cname, 教师编号T#, 学时Chours，学分CreditCourse ( C# char(3), Cname char(12), Chours integer,Credit float(1), T# char(3) )教师：教师编号T#，教师名Tname, 所属院系D#，工资SalaryTeacher ( T# char(3), Tname char(10), D# char(2),Salary float(2) )选课：学号S#, 课号C#, 成绩ScoreSC ( S# char(8), C# char(3), Score float(1) ) 建立数据库包括两件事： 定义数据库和表（使用DDL） 向表中追加元组（使用DML） 创建database语法：create database database 数据库名;如：create database database SCT; 创建Table语法：Create table 表名( 列名 数据类型 [Primary key Primary key |Unique |Unique] [Not null][, 列名 数据类型 [Not null] , … ]) ; “ [ ] ”表示其括起的内容可以省略，“ | ” 表示其隔开的两项可取其一 Primary key: 主键约束。每个表只能创建一个主键约束。 Unique: 唯一性约束(即候选键)。可以有多个唯一性约束。 Not null: 非空约束。是指该列允许不允许有空值出现，如选择了Not null表明该列不允许有空值出现。 语法中的数据类型在SQL标准中有定义 SQL-92标准中定义的数据类型 char (n) :固定长度的字符串 varchar (n) :可变长字符串 int :整数 // 有时不同系统也写作integer numeric (p，q) :固定精度数字，小数点左边p位，右边p-q位 real :浮点精度数字 //有时不同系统也写作float(n)，小数点后保留n位 date :日期 (如 2003-09-12) time : 时间 (如 23:15:003) 例:定义学生表 StudentCreate Table Student ( S# char(8) not null , Sname char(10),Ssex char(2), Sage integer, D# char(2), Sclass char(6) ); 向表中增加元组使用insert操作 语法：insert into insert into 表名[ (列名 [, 列名 ]… ]values values (值 [, 值] , …) ; 如： Insert Into Student Values ( ‘98030101’ , ‘张三’, ‘男’, 20， ’03’， ‘980301’); Insert Into Student ( S#, Sname, Ssex, Sage, D# , Sclass) Values ( ‘98030102’ , ‘张四’, ‘女’, 20， ’03’， ‘980301’); 简单查询操作单表查询用到select语法：Select Select 列名 [[, 列名] … ]From 表名[ Where Where 检索条件 ] ; 示例：检索学生表中所有年龄小于等于19岁的学生的年龄及姓名 Select Sage, Sname //投影的列可以重新排定顺序 From Student Where Sage &lt;= 19; 去重问题关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组，但也允许无重复元组。在Table中要求无重复元组是通过定义Primary key或Unique来保证的;而在检索结果中要求无重复元组, 是通过DISTINCT保留字的使用来实现的。 示例：在选课表中，检索成绩大于80分的所有学号 Select S# From SC Where Score &gt; 80 ; //有重复元组出现，比如一个同学两门以上课程大于80 Select DISTINCT S# From SC Where Score &gt; 80; //重复元组被DISTINCT过滤掉，只保留一份 结果排序 Order By仅需在前面的语法最后加上:order by order by 列名 [asc | desc] 意义为检索结果按指定列名进行排序，若后跟asc或省略，则为升序；若后跟desc, 则为降序。示例：检索002号课大于80分的所有同学学号并按成绩由高到低顺序显示 Select S# From SC Where C# = ‘002’ and Score &gt; 80 Order By Score DESC ; 模糊语言 Like示例：检索名字不姓张的所有同学姓名 Select Sname From Student Where Sname Not Like ‘张%’; 多表联合查询基本操作：Select Select 列名 [ [, 列名] … ] From 表名1, 表名2, … Where Where 检索条件 ; 注意：检索条件需要包含连接条件（多个表需要连接在一起） 示例：按“001”号课成绩由高到低顺序显示所有学生的姓名(二表连接) Select Sname From Student, SC Where Student.S# = SC.S# and SC.C# = ‘001’ Order By Score DESC; 多表连接时，如两个表的属性名相同，则需采用表名. 属性名方式来限定该属性是属于哪一个表 重命名处理连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名(同一表的连接)等，因此需要使用别名以便区分 select中采用别名的方式 Select Select 列名 as 列别名 [ [, 列名 as 列别名] … ] From 表名1 as 表别名1, 表名2 as 表别名2, … Where Where 检索条件 ; 上述定义中的as 可以省略 当定义了别名后，在检索条件中可以使用别名来限定属性 不等值连接示例：求有薪水差额的任意两位教师 Select T1.Tname as Teacher1, T2.Tname as Teacher2 From Teacher T1, Teacher T2 Where T1.Salary &gt; T2.Salary ; 示例：求年龄有差异的任意两位同学的姓名 Select S1.Sname as Stud1, S2.Sname as Stud2 From Student S1, Student S2 Where S1.Sage &gt; S2.Sage ; SQL的增、删、改操作Insert元组新增Insert命令有两种形式 1、单一元组新增命令形式：插入一条指定元组值的元组insert into 表名 [(列名[，列名]…)]values (值 [，值]…)； 例： Insert Into Teacher (T#, Tname, D#, Salary) Values (“005”, “阮小七”, “03”, “1250”); 2、批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元组由子查询给出。insert into 表名 [(列名[，列名]…)]子查询; 例： Insert Into St (S#, Sname) Select S#, Sname From Student Where Sname like ‘%伟 ’ ; 查询后插入到新表中可以将中间结果存储成表示例：新建Table: St(S#, Sname, avgScore), 将检索到的同学的平均成绩新增到该表中 Insert Into St (S#, Sname, avgScore) //St是新建表的操作 Select S#, Sname, Avg(Score) From Student, SC Where Student.S# = SC.S# Group by Student.S# ; 条件控制的删除示例：删除有四门不及格课程的所有同学 Delete From Student Where S# in ( Select S# From SC Where Score &lt; 60 Group by S# Having Count(*)&gt;= 4 ); Updata1)基础用法元组的指定列的值 Update 表名 Set 列名 = 表达式 | (子查询) [ [ , 列名 = 表达式 | (子查询) ] … ] [ Where 条件表达式] ; 如果Where条件省略，则更新所有的元组。示例：将所有教师工资上调5% Update Teacher Set Salary = Salary * 1.05 ; 示例：将所有计算机系的教师工资上调10% Update Teacher Set Salary = Salary * 1.1 Where D# in ( Select D# From Dept Where Dname = ‘计算机’); 示例：将张三同学001号课的成绩置为其班级该门课的平均成绩 Update SC Set Score = ( Select AVG(SC2.Score) From SC SC1, Student S1, SC SC2, Student S2 Where S1.Sclass = S2.Sclass and SC1.S# = S1.S# and SC2.S# = S2.S# and S1.Sname=‘张三’ and SC1.C# = ‘001’ and SC1.C# = SC2.C# ) Where C# = ‘001’ and S# in ( Select S# From Student Where Sname = ‘张三’ ) ; 撤销与修正修正数据库的定义修正基本表的定义 alter table tablename [add {colname datatype, …}] 增加新列 [drop {完整性约束名}] 删除完整性约束 [modify {colname datatype, …}] 修改列定义 drop撤消基本表drop table 表名 撤消数据库drop database 数据库名 指定与关闭数据库指定当前数据库use 数据库名; 关闭当前数据库close 数据库名; 实操训练：以SQL server为例 SQl server 的系统数据库：Master ：是SQL Server中最重要的系统数据库，存储SQL Server中的元数据。Model：模板数据库，在创建新的数据库时，SQL Server将会复制此数据库作为新数据库的基础。Msdb：代理服务数据库，提供一个存储空间。Tempdb：临时数据库，为所有的临时表、临时存储过程及其他临时操作提供存储空间，断开连接时，临时表与存储过程自动被删除。 创建/删除数据库CREATE DATABASE SCT DROP DATABASE SCT 正在使用的数据库不能被删除 use SCT DROP database SCT 这样会报错：“无法删除数据库 “SCT”，因为该数据库当前正在使用”。解决方法：切换另一个数据库 use master DROP database SCT 授权语法形式：grant 权限 on 表名 to 用户名 权限有：select, update, insert ,delete, exec, dri。对被授权的用户，要先成为该数据库的使用者，即要把用户加到数据库里,才能授权. 创建/修改table(表)创建：输入： Create Table Student ( S# char(8) not null , Sname char(10), Ssex char(2), Sage integer, D# char(2), Sclass char(6) ); 已经创建完成： 增加一列：alter table student add Sadress char(40); 修改某列ALTER TABLE table_nameALTER COLUMN column_name datatype ALTER TABLE Student ALTER COLUMN Ssex INT; 删除某列alter table Student drop column Saddress 此语法在并非SQL标准语法 创建一个带主键约束的表Create Table Course ( C# char(3) primary key , Cname char(12), Chours integer,Credit float(1), T# char(3) ) ; 向表中插入数据Insert Into Student Values ( &#39;98030101&#39; , &#39;张三&#39;, &#39;男&#39;, 20, &#39;03&#39;, &#39;980301&#39;); Insert Into Student ( S#, Sname, Ssex, Sage, D# ,Sclass) Values (&#39;98030102&#39;,&#39;张四&#39;,&#39;女&#39;,20,&#39;03&#39;,&#39;980301’); Insert Into Course Values ( &#39;001’ , &#39;数据库’, 40, 6， ’001’); Insert Into Course(Cname, C#, Credit, Chours, T#) Values (&#39;数据库&#39;, &#39;002&#39;, 7, 30, &#39;002&#39;); 上面的insert语句实操时各种报错。。。暂时不细究了 tip:有时候因为数据更新不及时而报错，Ctrl+Shift+R可以刷新缓存区","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"pytorch(2)： Tensor的创建与调整","slug":"pytorch-note-2","date":"2021-02-05T02:10:00.000Z","updated":"2021-02-08T13:38:43.645Z","comments":true,"path":"2021/02/05/pytorch-note-2/","link":"","permalink":"/2021/02/05/pytorch-note-2/","excerpt":"","text":"测试环境版本: torch1.7.1 + CPUpython 3.6 Tensor是pytorch中的“张量”，可以看作是类似numpy的矩阵本文介绍如何创建与调整Tensor 首先引用torch: import torch as t 1、创建tensor1）使用Tensor函数创建tensor# 1 指定形状 a = t.Tensor(2,3) a # 数值取决于内存空间的状态 tensor([[0., 0., 0.], [0., 0., 0.]]) 2）用list列表为参数创建b = t.Tensor([[1,2],[3,4]]) b tensor([[1., 2.], [3., 4.]]) `tensor也可以转化为list ls = b.tolist() ls [[1.0, 2.0], [3.0, 4.0]] 3）用torch.size为参数首先torch.Size是Tensor的参数 b_size = b.size() b tensor([[1., 2.], [3., 4.]]) b_size torch.Size([2, 2]) type(b_size) torch.Size c = t.Tensor(b_size) c tensor([[ 4.0000e+00, 0.0000e+00], [-1.2593e+13, 4.5911e-41]]) Tensor.shape等价于Tensor.size() c.shape torch.Size([2, 2]) 需要注意：使用Tensor(*sizes)创建Tensor时系统仅会检查剩余空间是否够用，但不会真的分配空间只有创建的tensor被使用时才分配空间 2、其他常用创建方法1)只含1的tensort.ones(2,3) tensor([[1., 1., 1.], [1., 1., 1.]]) 2）只含0的tensort.zeros(2,3) tensor([[0., 0., 0.], [0., 0., 0.]]) 3) 递增数列t.arange(0,10,2) tensor([0, 2, 4, 6, 8]) t.linspace(0,15,3) # 0到15均匀分割成3份 tensor([ 0.0000, 7.5000, 15.0000]) t.linspace(20,-5,5) tensor([20.0000, 13.7500, 7.5000, 1.2500, -5.0000]) 4) 均匀分布随机数t.rand(2,3,4) tensor([[[0.0350, 0.1746, 0.5931, 0.9241], [0.1791, 0.2205, 0.1145, 0.1942], [0.4908, 0.3410, 0.2910, 0.5894]], [[0.3705, 0.1012, 0.6324, 0.6196], [0.3016, 0.7018, 0.1615, 0.2207], [0.4301, 0.2420, 0.2793, 0.2108]]]) 5) 正态分布随机数t.randn(2,3) tensor([[ 0.1970, 0.7628, 1.0303], [ 0.6061, -2.3474, -0.1140]]) 6）随机排列t.randperm(10) tensor([0, 9, 6, 8, 1, 4, 3, 7, 5, 2]) 7) 对角线为1的矩阵t.eye(3,4) tensor([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.]]) 不要求为方阵 2、调整tensor形状1) tensor.viewtensor.view可以修改tensor的形状，但是 新tensor与原tensor共享内存 新tensor与原tensor必须保证元素个数相同 a = t.ones(2,3) b = a.view(1,6) print(&quot;a为：&quot;) print(a) print(&quot;b为：&quot;) print(b) a为： tensor([[1., 1., 1.], [1., 1., 1.]]) b为： tensor([[1., 1., 1., 1., 1., 1.]]) 由共享内存可知，一个tensor的改变也会改变另一个tensor a[0][0] = 0 b tensor([[0., 1., 1., 1., 1., 1.]]) 2)tensor.squeeze() 删除维度将元素个数为1的维度删去object.squeeze()以及t.squeeze()会将长度为1的维度抹去(或者称为“降维？”) c = t.randn(1,3,4,1) c.shape torch.Size([1, 3, 4, 1]) d = c.squeeze() d.shape torch.Size([3, 4]) d = t.squeeze(c) print(&quot;原矩阵形状&quot;) print(c.shape) print(&quot;压缩后形状&quot;) print(d.shape) 原矩阵形状 torch.Size([1, 3, 4, 1]) 压缩后形状 torch.Size([3, 4]) object.squeeze(n)会将第n维删去但如果第n维不止一个元素操作无效 print(&quot;删去第2维:&quot;) print(c.squeeze(2).shape) print(&quot;删去第3维:&quot;) print(c.squeeze(3).shape) 删去第2维: torch.Size([1, 3, 4, 1]) 删去第3维: torch.Size([1, 3, 4]) 3）tensor.unsqueeze()object.squeeze(n)在第n维上插入一个这里的n不可省略 print(&quot;原矩阵形状:&quot;) c.shape 原矩阵形状: torch.Size([1, 3, 4, 1]) print(&quot;增加第1维:&quot;) c.unsqueeze(1).shape 增加第1维: torch.Size([1, 1, 3, 4, 1]) print(&quot;原矩阵形状:&quot;) c.shape 原矩阵形状: torch.Size([1, 3, 4, 1]) print(&quot;增加第2维:&quot;) c.unsqueeze(2).shape 增加第2维: torch.Size([1, 3, 1, 4, 1]) c = t.Tensor([[[2]]]) squeeze()与unsqueeze()后的对象与原对象共享内存 d = c.squeeze() e = c.unsqueeze(2) c[0][0][0] = 1 print(d) print(e) tensor(1.) tensor([[[[1.]]]]) 4) tensor.resize()c = t.arange(1,10) c tensor([1, 2, 3, 4, 5, 6, 7, 8, 9]) 数据量不变的话，和view没有什么区别resize()会有弃用提醒，所以这里使用resize_() c.resize_(3,3) tensor([[0, 2, 3], [4, 5, 6], [7, 8, 9]]) 如果元素个数改变，填充和删除都是按“Z”字形 c.resize_(2,2) tensor([[0, 2], [3, 4]]) c.resize_(4,4) tensor([[ 0, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 32651548277538908, 27303553780220005, 28992339220037731], [32651492442964069, 29273822787141743, 29555280582738012, 26740621010600046]])","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"pytorch","slug":"pytorch","permalink":"/tags/pytorch/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"pytorch(1) 简单入门","slug":"pytorch-note-1","date":"2021-02-04T03:40:24.000Z","updated":"2021-02-08T13:38:55.335Z","comments":true,"path":"2021/02/04/pytorch-note-1/","link":"","permalink":"/2021/02/04/pytorch-note-1/","excerpt":"","text":"测试环境版本: torch1.7.1 + CPUpython 3.6 1、Tensor实际上就是一个高维数组。类似与numpy 加法的几种写法：import torch as t x = t.Tensor(5,3) y = t.Tensor(5,3) z = t.Tensor(5,3) # z必须事先分配内存 1)z = x + y 2)z = t.add(x,y) 3)t.add(x,y,out = z) 4）add() 与 add_()的区别：x.add(y),等同于 x+y。 x的值不会改变x.add_(y)等同于 x += y（且返回值是x的值） Tensor与numpy的相互转化与numpy相比，Tensor支持gpu运算。numpy()方法可以将Tensor转化为numpy In [23]: x = t.Tensor(3,4) In [24]: y = x.numpy() In [26]: x[1][1] = 1 In [27]: y Out[27]: array([[1.0102060e-38, 9.0000075e-39, 9.6428910e-39, 1.0653069e-38], [1.0102052e-38, 1.0000000e+00, 1.0653079e-38, 9.0000426e-39], [8.4490268e-39, 8.7245053e-39, 1.0102052e-38, 1.0653065e-38]], dtype=float32) 注意：Tensor与numpy共用内存，所以两者的转化非常快。但相对的，对其中一个的操作也会影响另一个 GPU加速运算cuda方法可以将Tensor转化为支持cuda的Tensor if t.cuda.is_available(): x = x.cuda() y = y.cuda() z = x + y 2、Autograd 自动微分pytorch的Autograd模块实现了自动求微分的功能。 Autograd模块的核心类是autograd.Variable,他简单封装了Tensor,并支持几乎所有的tensor操作。 autograd.Variable的数据结构包含三部分：{data: 存储着Variable所包含的Tensor。grad：保存data对应的梯度，它也是一个Variable，而不是Tensor。grad_fn：指向一个function对象，这个function用来反向传播求导数。} 在我的测试中，tensor和Variable是等同的。和书中所说不一样。可能原因有： 1、我安装的pytoch并不是cuda版本()不可以进行gpu运算 2、仅仅是显示问题，实际上tensor和variable不同，只是我没有发现 3、pytorch进行了更新，variable和tensor被改的一样了 （补充：后来我发现实际情况是3） from torch.autograd import Variable import torch as t x = Variable(t.ones(2,2),requires_grad = True) x # tensor([[1., 1.], # [1., 1.]], requires_grad=True) y = x.sum() y # tensor(4., grad_fn=&lt;SumBackward0&gt;) # x.grad # tensor([[1., 1.], # [1., 1.]]) y.backward() x.grad # tensor([[2., 2.], # [2., 2.]]) 注意，grad在反向传播的过程中是累加的，反向传播之前需要把梯度清零。 x.grad.data.zero_() x # tensor([[1., 1.], # [1., 1.]], requires_grad=True) x.grad # tensor([[0., 0.], # [0., 0.]]) 3、nnnn(神经网络)是神经网络的一个模块化接口。 利用它可以便捷地搭建神经网络。 nn.Module是nn中最重要的类，可以看作一个神经网络的封装，包含着各层定义和forward方法 建立一个基础的前向传播网络： import torch.nn as nn import torch.nn.functional as F class Net(nn.Module): def __init__(self): #下式等同于nn.Mudule.__init__(self) super(Net,self).__init__() # net继承了nn.Mudule以及其构造函数 #两层卷积层： self.conv1 = nn.Conv2d(1,6,5) #参数解释：1:输入图片为单通道，RGB图像的输入通道为3 #6：输出通道数 #5：卷积核大小为5×5， 输入5与(5,5)等同 self.conv2 = nn.Conv2d(6,16,5) #全连接层： self.fc1 = nn.Linear(16*5*5,120) self.fc2 = nn.Linear(120,84) self.fc3 = nn.Linear(84,10) def forward(self,x): # 卷积-&gt;激活-&gt;池化 x = F.max_pool2d(F.relu(self.conv1(x)),(2,2)) x = F.max_pool2d(F.relu(self.conv2(x)),2) # reshape 自适应 x = x.view(x.size()[0],-1) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x net = Net() print(net) 以上构建的是一个这样的网络：卷积-激活-池化-卷积-激活-池化-激活-全连接-激活-全连接-激活其中激活函数使用ReLU 不需要学习参数的层可以不在init()中定义。 比如ReLU 只要在nn.Module的子类中定义了forward函数，backward函数就自动被实现。 可以用parameters方法查看各层的权重参数 params = net.parameters print(params) 输出： (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1)) (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1)) (fc1): Linear(in_features=400, out_features=120, bias=True) (fc2): Linear(in_features=120, out_features=84, bias=True) (fc3): Linear(in_features=84, out_features=10, bias=True)) input_data = t.randn(1,1,32,32) out = net(input_data) print(out.size()) 损失函数：pytorch中封装了常用的损失函数 nn.MSEloss 均方误差 nn.CrossEntropyLoss 交叉熵误差 input_data = t.randn(1,1,32,32) out = net(input_data) # print(out.size()) arrtmp = np.array(list(range(10)),ndmin=2) target = t.from_numpy(arrtmp).float() criterion = nn.MSELoss() loss_func = criterion(out,target) 由损失函数反向传播，自动获得梯度loss_func.backward() net.conv1.bias.grad 结果：tensor([-0.0280, -0.0164, 0.0484, 0.0696, 0.0301, -0.1436]) 优化器（更新参数的策略）以随机梯度下降法(SGD)为例：其实现为：weight = weight - learning_rate * gradient 如果在刚才的网络中,应该写一个这样代码： learning_rate = 0.01 for f in net.parameters(): f.data.sub_(f.grad.data * learning_rate) 而pytorch已经内置了常用的优化器，比如adam、SGD import torch.optim as optim optimizer = optim.SGD(net.parameters(),lr=0.01) #梯度清零 optimizer.zero_grad()# 等同于net.zero_grad out = net(input_data) #反向传播 loss_func.backward() #更新参数 optimizer.step()","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"pytorch","slug":"pytorch","permalink":"/tags/pytorch/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"python3 自定义sort","slug":"python3-sort","date":"2021-01-31T03:40:24.000Z","updated":"2021-02-08T06:01:24.735Z","comments":true,"path":"2021/01/31/python3-sort/","link":"","permalink":"/2021/01/31/python3-sort/","excerpt":"","text":"欲实现以下功能：a是一个二维数组a = [[1,2],[4,5],[1,6],[5,3],[3,8],[12,34],[12,33],[0,12]]现在要对这个二维数组排序，规则是：首先按a[i][0]升序排序如果a[i][0]值相同，按a[i][1]升序排序 list自带的sort函数是用key来实现的（有点儿类似哈希），需要将每个元素映射为可比较的值。 我的映射思路: key = a[i][0]*1000+a[i][1],也就是映射为整数 a = [[1,2],[4,5],[1,6],[5,3],[3,8],[12,34],[12,33],[0,12]] a.sort(key=lambda x:x[0]*1000+x[1]) print(a) # 输出： # [[0, 12], [1, 2], [1, 6], [3, 8], [4, 5], [5, 3], [12, 33], [12, 34]] lambda表达式不是必须的，一下两种写法等同: # 写法1 def key_exp(x): return x[0]*1000 +x[1] a.sort(key=key_exp) # 写法2 a.sort(key=lambda x:x[0]*1000+x[1]) 复习一下lambda表达式： def sum(arg1, arg2): total = arg1 + arg2 return total # 使用lambda表达式的写法： lambda arg1, arg2: arg1 + arg2 # arg1, arg2可以传入默认值 如： x = 1 y = 2 add = lambda a,b:a+b print(add(x,y))","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"小程序笔记（一）基础储备","slug":"mini-program-1","date":"2021-01-30T03:40:24.000Z","updated":"2021-02-08T04:45:57.242Z","comments":true,"path":"2021/01/30/mini-program-1/","link":"","permalink":"/2021/01/30/mini-program-1/","excerpt":"","text":"一、像素相关1.1 物理像素1) 屏幕的分辨率2) 设备能控制显示的最小单元，可以把物理像素看成是对应的像素点 1.2 设备独立像素 &amp; css 像素设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用并控制的虚拟像素(比如：CSS 像素,只是在 android 机中 CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”)，然后由相关系统转换为物理像素。 1.3 dpr 比 &amp; DPI &amp; PPI1) dpr: 设备像素比，物理像素/设备独立像素 = dpr， 一般以 iphon6 的 dpr 为准 dpr =22) PPI: 一英寸显示屏上的像素点个数3) DPI：最早指的是打印机在单位面积上打印的墨点数，墨点越多越清晰 二、移动端适配2.1 viewport2.1.1 为什么做 viewport 适配a) 手机厂商在生产手机的时候大部分手机默认页面宽度为 980pxb) 手机实际视口宽度都要小于 980px，如: iphone6 为 375pxc) 开发需求： 需要将 980 的页面完全显示在手机屏幕上且没有滚动条 2.1.2 实现：这句代码可以让网页宽度和手机视窗宽度匹配 2.2 rem适配1. 为什么做 rem 适配a) 机型太多，不同的机型屏幕大小不一样b) 需求： 一套设计稿的内容在不同的机型上呈现的效果一致，根据屏幕大小不同的变化，页面中的内容也相应变化 2. 实现function remRefresh() { let clientWidth = document.documentElement.clientWidth; // 将屏幕等分 10 份 let rem = clientWidth / 10; document.documentElement.style.fontSize = rem + &#39;px&#39;; document.body.style.fontSize = &#39;12px&#39;; } window.addEventListener(&#39;pageshow&#39;, () =&gt; { remRefresh() }) // 函数防抖 let timeoutId; window.addEventListener(&#39;resize&#39;, () =&gt; { timeoutId &amp;&amp; clearTimeout(timeoutId); timeoutId = setTimeout(() =&gt;{ remRefresh() }, 300) }) 三、(微信)小程序的适配方案a) 小程序适配单位： rpxb) 规定任何屏幕下宽度为 750rpxc) 小程序会根据屏幕的宽度不同自动计算 rpx 值的大小d) iphone6 下： 1rpx = 1 物理像素 = 0.5px","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"/tags/Web前端/"},{"name":"css","slug":"css","permalink":"/tags/css/"},{"name":"小程序","slug":"小程序","permalink":"/tags/小程序/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"鱼书笔记 第八章 深度学习","slug":"DLFromScratch-8","date":"2021-01-29T03:40:24.000Z","updated":"2021-02-08T05:09:40.562Z","comments":true,"path":"2021/01/29/DLFromScratch-8/","link":"","permalink":"/2021/01/29/DLFromScratch-8/","excerpt":"","text":"8.1 加深网络创建一个图示中的网络，挑战MINIST数据集 这个网络使用He初始值作为权重的初始值，使用Adam更新权重参数。把上述内容总结起来，这个网络有如下特点。 • 基于3×3的小型滤波器的卷积层。• 激活函数是ReLU。• 全连接层的后面使用Dropout层。• 基于Adam的最优化。• 使用He初始值作为权重初始值。 书中介绍这个网络的识别精度能稳定达到99%以上 8.1.1 数据扩充的介绍Data Augmentation(数据扩充)，虽然方法很简单，但在提高识别精度上效果显著。 具体方法大概是:将训练数据处理一下，以达到扩充数据的目的。 比如： 将原图像旋转一定角度 裁切原图像 改变原图像的亮度、对比度等 该方法在训练数据较少时尤其有效 8.1.3 加深网络的动机为什么加深网络能提高学习率呢？原因之一是节省参数 直观理解起来大概是： 假如使用100个参数构建网络 方案1： 构建1个10×10的层方案2： 构建4个5×5的层 但两种方案比较而言，方案2中，对于每个输入数据，实际上有25^4种参数的组合来处理它而方案1仅有100种。多个层之间可以添加激活函数，更能提高神经网络的表现力 而减少参数又可以减少学习时间 8.2 深度学习的小历史深度学习受到关注2012年举办的大规模图像识别大赛ILSVRC（ImageNet Large Scale Visual Recognition Challenge）。在那年的比赛中，基于深度学习的方法（通称AlexNet）以压倒性的优势胜出，彻底颠覆了以往的图像识别方法。 8.2.1 ImageNetImageNet[25]是拥有超过100万张图像的数据集。如图8-7所示，它包含了各种各样的图像，并且每张图像都被关联了标签（类别名）。每年都会举办使用这个巨大数据集的ILSVRC图像识别大赛。 下面介绍的都是在这个数据集中表现优异的神经网络 8.2.3 VGGVGG是由卷积层和池化层构成的基础的CNN。 它的特点在于将有权重的层（卷积层或者全连接层）叠加至16层（或者19层），具备了深度（根据层的深度，有时也称为“VGG16”或“VGG19”）。 VGG中需要注意的地方是，基于3×3的小型滤波器的卷积层的运算是连续进行的。如图8-9所示，重复进行“卷积层重叠2次到4次，再通过池化层将大小减半”的处理，最后经由全连接层输出结果。 ResNet深度加深是有限度的：随着深度加深，数据的梯度会降低，学习会越来越困难 ResNet导入了“快捷结构”通过这种快捷结构，原来卷积层的输出F(x)变成了F(x)+x一定程度上改善了梯度消失的问题 ResNet可以加深到100多层。 8.3 深度学习的高速化本节介绍如何加速学习 8.3.1先看AlexNet在推理时各层占用的时间 (fc指的是全连接层) 从图中可知，AlexNex中，大多数时间都被耗费在卷积层上。实际上，卷积层的处理时间加起来占GPU整体的95%，占CPU整体的89%。 8.3.2 基于GPU的高速化GPU擅长并行运算CPU擅长连续串行的运算。 在矩阵处理时，需要大量并行运算，此时使用GPU能大大加速学习过程。 8.3.3 分布式学习分布式学习，简而言之，就是在多个计算机上进行的学习。 Google的TensorFlow、微软的CNTK（Computational Network Toolki）在开发过程中高度重视分布式学习。 分布式学习需要解决机器间的通信、数据的同步等多个无法轻易解决的问题。但这些可以交给tensorflow等学习框架解决。 8.3.4 运算精度的位数缩减不止是CPU和GPU，在深度学习时，内存、总线宽度也有可能成为瓶颈。 关于内存容量，需要考虑将大量的权重参数或中间数据放在内存中。关于总线带宽，当流经GPU（或者CPU）总线的数据超过某个限制时，就会成为瓶颈。考虑到这些情况，我们希望尽可能减少流经网络的数据的位数。 比如：当能用4位大体存储权重参数时，就不要使用6位。 计算机中表示小数时，有32位的单精度浮点数和64位的双精度浮点数等格式。根据以往的实验结果，在深度学习中，即便是16位的半精度浮点数（half float），也可以顺利地进行学习。 另外，使用16位半精度浮点数应该也会缩短运算时间（书中没提，也许是影响不大，但肯定会有影响） 实际上，NVIDIA的下一代GPU框架Pascal也支持半精度浮点数的运算，由此可以认为今后半精度浮点数将被作为标准使用。 8.5 深度学习的未来8.5.2 无监督学习DCGAN（Deep Convolutional Generative Adversarial Network）方法生成的卧室图像的例子。 这些并不是照片，而是由深度学习网络自动生成的。DCGAN的要点在于，它同时使用了两个神经网络。Generator生成近似真品的图像，Discriminator判别它是不是真图像（是Generator生成的图像还是实际拍摄的图像）。像这样，通过让两者以竞争的方式学习，Generator会学习到更加精妙的图像作假技术，Discriminator则会成长为能以更高精度辨别真假的鉴定师。两者互相切磋、共同成长 有监督的学习:所有的训练数据都有正确解标签与有监督学习对应的就是无监督的学习。DCGAN就是无监督的学习。 8.5.3 强化学习设想这样一个问题：如何训练一个模型来玩《超级马里奥》 之前的监督式学习应该是这样的方法：给每一步都设置正确解标签。 但可不可以不交由人工判断，而是让模型自动学习呢？ 这就是强化学习。强化学习没有的正确解标签，而是基于一些指标，比如游戏的金币数、积分、游戏的输赢来确定行动。当然，强化学习也必须要利用深度学习，因为游戏的输赢等也需要有函数来评估。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"鱼书笔记","slug":"鱼书笔记","permalink":"/tags/鱼书笔记/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"Flex布局","slug":"flex","date":"2021-01-29T03:40:24.000Z","updated":"2021-02-08T06:01:20.956Z","comments":true,"path":"2021/01/29/flex/","link":"","permalink":"/2021/01/29/flex/","excerpt":"","text":"本文总结自菜鸟教程 flex布局是css中的一种布局模式： 一、使用flex布局：/*任何一个容器都可以指定为Flex布局。*/ .box{ display: flex; } /*行内元素也可以使用Flex布局。*/ .box{ display: inline-flex; } /*Webkit内核的浏览器，必须加上-webkit前缀。*/ .box{ display: -webkit-flex; /* Safari */ display: flex; } 注意：设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念 flex container:采用Flex布局的元素，称为Flex容器(Flex container) flex item: flex container的所有子元素称为flex成员(flex item) main axis: 主轴(水平的) cross axis:交叉轴(竖直的) main start/end: 主轴的 开始/结束 位置 cross start/end: 交叉轴的 开始/结束 位置 main size: 单个item在主轴上占用的空间 cross size: 单个item在交叉轴上占用的空间 三、容器属性3.1 flex-direction属性.box { flex-direction: row | row-reverse | column | column-reverse; } 这几张图依次是： column-reverse \\ column \\ row \\ row-reverse row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性flex-wrap用来定义这个问题：当item在一行中排不开的时候，如何布局呢？ .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 1、nowrap(不换行)2、wrap(换行)3、wrap-reverse(换行，且第一行放在下面) 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 参数说明： flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 图示： 3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} 四、项目的属性4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: &lt;integer&gt;; } 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: ; / default 0 /} 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: ; / default 1 /}布局类似flex-grow 4.4 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: | auto; / default auto /}它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; }","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"Web前端","slug":"Web前端","permalink":"/tags/Web前端/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"python 列表生成器","slug":"ListComprehensions","date":"2021-01-28T03:40:24.000Z","updated":"2021-02-08T04:45:50.312Z","comments":true,"path":"2021/01/28/ListComprehensions/","link":"","permalink":"/2021/01/28/ListComprehensions/","excerpt":"","text":"基础版：variable = [out_exp for item in list if (expression == true)] 如： li = [i*i for i in range(10) if i % 2] 输出： [1, 9, 25, 49, 81] if也可以省略li = [i for i in range(10)] 输入： [0,1,2,3,4,5,6,7,8,9] for/if均可以多层嵌套li = [i+j+k for i in &quot;123&quot; for j in &quot;abc&quot; for k in &quot;ABC&quot;] 输出结果： [‘1aA’, ‘1aB’, ‘1aC’, ‘1bA’, ‘1bB’, ‘1bC’, ‘1cA’, ‘1cB’, ‘1cC’, ‘2aA’, ‘2aB’, ‘2aC’, ‘2bA’, ‘2bB’, ‘2bC’, ‘2cA’, ‘2cB’, ‘2cC’, ‘3aA’, ‘3aB’, ‘3aC’, ‘3bA’, ‘3bB’, ‘3bC’, ‘3cA’, ‘3cB’, ‘3cC’] li = [i+j+k for i in &quot;123&quot; if i != &#39;1&#39; for j in &quot;abc&quot; if j != &#39;a&#39; for k in &quot;ABC&quot;] 输出结果： [‘2bA’, ‘2bB’, ‘2bC’, ‘2cA’, ‘2cB’, ‘2cC’, ‘3bA’, ‘3bB’, ‘3bC’, ‘3cA’, ‘3cB’, ‘3cC’]","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"974. 和可被 K 整除的子数组","slug":"leetcode974","date":"2021-01-28T03:40:24.000Z","updated":"2021-02-08T04:45:32.318Z","comments":true,"path":"2021/01/28/leetcode974/","link":"","permalink":"/2021/01/28/leetcode974/","excerpt":"","text":"原题传送门：《leetcode974. 和可被 K 整除的子数组》 题目描述：给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 示例： 输入：A = [4,5,0,-2,-3,1], K = 5输出：7解释：有 7 个子数组满足其元素之和可被 K = 5 整除：[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 提示： 1 &lt;= A.length &lt;= 30000-10000 &lt;= A[i] &lt;= 100002 &lt;= K &lt;= 10000 AC代码： class Solution { public: int* counter; int subarraysDivByK(vector&lt;int&gt;&amp; A, int K) { init(A, K); count(A); return solve(K); } int solve(int K) { int ans = counter[0] * (counter[0] + 1) / 2; for (int i = 1; i &lt; K; ++i) { int tmp = counter[i]; ans += (tmp * (tmp - 1) / 2); } delete[]counter; return ans; } int init(vector&lt;int&gt;&amp; A, int K) { A[0] %= K; if(A[0] &lt; 0) A[0] += K; //错点2 counter = new int[K]; memset(counter, 0, K * 4); for (int i = 1; i &lt; A.size(); ++i) { A[i] += A[i - 1]; A[i] %= K; if (A[i] &lt; 0) A[i] += K; //错点1 } return 0; } int count(vector&lt;int&gt;&amp; A) { for (int i = 0; i &lt; A.size(); ++i) { ++counter[A[i]]; } return 0; } }; 一开始暴力TLE了没什么好说的。 需要注意 数组求和时前缀和的使用 负数取模的问题","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"前缀和","slug":"前缀和","permalink":"/tags/前缀和/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"负数取模问题","slug":"mod-for-nagative","date":"2021-01-28T03:40:24.000Z","updated":"2021-02-08T04:46:04.935Z","comments":true,"path":"2021/01/28/mod-for-nagative/","link":"","permalink":"/2021/01/28/mod-for-nagative/","excerpt":"","text":"先说结论:c++中负数取模为负数python中负数取模为正数比如：-12 % 10c++中结果为-2python中结果为8 c++测试：测试程序： #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int a; while (1) { cout &lt;&lt; &quot;&gt;&gt; 输入：&quot;; cin &gt;&gt; a; cout &lt;&lt;&quot;&gt;&gt; mod 10结果：&quot; &lt;&lt; a % 10 &lt;&lt; endl; } return 0; } 结果： &gt;&gt; 输入：5 &gt;&gt; mod 10结果：5 &gt;&gt; 输入：-1 &gt;&gt; mod 10结果：-1 &gt;&gt; 输入：-10 &gt;&gt; mod 10结果：0 &gt;&gt; 输入：-12 &gt;&gt; mod 10结果：-2 &gt;&gt; 输入：-15 &gt;&gt; mod 10结果：-5 可见，负数取模仍是负数 python测试In [1]: 5 % 10 Out[1]: 5 In [2]: 0 % 10 Out[2]: 0 In [3]: -2 % 10 Out[3]: 8 In [4]: -10 % 10 Out[4]: 0 In [5]: -12 % 10 Out[5]: 8 In [6]: -13 % 10 Out[6]: 7 python中负数取模答案是正数。","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"鱼书笔记 第七章 卷积神经网络","slug":"DLFromScratch-7","date":"2021-01-27T03:40:24.000Z","updated":"2021-02-08T05:09:32.167Z","comments":true,"path":"2021/01/27/DLFromScratch-7/","link":"","permalink":"/2021/01/27/DLFromScratch-7/","excerpt":"","text":"卷积神经网络(Convolutional Neural Network)简称为CNN。几乎所有的深度学习比赛中都在广泛使用卷积神经网络。 7.1 CNN的结构先回顾一下之前学习的神经网络。相邻层的所有神经元之间都有连接，这称为全连接 前面我们用Affine层实现了全连接 这是利用ReLU层和Affine层构建的一个四层神经网络 而CNN的模式大概是这样的：也就是说，层与层之间有些用卷积层(Convolution)或池化层(Pooling)。 7.2 卷积层7.2.1 全连接的问题全连接层的问题是：忽视了输入数据的形状 比如处理一个10×10的输入图像，全连接层会把他处理成一个一维的100×1的数据。这个处理过程丢失了数据的形状。 在图像处理过程中，这个形状所代表的信息有可能非常重要 而在卷积神经网络中，可以将三维输入的数据按照三维来处理。 在卷积神经网络中，会把输入输出数据称作特征图其中输入数据被称为输入特征图输出数据被称为输出特征图 7.2.2 卷积运算如图：上图展示的是如下运算： 相当于一个窗口不停滑动的过程其中滑动时进行的运算是点乘求和运算 上面的大矩阵是输入数据小矩阵是权重值（滤波器） 一般在卷积运算之后还要加上偏置 下面介绍填充幅度和步幅上面的例子中，填充幅度为0，步幅为1；步幅很容易理解：就是每次平移的格数。所谓填充幅度，是指在原图周围填充上特定数值（比如0） 思考：当输入数据为H×W，步幅为S，填充幅度为M,滤波器大小为(FH,FW)输出数据应该是？ 高为\\frac{H-FH+2M}{S}+1,宽为\\frac{W-FW+2M}{S}+1 7.2.5 三维卷积运算假如输入的是三维数据呢？我们可以使用一个三维的滤波器。(之前的滤波器是二维的) 但这样运算会丢失维度（输入是三维，输出是二维）所以采用下面的方法：这样得到的是三维数据。可以看作：使用的是一个四维的滤波器 7.3 池化层池化层的作用是缩小数据量。 如图是一个执行max操作的池化层： 一般来说，池化层的窗口大小会设定成和步幅相同的值。 池化层的特征 没有需要学习的参数 通道数不发生变化 对数据的微小变化不敏感 7.4 池化层和卷积层的实现CNN中传递的是四维数据(batch_num, channel,width,height) 7.4.1 生成四维数组import numpy as np x = np.random.rand(10,1,28,28) 生成的是一个10×1×28×28的四维数据 基于im2col的展开卷积运算由于牵扯到较高维度，需要嵌套for循环。这在运算起来比较麻烦。im2col可以将高维数据转换成二维矩阵，也能再将运算过的矩阵恢复为高维数据。 具体实现不表。 当转换成矩阵后，就可以高效的进行卷积运算。 卷积层具体实现 class Convolution: def __init__(self, W, b, stride=1, pad=0): self.W = W #滤波器（权重） self.b = b self.stride = stride #步幅 self.pad = pad#填充 # 保存的中间变量（反向传播时用到） self.x = None self.col = None self.col_W = None # 重み・バイアスパラメータの勾配 self.dW = None self.db = None def forward(self, x): FN, C, FH, FW = self.W.shape #滤波器的形状 N, C, H, W = x.shape out_h = 1 + int((H + 2*self.pad - FH) / self.stride) out_w = 1 + int((W + 2*self.pad - FW) / self.stride) col = im2col(x, FH, FW, self.stride, self.pad)#输入数据展开 col_W = self.W.reshape(FN, -1).T #滤波器展开 out = np.dot(col, col_W) + self.b#卷积运算 out = out.reshape(N, out_h, out_w, -1).transpose(0, 3, 1, 2)#恢复数据的形状 self.x = x self.col = col self.col_W = col_W return out def backward(self, dout): FN, C, FH, FW = self.W.shape dout = dout.transpose(0,2,3,1).reshape(-1, FN) self.db = np.sum(dout, axis=0) self.dW = np.dot(self.col.T, dout) self.dW = self.dW.transpose(1, 0).reshape(FN, C, FH, FW) dcol = np.dot(dout, self.col_W.T) dx = col2im(dcol, self.x.shape, FH, FW, self.stride, self.pad) return dx 池化层的实现与卷积层不同，池化层对每个通道会单独处理。 class Pooling: def __init__(self, pool_h, pool_w, stride=2, pad=0): self.pool_h = pool_h self.pool_w = pool_w self.stride = stride self.pad = pad self.x = None self.arg_max = None def forward(self, x): N, C, H, W = x.shape out_h = int(1 + (H - self.pool_h) / self.stride) out_w = int(1 + (W - self.pool_w) / self.stride) col = im2col(x, self.pool_h, self.pool_w, self.stride, self.pad) col = col.reshape(-1, self.pool_h*self.pool_w) arg_max = np.argmax(col, axis=1) out = np.max(col, axis=1) out = out.reshape(N, out_h, out_w, C).transpose(0, 3, 1, 2) self.x = x self.arg_max = arg_max return out def backward(self, dout): dout = dout.transpose(0, 2, 3, 1) pool_size = self.pool_h * self.pool_w dmax = np.zeros((dout.size, pool_size)) dmax[np.arange(self.arg_max.size), self.arg_max.flatten()] = dout.flatten() dmax = dmax.reshape(dout.shape + (pool_size,)) dcol = dmax.reshape(dmax.shape[0] * dmax.shape[1] * dmax.shape[2], -1) dx = col2im(dcol, self.x.shape, self.pool_h, self.pool_w, self.stride, self.pad) return dx CNN层的实现我们要实现的是这样的一个CNN：conv - relu - pool - affine - relu - affine - softmax # coding: utf-8 import sys, os sys.path.append(os.pardir) import pickle import numpy as np from collections import OrderedDict from common.layers import * from common.gradient import numerical_gradient class SimpleConvNet: &quot;&quot;&quot;単純なConvNet conv - relu - pool - affine - relu - affine - softmax Parameters ---------- input_size : 输入大小（对于MINIST来说为784） hidden_size_list : 隐藏层的层数 output_size : 输出（使用MNIST时为10） activation : &#39;relu&#39; or &#39;sigmoid&#39; weight_init_std : 权重的标准差设定（比如0.01） &#39;relu&#39;下使用He值 &#39;sigmoid&#39;下使用Xavier值 &quot;&quot;&quot; def __init__(self, input_dim=(1, 28, 28), conv_param={&#39;filter_num&#39;:30, &#39;filter_size&#39;:5, &#39;pad&#39;:0, &#39;stride&#39;:1}, hidden_size=100, output_size=10, weight_init_std=0.01): filter_num = conv_param[&#39;filter_num&#39;]#滤波器数量 filter_size = conv_param[&#39;filter_size&#39;]#滤波器大小 filter_pad = conv_param[&#39;pad&#39;]#填充 filter_stride = conv_param[&#39;stride&#39;]#步幅 input_size = input_dim[1]#输入大小，input_dim保存着输入数据的形状 conv_output_size = (input_size - filter_size + 2*filter_pad) / filter_stride + 1 pool_output_size = int(filter_num * (conv_output_size/2) * (conv_output_size/2)) # 重みの初期化 self.params = {} self.params[&#39;W1&#39;] = weight_init_std * \\ np.random.randn(filter_num, input_dim[0], filter_size, filter_size) self.params[&#39;b1&#39;] = np.zeros(filter_num) self.params[&#39;W2&#39;] = weight_init_std * \\ np.random.randn(pool_output_size, hidden_size) self.params[&#39;b2&#39;] = np.zeros(hidden_size) self.params[&#39;W3&#39;] = weight_init_std * \\ np.random.randn(hidden_size, output_size) self.params[&#39;b3&#39;] = np.zeros(output_size) # レイヤの生成 self.layers = OrderedDict() self.layers[&#39;Conv1&#39;] = Convolution(self.params[&#39;W1&#39;], self.params[&#39;b1&#39;], conv_param[&#39;stride&#39;], conv_param[&#39;pad&#39;]) self.layers[&#39;Relu1&#39;] = Relu() self.layers[&#39;Pool1&#39;] = Pooling(pool_h=2, pool_w=2, stride=2) self.layers[&#39;Affine1&#39;] = Affine(self.params[&#39;W2&#39;], self.params[&#39;b2&#39;]) self.layers[&#39;Relu2&#39;] = Relu() self.layers[&#39;Affine2&#39;] = Affine(self.params[&#39;W3&#39;], self.params[&#39;b3&#39;]) self.last_layer = SoftmaxWithLoss() def predict(self, x): for layer in self.layers.values(): x = layer.forward(x) return x def loss(self, x, t): &quot;&quot;&quot;損失関数を求める 引数のxは入力データ、tは教師ラベル &quot;&quot;&quot; y = self.predict(x) return self.last_layer.forward(y, t) def accuracy(self, x, t, batch_size=100): if t.ndim != 1 : t = np.argmax(t, axis=1) acc = 0.0 for i in range(int(x.shape[0] / batch_size)): tx = x[i*batch_size:(i+1)*batch_size] tt = t[i*batch_size:(i+1)*batch_size] y = self.predict(tx) y = np.argmax(y, axis=1) acc += np.sum(y == tt) return acc / x.shape[0] def numerical_gradient(self, x, t): &quot;&quot;&quot;勾配を求める（数値微分） Parameters ---------- x : 入力データ t : 教師ラベル Returns ------- 各層の勾配を持ったディクショナリ変数 grads[&#39;W1&#39;]、grads[&#39;W2&#39;]、...は各層の重み grads[&#39;b1&#39;]、grads[&#39;b2&#39;]、...は各層のバイアス &quot;&quot;&quot; loss_w = lambda w: self.loss(x, t) grads = {} for idx in (1, 2, 3): grads[&#39;W&#39; + str(idx)] = numerical_gradient(loss_w, self.params[&#39;W&#39; + str(idx)]) grads[&#39;b&#39; + str(idx)] = numerical_gradient(loss_w, self.params[&#39;b&#39; + str(idx)]) return grads def gradient(self, x, t): &quot;&quot;&quot;勾配を求める（誤差逆伝搬法） Parameters ---------- x : 入力データ t : 教師ラベル Returns ------- 各層の勾配を持ったディクショナリ変数 grads[&#39;W1&#39;]、grads[&#39;W2&#39;]、...は各層の重み grads[&#39;b1&#39;]、grads[&#39;b2&#39;]、...は各層のバイアス &quot;&quot;&quot; # forward self.loss(x, t) # backward dout = 1 dout = self.last_layer.backward(dout) layers = list(self.layers.values()) layers.reverse() for layer in layers: dout = layer.backward(dout) # 設定 grads = {} grads[&#39;W1&#39;], grads[&#39;b1&#39;] = self.layers[&#39;Conv1&#39;].dW, self.layers[&#39;Conv1&#39;].db grads[&#39;W2&#39;], grads[&#39;b2&#39;] = self.layers[&#39;Affine1&#39;].dW, self.layers[&#39;Affine1&#39;].db grads[&#39;W3&#39;], grads[&#39;b3&#39;] = self.layers[&#39;Affine2&#39;].dW, self.layers[&#39;Affine2&#39;].db return grads def save_params(self, file_name=&quot;params.pkl&quot;): params = {} for key, val in self.params.items(): params[key] = val with open(file_name, &#39;wb&#39;) as f: pickle.dump(params, f) def load_params(self, file_name=&quot;params.pkl&quot;): with open(file_name, &#39;rb&#39;) as f: params = pickle.load(f) for key, val in params.items(): self.params[key] = val for i, key in enumerate([&#39;Conv1&#39;, &#39;Affine1&#39;, &#39;Affine2&#39;]): self.layers[key].W = self.params[&#39;W&#39; + str(i+1)] self.layers[key].b = self.params[&#39;b&#39; + str(i+1)] 用于测试的源码如下： # coding: utf-8 import sys, os sys.path.append(os.pardir) # 親ディレクトリのファイルをインポートするための設定 import numpy as np import matplotlib.pyplot as plt from dataset.mnist import load_mnist from simple_convnet import SimpleConvNet from common.trainer import Trainer # データの読み込み (x_train, t_train), (x_test, t_test) = load_mnist(flatten=False) # 処理に時間のかかる場合はデータを削減 #x_train, t_train = x_train[:5000], t_train[:5000] #x_test, t_test = x_test[:1000], t_test[:1000] max_epochs = 20 network = SimpleConvNet(input_dim=(1,28,28), conv_param = {&#39;filter_num&#39;: 30, &#39;filter_size&#39;: 5, &#39;pad&#39;: 0, &#39;stride&#39;: 1}, hidden_size=100, output_size=10, weight_init_std=0.01) trainer = Trainer(network, x_train, t_train, x_test, t_test, epochs=max_epochs, mini_batch_size=100, optimizer=&#39;Adam&#39;, optimizer_param={&#39;lr&#39;: 0.001}, evaluate_sample_num_per_epoch=1000) trainer.train() # パラメータの保存 network.save_params(&quot;params.pkl&quot;) print(&quot;Saved Network Parameters!&quot;) # グラフの描画 markers = {&#39;train&#39;: &#39;o&#39;, &#39;test&#39;: &#39;s&#39;} x = np.arange(max_epochs) plt.plot(x, trainer.train_acc_list, marker=&#39;o&#39;, label=&#39;train&#39;, markevery=2) plt.plot(x, trainer.test_acc_list, marker=&#39;s&#39;, label=&#39;test&#39;, markevery=2) plt.xlabel(&quot;epochs&quot;) plt.ylabel(&quot;accuracy&quot;) plt.ylim(0, 1.0) plt.legend(loc=&#39;lower right&#39;) plt.show() 7.6 CNN可视化7.6.1 CNN的卷积层究竟在“观察”什么呢？我们将CNN的滤波器可视化，将权重显示为颜色，可以发现在学习前后，滤波器有了明显变化： 滤波器在“观察”什么，答案就是它在观察边缘（颜色变化的分界线）和斑块（局部的块状区域）等。 由此可知，卷积层的滤波器会提取边缘或斑块等原始信息。而刚才实现的CNN会将这些原始信息传递给后面的层。 7.6.2 基于分层结构的信息提取上面观察的仅仅是CNN中的一层，下面以AlexNet为例，介绍多层CNN的工作过程。 上面的图像可以概括为： CNN的卷积层中提取的信息。 第1层的神经元对边缘或斑块有响应 第3层对纹理有响应 第5层对物体部件有响应 最后的全连接层对物体的类别（狗或车）有响应 这是一个由简单到复杂、逐步加深的过程 7.7 具有代表性的CNN7.7.1 LeNet1998年被提出的CNN网络，可以说是CNN的鼻祖与当前CNN的区别主要是:1、池化层采用随机采样(现在更多采用Max操作)2、激活函数为sigmoid(现在更多采用ReLU) 7.7.2 AlexNet AlexNet的特点是：• 激活函数使用ReLU。• 使用进行局部正规化的LRN（Local Response Normalization）层。• 使用Dropout。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"鱼书笔记","slug":"鱼书笔记","permalink":"/tags/鱼书笔记/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"leetcode 1654. 到家的最少跳跃次数","slug":"leetcode1654","date":"2021-01-27T03:40:24.000Z","updated":"2021-02-08T04:45:43.206Z","comments":true,"path":"2021/01/27/leetcode1654/","link":"","permalink":"/2021/01/27/leetcode1654/","excerpt":"","text":"原题传送门—&gt;leetcode 题目描述：有一只跳蚤的家在数轴上的位置 x 处。请你帮助它从位置 0 出发，到达它的家。 跳蚤跳跃的规则如下：它可以 往前 跳恰好 a 个位置（即往右跳）。它可以 往后 跳恰好 b 个位置（即往左跳）。它不能 连续 往后跳 2 次。它不能跳到任何 forbidden 数组中的位置。跳蚤可以往前跳 超过 它的家的位置，但是它 不能跳到负整数 的位置。 给你一个整数数组 forbidden ，其中 forbidden[i] 是跳蚤不能跳到的位置，同时给你整数 a， b 和 x ，请你返回跳蚤到家的最少跳跃次数。如果没有恰好到达 x 的可行方案，请你返回 -1 。 示例示例 1： 输入：forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9输出：3解释：往前跳 3 次（0 -&gt; 3 -&gt; 6 -&gt; 9），跳蚤就到家了。 示例 2： 输入：forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11输出：-1 示例 3： 输入：forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7输出：2解释：往前跳一次（0 -&gt; 16），然后往回跳一次（16 -&gt; 7），跳蚤就到家了。 提示： 1 &lt;= forbidden.length &lt;= 10001 &lt;= a, b, forbidden[i] &lt;= 20000 &lt;= x &lt;= 2000forbidden 中所有位置互不相同。位置 x 不在 forbidden 中。 证明见链接：证明+过程 难点在于数学证明，只要把边界找到，就是简单的BFS。我的代码思路： blocks记录forbiden数组内容，blocks = 1则无法访问。 blocks也充当visited数组的功能，当某点已经访问过一次了，blocks的值也置为1 队列保存着上次跳跃可能的位置，正数代表向右跳，负数代表向左跳。比如-20代表的是上次跳跃是向左跳到了位置为20的地方 不过我遇到很有意思的事情：（一下是AC版本1，请特别注意代码中的入队顺序） class Solution { public: int *blocks; int minimumJumps(vector&lt;int&gt;&amp; forbidden, int a, int b, int x) { if(!x) return 0; blocks = new int[6005]; memset(blocks,0,24020); for(vector&lt;int&gt;::iterator i = forbidden.begin(); i!= forbidden.end(); ++i){ blocks[*i] = 1; }//路障标记 return bfs(a,b,x); } int bfs(int a,int b, int x){ queue&lt;int&gt; Q; Q.push(0); int step = 1; while(!Q.empty()){ int size_tmp = Q.size(); for(int i = 0; i &lt; size_tmp; ++i){ int tmp = Q.front(); int isPosi = 1;// if(tmp &lt;= 0) { isPosi = 0; tmp = -tmp; } int aa = tmp + a; int bb = tmp - b; if((aa == x)||((bb == x)&amp;&amp;(isPosi))) { return step; } if((bb &gt; 0)&amp;&amp;(!blocks[bb])&amp;&amp;(isPosi)) { //#左入队 Q.push(-bb); blocks[bb] = 1; } if((aa &lt;= 6000)&amp;&amp;(!blocks[aa])) { //#右入队 Q.push(aa); blocks[aa] = 1; } Q.pop(); } ++step; } return -1; } }; 奇怪之处在于：假如将两个入队顺序调换过来就会Wa掉，没道理啊。 我又仔细比较了调换顺序的执行过程，发现了问题： 假如在step = 6时，存在两个点:p点可以向右跳a步到达M点q点可以向左跳b步到达M点 那么此时入队的应该是正数还是负数？ 其实应该是正数，但是前面的写法无法应对这种情况。 改进版本： class Solution { public: int* blocks; int minimumJumps(vector&lt;int&gt;&amp; forbidden, int a, int b, int x) { if (!x) return 0; blocks = new int[6005]; memset(blocks, 0, 24020); for (vector&lt;int&gt;::iterator i = forbidden.begin(); i != forbidden.end(); ++i) { blocks[*i] = 1; }//路障标记 return bfs(a, b, x); } int bfs(int a, int b, int x) { queue&lt;int&gt; Q; Q.push(0); int step = 1; while (!Q.empty()) { int size_tmp = Q.size(); for (int i = 0; i &lt; size_tmp; ++i) { int tmp = Q.front(); int isPosi = 1;// if (tmp &lt;= 0) { isPosi = 0; tmp = -tmp; } int aa = tmp + a; int bb = tmp - b; if ((aa == x) || ((bb == x) &amp;&amp; (isPosi))) { return step; } if ((aa &lt;= 6000) &amp;&amp; (blocks[aa] &lt;= 0)) { Q.push(aa); blocks[aa] = 1; } if ((bb &gt; 0) &amp;&amp; (!blocks[bb]) &amp;&amp; (isPosi)) { Q.push(-bb); blocks[bb] = -1; } Q.pop(); } ++step; } return -1; } }; 至于第一版为什么恰巧能AC，我猜是数据不够强蒙混过关。。。","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"BFS","slug":"BFS","permalink":"/tags/BFS/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"JS笔记（六） 数组及其方法","slug":"jsNote-6","date":"2021-01-26T03:40:24.000Z","updated":"2021-02-08T04:41:36.616Z","comments":true,"path":"2021/01/26/jsNote-6/","link":"","permalink":"/2021/01/26/jsNote-6/","excerpt":"","text":"数组的定义数组的使用和其他编程语言差不多，但有以下区别： 数组是一类特殊的对象（使用typeof运算符，返回值是object） 数组的索引值不可以是负数。 数组的操作：遍历:for循环遍历（类似其他高级语言）forEach()var fruits, text; fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; text = &quot;&lt;ul&gt;&quot;; fruits.forEach(myFunction); text += &quot;&lt;/ul&gt;&quot;; document.getElementById(&quot;demo&quot;).innerHTML = text; function myFunction(value) { text += &quot;&lt;li&gt;&quot; + value + &quot;&lt;/li&gt;&quot;; } forEach的参数为一个函数，该函数有一个参数 添加元素1）pushvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits.push(&quot;Lemon&quot;); // 向 fruits 添加一个新元素 (Lemon) push的返回值是新数组的长度。 pop()是弹出元素，返回值是被弹出的元素 2)直接通过下标添加var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits[10] = &quot;Lemon&quot;); // 向 fruits 添加一个新元素 (Lemon) 这样的是可以的，fruits最后的结果是：[“Banana”,”Orange”,”Apple”,”Mango”,,,,,,,”Lemon”](中间会留下没有值的“洞”) 3) unshift()从头部插入元素 删除元素1）pop()pop()是弹出元素，返回值是被弹出的元素 2）shift()删除第一个元素，并且将之后的元素平移好。 查找元素1)Array.indexOf()indexOf() 方法在数组中搜索元素值并返回其位置。 2)Array.lastIndexOf()Array.lastIndexOf() 与 Array.indexOf() 类似，但是从数组结尾开始搜索。 3)Array.find()find() 方法返回通过测试函数的第一个数组元素的值。 这个例子查找（返回）大于 18 的第一个元素的值： var numbers = [4, 9, 16, 25, 29]; var first = numbers.find(myFunction); function myFunction(value, index, array) { return value &gt; 18; } 4)Array.findIndex()findIndex() 方法返回通过测试函数的第一个数组元素的索引。与前面的find很像，只不过返回值不同。 转换成字符串1）toString()方法可以将数组转换成字符串 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;JavaScript 数组方法&lt;/h1&gt; &lt;h2&gt;toString()&lt;/h2&gt; &lt;p&gt;toString() 方法以逗号分隔的字符串返回数组：&lt;/p&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; document.getElementById(&quot;demo&quot;).innerHTML = fruits.toString(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 某些情况下可认为这是一个强制转换，有时会自动调用 2）join()方法与toString的区别是，join可以有参数，参数是字符串中用作间隔的字符 splice 剪裁拼接&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;JavaScript 数组方法&lt;/h1&gt; &lt;h2&gt;splice()&lt;/h2&gt; &lt;p&gt;splice() 方法将新元素添加到数组中。&lt;/p&gt; &lt;button onclick=&quot;myFunction()&quot;&gt;试一试&lt;/button&gt; &lt;p id=&quot;demo1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;demo2&quot;&gt;&lt;/p&gt; &lt;script&gt; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; document.getElementById(&quot;demo1&quot;).innerHTML = &quot;原数组：&lt;br&gt;&quot; + fruits; function myFunction() { fruits.splice(2, 1, &quot;Lemon&quot;, &quot;Kiwi&quot;); document.getElementById(&quot;demo2&quot;).innerHTML = &quot;新数组：&lt;br&gt;&quot; + fruits; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; splice(2,1,”lemon”,”Kiwi”)中参数的意义是：2代表拼接点（即”Apple”），1代表从拼接点删除1个元素（即把”Apple”删掉）最后再插入”Lemon”,”Kiwi”一次运行的结果是：Banana,Orange,Lemon,Kiwi,Mango concat()连接concat将若干数组连接起来，返回一个新数组 var myGirls = [&quot;Cecilie&quot;, &quot;Lone&quot;]; var myBoys = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;]; var myChildren = myGirls.concat(myBoys); // 连接 myGirls 和 myBoys slice()切片类似字符串。返回值是一个新数组，不会改变原数组 排序sortvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits.sort(); // 对 fruits 中的元素进行排序 自定义使用sortvar points = [40, 100, 1, 5, 25, 10]; points.sort(function(a, b){return a - b}); 参数是一个函数。 反转数组 reverse()数据批量处理Array.map()迭代执行函数var numbers1 = [45, 4, 9, 16, 25]; var numbers2 = numbers1.map(myFunction); function myFunction(value, index, array) { return value * 2; } map会对数组中的每个元素执行myFunction,并把返回值存到一个数组中。 map() 方法不会对没有值的数组元素执行函数。 map() 方法不会更改原始数组。 Array.filter() 过滤器var numbers = [45, 4, 9, 16, 25]; var over18 = numbers.filter(myFunction); function myFunction(value, index, array) { return value &gt; 18; } 生成新数组，其中包含所有myFunction值为true的数据 Array.reduce()语法: arr.reduce(function(prev,cur,index,arr){ ... }, init); arr 表示原数组；prev 表示上一次调用回调时的返回值，或者初始值 init;cur 表示当前正在处理的数组元素；index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；init 表示初始值。与map、filter相比，reduce最大的优点是可以利用函数调用的返回值。 Array.reduceRight()与reduce相比，该函数从右向左处理。 Array.every()every() 方法检查所有数组值是否通过测试。 Array.some()some() 方法检查是否存在数组值通过了测试。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"JS笔记（八） math/一些语法","slug":"jsNote-8","date":"2021-01-26T03:40:24.000Z","updated":"2021-02-08T04:41:55.850Z","comments":true,"path":"2021/01/26/jsNote-8/","link":"","permalink":"/2021/01/26/jsNote-8/","excerpt":"","text":"math属性Math 属性（常量） JavaScript 提供了可由 Math 对象访问的 8 个数学常量：实例 Math.E // 返回欧拉指数（Euler’s number） Math.PI // 返回圆周率（PI） Math.SQRT2 // 返回 2 的平方根 Math.SQRT1_2 // 返回 1/2 的平方根 Math.LN2 // 返回 2 的自然对数 Math.LN10 // 返回 10 的自然对数 Math.LOG2E // 返回以 2 为底的 e 的对数（约等于 1.414） Math.LOG10E // 返回以 10 为底的 e 的对数（约等于0.434） math对象方法 abs(x) 返回 x 的绝对值 acos(x) 返回 x 的反余弦值，以弧度计 asin(x) 返回 x 的反正弦值，以弧度计 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度 ceil(x) 对 x 进行上舍入 cos(x) 返回 x 的余弦 exp(x) 返回 Ex 的值 floor(x) 对 x 进行下舍入 log(x) 返回 x 的自然对数（底为e） max(x,y,z,…,n) 返回最高值 min(x,y,z,…,n) 返回最低值 pow(x,y) 返回 x 的 y 次幂 random() 返回 0 ~ 1 之间的随机数 round(x) 把 x 四舍五入为最接近的整数 sin(x) 返回 x（x 以角度计）的正弦 sqrt(x) 返回 x 的平方根 tan(x) 返回角的正切 js支持 ?:表达式var voteable = (age &lt; 18) ? &quot;太年轻&quot;:&quot;足够成熟&quot;; js的条件分支/循环与C语言相同提升(hoisting)js可以先使用变量后声明 letlet与var的区别： 通过 var 关键词声明的变量没有块作用域。在块 {} 内声明的变量可以从块之外进行访问。而用let声明的关键词有块作用域。 let更接近与c语言的声明。 var x = 10; // 此处 x 为 10 { var x = 6; // 此处 x 为 6 } // 此处 x 为 6 var x = 10; // 此处 x 为 10 { let x = 6; // 此处 x 为 6 } // 此处 x 为 10 let不会发生“提升”，必须声明后使用 var可以对var重新声明，但其他的重新声明需要自己尝试语法","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"JS笔记（七） 时间","slug":"jsNote-7","date":"2021-01-26T03:40:24.000Z","updated":"2021-02-08T04:41:46.108Z","comments":true,"path":"2021/01/26/jsNote-7/","link":"","permalink":"/2021/01/26/jsNote-7/","excerpt":"","text":"创建日期对象有以下四种方法： new Date() 以当前系统时间创建时间对象 new Date(year, month, day, hours, minutes, seconds, milliseconds) new Date(milliseconds) new Date(date string) new Date(year, month, day, hours, minutes, seconds, milliseconds)这个创建对象的方法可以省略部分值。比如: a = new Data(2020,12,1): 2020年12月1日至少保留两个参数（一个参数的话就是第三个构造方法了）另外，两位数年份会被解析为19XX年 new Date(milliseconds)以1970年1月1日0点（世界标准时间）为起始点。 new Date(date string) |ISO 日期: | “2018-02-19” （国际标准） | |短日期: | “02/19/2018” 或者 “2018/02/19” | |长日期: |”Feb 19 2018” 或者 “19 Feb 2019” | |完整日期: | “Monday February 25 2015” | 首选输入格式为ISO日期：”YYYY-MM-DD”ISO日期也可以写成：只有年：”YYYY”只有年月：”YYYY-MM” 日期获取 getDate() 以数值返回天（1-31） getDay() 以数值获取周名（0-6） getFullYear() 获取四位的年（yyyy） getHours() 获取小时（0-23） getMilliseconds() 获取毫秒（0-999） getMinutes() 获取分（0-59） getMonth() 获取月（0-11） getSeconds() 获取秒（0-59） getTime() 获取时间（从 1970 年 1 月 1 日至今） getUTCDate() 等于 getDate()，但返回 UTC 日期 getUTCDay() 等于 getDay()，但返回 UTC 日 getUTCFullYear() 等于 getFullYear()，但返回 UTC 年 getUTCHours() 等于 getHours()，但返回 UTC 小时 getUTCMilliseconds() 等于 getMilliseconds()，但返回 UTC 毫秒 getUTCMinutes() 等于 getMinutes()，但返回 UTC 分 getUTCMonth() 等于 getMonth()，但返回 UTC 月 getUTCSeconds() 等于 getSeconds()，但返回 UTC 秒 日期设置 setDate() 以数值（1-31）设置日 setFullYear() 设置年（可选月和日） setHours() 设置小时（0-23） setMilliseconds() 设置毫秒（0-999） setMinutes() 设置分（0-59） setMonth() 设置月（0-11） setSeconds() 设置秒（0-59） setTime() 设置时间（从 1970 年 1 月 1 日至今的毫秒数） 例： &lt;script&gt; var d = new Date(); d.setSeconds(30); document.getElementById(&quot;demo&quot;).innerHTML = d; &lt;/script&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"鱼书笔记 第六章 与学习有关的技巧","slug":"DLFromScratch-6","date":"2021-01-24T03:40:24.000Z","updated":"2021-02-08T02:09:15.942Z","comments":true,"path":"2021/01/24/DLFromScratch-6/","link":"","permalink":"/2021/01/24/DLFromScratch-6/","excerpt":"","text":"6.1 参数的更新前面我们采用的参数更新方法是随机梯度下降法(SGD)实际上还有很多更新参数的方法: 以函数f(x,y)=\\frac{x^2}{20}+y^2为例，以下四种参数更新策略的表现情况如下： 6.1.1-6.1.3 SGD及其缺点SGD的策略是：向梯度的方向更新参数 class SGD: def __init__(self, lr=0.01): self.lr = lr def update(self, params, grads): for key in params.keys(): params[key] -= self.lr * grads[key] 但前面的图中，梯度的方向并没有指向损失函数最低的方向，导致其更新效率很低效 6.1.4 MomentumMomentum是动量的意思，Momentum的更新与“速度”有关 v=\\alpha v-\\eta\\frac{\\delta L}{\\delta W}Momentum的更新值受到上次更新的值以及这次的梯度共同影响 也就是说，当梯度方向和上次参数更新不符合，也就是此时更新在发生“迂回”，与SGD相比，Momentum可以使迂回幅度减小 6.1.5 AdaGrad学习率衰减：学习时，学习率逐渐降低的方法AdaGrad发展了学习率衰减的思想，会根据参数来更新学习率 AdaGrad学习率的调整思想：参数更新幅度越大，学习率越小 h=h+\\frac{\\delta L}{\\delta W}\\odot\\frac{\\delta L}{\\delta W}W=W-\\eta\\frac{1}{\\sqrt{h}}\\frac{\\delta L}{\\delta W}h会记录之前所有梯度的平方和，所以学习进行越久，学习率会越接近于0 class AdaGrad: &quot;&quot;&quot;AdaGrad&quot;&quot;&quot; def __init__(self, lr=0.01): self.lr = lr self.h = None def update(self, params, grads): if self.h is None: self.h = {} for key, val in params.items(): self.h[key] = np.zeros_like(val) for key in params.keys(): self.h[key] += grads[key] * grads[key] params[key] -= self.lr * grads[key] / (np.sqrt(self.h[key]) + 1e-7) 6.1.6 AdamAdam参考了AdaGrad和Momentum两种策略 class Adam: &quot;&quot;&quot;Adam (http://arxiv.org/abs/1412.6980v8)&quot;&quot;&quot; def __init__(self, lr=0.001, beta1=0.9, beta2=0.999): self.lr = lr self.beta1 = beta1 self.beta2 = beta2 self.iter = 0 self.m = None self.v = None def update(self, params, grads): if self.m is None: self.m, self.v = {}, {} for key, val in params.items(): self.m[key] = np.zeros_like(val) self.v[key] = np.zeros_like(val) self.iter += 1 lr_t = self.lr * np.sqrt(1.0 - self.beta2**self.iter) / (1.0 - self.beta1**self.iter) for key in params.keys(): #self.m[key] = self.beta1*self.m[key] + (1-self.beta1)*grads[key] #self.v[key] = self.beta2*self.v[key] + (1-self.beta2)*(grads[key]**2) self.m[key] += (1 - self.beta1) * (grads[key] - self.m[key]) self.v[key] += (1 - self.beta2) * (grads[key]**2 - self.v[key]) params[key] -= lr_t * self.m[key] / (np.sqrt(self.v[key]) + 1e-7) #unbias_m += (1 - self.beta1) * (grads[key] - self.m[key]) # correct bias #unbisa_b += (1 - self.beta2) * (grads[key]*grads[key] - self.v[key]) # correct bias #params[key] += self.lr * unbias_m / (np.sqrt(unbisa_b) + 1e-7) 6.2 权重的初始值6.2.1 初始权重可以设为0吗减小权重的值可以抑制过拟合的发生（具体原因在之后的章节会解释）。但初始权重可以设为0吗？ 注：查阅资料了解到，权重可以取负值，但这里“减少权重的值”指的是绝对值还是数值呢？ 答案是：不可以设为0.确切地说，权重不应该设计成一样的值。（起码在梯度下降算法时是这样的） 假设：第一层和第二层之间的权重全部设为0，那么第二层接收到的值是相同的。 那么，当反向传播时，第二层返回的导数也是相同的。 那么，第二层权重的更新幅度也是相同的。 这样就使神经网络失去了意义——神经网络必须要有复杂的权重才有意义。 6.2.2 隐藏层的激活值分布解释一下隐藏层的激活值：就是隐藏层激活函数的输出数据。已经知道，神经网络的权重需要设为满足高斯分布的值。那么标准差应该设为多少呢？ 下面构造的神经网络测试了标准差为1的情况： # coding: utf-8 import numpy as np import matplotlib.pyplot as plt def sigmoid(x): return 1 / (1 + np.exp(-x)) def ReLU(x): return np.maximum(0, x) def tanh(x): return np.tanh(x) #双曲正切函数 input_data = np.random.randn(1000, 100) # 1000个输入数据 node_num = 100 # 每个隐藏层的神经元数目 hidden_layer_size = 5 # 隐藏层数 activations = {} # 结果保存的位置 x = input_data for i in range(hidden_layer_size):#注意这个循环包括了十几行语句哦！ if i != 0: x = activations[i-1] #实验！ w = np.random.randn(node_num, node_num) * 1 # w = np.random.randn(node_num, node_num) * 0.01 # w = np.random.randn(node_num, node_num) * np.sqrt(1.0 / node_num) # w = np.random.randn(node_num, node_num) * np.sqrt(2.0 / node_num) a = np.dot(x, w) # 活性化関数の種類も変えて実験しよう！ z = sigmoid(a) # z = ReLU(a) # z = tanh(a) activations[i] = z # ヒストグラムを描画 for i, a in activations.items(): plt.subplot(1, len(activations), i+1) plt.title(str(i+1) + &quot;-layer&quot;) if i != 0: plt.yticks([], []) # plt.xlim(0.1, 1) # plt.ylim(0, 7000) plt.hist(a.flatten(), 30, range=(0,1)) plt.show() 下面展示的是标准差为1、0.01、\\sqrt{\\frac{1}{n}}、\\sqrt{\\frac{2}{n}}时的激活值分布：（注：n是上一层的神经元数。比如对于第1层的初始值，应使用第0层的神经元数） 梯度消失：这里使用的是sigmoid函数，当激活值偏向0或1时，导数会接近于0，这样就发生了梯度消失问题。图1便是这种情况表现力缺失：如果激活值集中于某几个值，那么大量的神经元就没有存在的意义了，这称为表现力缺失图1、2都有表现力缺失的问题 所以标准差设为\\sqrt{\\frac{1}{n}}、\\sqrt{\\frac{2}{n}}或许是更好的选择 当激活函数为sigmoid或者tanh时，使用标准差为\\sqrt{\\frac{1}{n}}的初始值 当激活函数为ReLU函数时，使用标准差为\\sqrt{\\frac{2}{n}}的初始值 6.3 Batch Normalization前面的初始值设定的目标是：激活值有一定的“广度”那么我们可不可以刻意提高这个“广度”来帮助学习的进行呢？ 由此，出现了BatchNormalization方法Batch Norm有以下优点： 使学习快速进行（可以增大学习率） 不那么依赖初始值 抑制过拟合 Batch Norm的方法是：向神经网络中插入若干个Batch Norm层，该层用于对数据进行正规化。 正规化：使输出数据均值为0、方差为1 \\mu_{B}$$:均值 $$\\sigma^{2}_{B}$$:方差 输出函数： $$x_i=\\frac{x_i-\\mu_B}{\\sqrt{\\sigma^2+\\epsilon}}其中\\epsilon是一个微小的接近0的值，加上它是为了避免分母为0 以下代码用于对batch-norm的评估 # coding: utf-8 import sys, os sys.path.append(os.pardir) # 親ディレクトリのファイルをインポートするための設定 import numpy as np import matplotlib.pyplot as plt from dataset.mnist import load_mnist from common.multi_layer_net_extend import MultiLayerNetExtend from common.optimizer import SGD, Adam (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True) # 学習データを削減 x_train = x_train[:1000] t_train = t_train[:1000] max_epochs = 20 train_size = x_train.shape[0] batch_size = 100 learning_rate = 0.01 def __train(weight_init_std): bn_network = MultiLayerNetExtend(input_size=784, hidden_size_list=[100, 100, 100, 100, 100], output_size=10, weight_init_std=weight_init_std, use_batchnorm=True) network = MultiLayerNetExtend(input_size=784, hidden_size_list=[100, 100, 100, 100, 100], output_size=10, weight_init_std=weight_init_std) optimizer = SGD(lr=learning_rate) train_acc_list = [] bn_train_acc_list = [] iter_per_epoch = max(train_size / batch_size, 1) epoch_cnt = 0 for i in range(1000000000): batch_mask = np.random.choice(train_size, batch_size) x_batch = x_train[batch_mask] t_batch = t_train[batch_mask] for _network in (bn_network, network): grads = _network.gradient(x_batch, t_batch) optimizer.update(_network.params, grads) if i % iter_per_epoch == 0: train_acc = network.accuracy(x_train, t_train) bn_train_acc = bn_network.accuracy(x_train, t_train) train_acc_list.append(train_acc) bn_train_acc_list.append(bn_train_acc) print(&quot;epoch:&quot; + str(epoch_cnt) + &quot; | &quot; + str(train_acc) + &quot; - &quot; + str(bn_train_acc)) epoch_cnt += 1 if epoch_cnt &gt;= max_epochs: break return train_acc_list, bn_train_acc_list # 3.グラフの描画========== weight_scale_list = np.logspace(0, -4, num=16) x = np.arange(max_epochs) for i, w in enumerate(weight_scale_list): print( &quot;============== &quot; + str(i+1) + &quot;/16&quot; + &quot; ==============&quot;) train_acc_list, bn_train_acc_list = __train(w) plt.subplot(4,4,i+1) plt.title(&quot;W:&quot; + str(w)) if i == 15: plt.plot(x, bn_train_acc_list, label=&#39;Batch Normalization&#39;, markevery=2) plt.plot(x, train_acc_list, linestyle = &quot;--&quot;, label=&#39;Normal(without BatchNorm)&#39;, markevery=2) else: plt.plot(x, bn_train_acc_list, markevery=2) plt.plot(x, train_acc_list, linestyle=&quot;--&quot;, markevery=2) plt.ylim(0, 1.0) if i % 4: plt.yticks([]) else: plt.ylabel(&quot;accuracy&quot;) if i &lt; 12: plt.xticks([]) else: plt.xlabel(&quot;epochs&quot;) plt.legend(loc=&#39;lower right&#39;) plt.show() 运行结果： 实线为使用batch norm 。虚线为不使用。 6.4 正则化6.4.1 过拟合过拟合是指：训练出的模型只能拟合训练数据，但不能很好地拟合训练数据之外的数据的情况 发生过拟合的原因有： 模型具有大量参数，表现力强 训练数据少 下面的代码模拟了过拟合的情况:(采用300个训练数据，7×100的神经网络) # coding: utf-8 import os import sys sys.path.append(os.pardir) import numpy as np import matplotlib.pyplot as plt from dataset.mnist import load_mnist from common.multi_layer_net import MultiLayerNet from common.optimizer import SGD (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True) x_train = x_train[:300] t_train = t_train[:300] weight_decay_lambda = 0.1 # ==================================================== network = MultiLayerNet(input_size=784, hidden_size_list=[100, 100, 100, 100, 100, 100], output_size=10, weight_decay_lambda=weight_decay_lambda) optimizer = SGD(lr=0.01) max_epochs = 201 train_size = x_train.shape[0] batch_size = 100 train_loss_list = [] train_acc_list = [] test_acc_list = [] iter_per_epoch = max(train_size / batch_size, 1) epoch_cnt = 0 for i in range(1000000000): batch_mask = np.random.choice(train_size, batch_size) x_batch = x_train[batch_mask] t_batch = t_train[batch_mask] grads = network.gradient(x_batch, t_batch) optimizer.update(network.params, grads) if i % iter_per_epoch == 0: train_acc = network.accuracy(x_train, t_train) test_acc = network.accuracy(x_test, t_test) train_acc_list.append(train_acc) test_acc_list.append(test_acc) print(&quot;epoch:&quot; + str(epoch_cnt) + &quot;, train acc:&quot; + str(train_acc) + &quot;, test acc:&quot; + str(test_acc)) epoch_cnt += 1 if epoch_cnt &gt;= max_epochs: break markers = {&#39;train&#39;: &#39;o&#39;, &#39;test&#39;: &#39;s&#39;} x = np.arange(max_epochs) plt.plot(x, train_acc_list, marker=&#39;o&#39;, label=&#39;train&#39;, markevery=10) plt.plot(x, test_acc_list, marker=&#39;s&#39;, label=&#39;test&#39;, markevery=10) plt.xlabel(&quot;epochs&quot;) plt.ylabel(&quot;accuracy&quot;) plt.ylim(0, 1.0) plt.legend(loc=&#39;lower right&#39;) plt.show() 运行结果图像: 6.4.2 权值衰减很多过拟合是由于权重参数取值过大才发生的。为了抑制这种过拟合，便可以采取权值衰减的方法，即抑制权重参数过大的现象 “学习”是不断调整参数来使损失函数减小的过程。假如把权重参数加进损失函数里，就可以在减小损失函数时兼顾减小权重了。 我们定义L2范数： \\frac{1}{2}\\lambda W^2乘以\\frac{1}{2}的目的是为了在求导时得到规整的值 以下为权值衰减时的随书源码。(仅需注意loss函数中的weight_dacay) # coding: utf-8 import sys, os sys.path.append(os.pardir) # 親ディレクトリのファイルをインポートするための設定 import numpy as np from collections import OrderedDict from common.layers import * from common.gradient import numerical_gradient class MultiLayerNet: &quot;&quot;&quot;全結合による多層ニューラルネットワーク Parameters ---------- input_size : 入力サイズ（MNISTの場合は784） hidden_size_list : 隠れ層のニューロンの数のリスト（e.g. [100, 100, 100]） output_size : 出力サイズ（MNISTの場合は10） activation : &#39;relu&#39; or &#39;sigmoid&#39; weight_init_std : 重みの標準偏差を指定（e.g. 0.01） &#39;relu&#39;または&#39;he&#39;を指定した場合は「Heの初期値」を設定 &#39;sigmoid&#39;または&#39;xavier&#39;を指定した場合は「Xavierの初期値」を設定 weight_decay_lambda : Weight Decay（L2ノルム）の強さ &quot;&quot;&quot; def __init__(self, input_size, hidden_size_list, output_size, activation=&#39;relu&#39;, weight_init_std=&#39;relu&#39;, weight_decay_lambda=0): self.input_size = input_size self.output_size = output_size self.hidden_size_list = hidden_size_list self.hidden_layer_num = len(hidden_size_list) self.weight_decay_lambda = weight_decay_lambda self.params = {} # 重みの初期化 self.__init_weight(weight_init_std) # レイヤの生成 activation_layer = {&#39;sigmoid&#39;: Sigmoid, &#39;relu&#39;: Relu} self.layers = OrderedDict() for idx in range(1, self.hidden_layer_num+1): self.layers[&#39;Affine&#39; + str(idx)] = Affine(self.params[&#39;W&#39; + str(idx)], self.params[&#39;b&#39; + str(idx)]) self.layers[&#39;Activation_function&#39; + str(idx)] = activation_layer[activation]() idx = self.hidden_layer_num + 1 self.layers[&#39;Affine&#39; + str(idx)] = Affine(self.params[&#39;W&#39; + str(idx)], self.params[&#39;b&#39; + str(idx)]) self.last_layer = SoftmaxWithLoss() def __init_weight(self, weight_init_std): &quot;&quot;&quot;重みの初期値設定 Parameters ---------- weight_init_std : 重みの標準偏差を指定（e.g. 0.01） &#39;relu&#39;または&#39;he&#39;を指定した場合は「Heの初期値」を設定 &#39;sigmoid&#39;または&#39;xavier&#39;を指定した場合は「Xavierの初期値」を設定 &quot;&quot;&quot; all_size_list = [self.input_size] + self.hidden_size_list + [self.output_size] for idx in range(1, len(all_size_list)): scale = weight_init_std if str(weight_init_std).lower() in (&#39;relu&#39;, &#39;he&#39;): scale = np.sqrt(2.0 / all_size_list[idx - 1]) # ReLUを使う場合に推奨される初期値 elif str(weight_init_std).lower() in (&#39;sigmoid&#39;, &#39;xavier&#39;): scale = np.sqrt(1.0 / all_size_list[idx - 1]) # sigmoidを使う場合に推奨される初期値 self.params[&#39;W&#39; + str(idx)] = scale * np.random.randn(all_size_list[idx-1], all_size_list[idx]) self.params[&#39;b&#39; + str(idx)] = np.zeros(all_size_list[idx]) def predict(self, x): for layer in self.layers.values(): x = layer.forward(x) return x def loss(self, x, t): &quot;&quot;&quot;損失関数を求める Parameters ---------- x : 入力データ t : 教師ラベル Returns ------- 損失関数の値 &quot;&quot;&quot; y = self.predict(x) weight_decay = 0 for idx in range(1, self.hidden_layer_num + 2): W = self.params[&#39;W&#39; + str(idx)] weight_decay += 0.5 * self.weight_decay_lambda * np.sum(W ** 2) return self.last_layer.forward(y, t) + weight_decay def accuracy(self, x, t): y = self.predict(x) y = np.argmax(y, axis=1) if t.ndim != 1 : t = np.argmax(t, axis=1) accuracy = np.sum(y == t) / float(x.shape[0]) return accuracy def numerical_gradient(self, x, t): &quot;&quot;&quot;勾配を求める（数値微分） Parameters ---------- x : 入力データ t : 教師ラベル Returns ------- 各層の勾配を持ったディクショナリ変数 grads[&#39;W1&#39;]、grads[&#39;W2&#39;]、...は各層の重み grads[&#39;b1&#39;]、grads[&#39;b2&#39;]、...は各層のバイアス &quot;&quot;&quot; loss_W = lambda W: self.loss(x, t) grads = {} for idx in range(1, self.hidden_layer_num+2): grads[&#39;W&#39; + str(idx)] = numerical_gradient(loss_W, self.params[&#39;W&#39; + str(idx)]) grads[&#39;b&#39; + str(idx)] = numerical_gradient(loss_W, self.params[&#39;b&#39; + str(idx)]) return grads def gradient(self, x, t): &quot;&quot;&quot;勾配を求める（誤差逆伝搬法） Parameters ---------- x : 入力データ t : 教師ラベル Returns ------- 各層の勾配を持ったディクショナリ変数 grads[&#39;W1&#39;]、grads[&#39;W2&#39;]、...は各層の重み grads[&#39;b1&#39;]、grads[&#39;b2&#39;]、...は各層のバイアス &quot;&quot;&quot; # forward self.loss(x, t) # backward dout = 1 dout = self.last_layer.backward(dout) layers = list(self.layers.values()) layers.reverse() for layer in layers: dout = layer.backward(dout) # 設定 grads = {} for idx in range(1, self.hidden_layer_num+2): grads[&#39;W&#39; + str(idx)] = self.layers[&#39;Affine&#39; + str(idx)].dW + self.weight_decay_lambda * self.layers[&#39;Affine&#39; + str(idx)].W grads[&#39;b&#39; + str(idx)] = self.layers[&#39;Affine&#39; + str(idx)].db return grads 用于实验的代码不表。运行结果： 虽然预测能力没有明显提高，但过拟合受到了抑制。 6.4.3 DropOut当模型很复杂(神经元数量很多)时，权值衰减法效果也不太明显了。DropOut方法可以在复杂的模型中也有较好效果。思路：Dropout说的简单一点就是：我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征。这篇文章讲得挺有趣的：知乎《什么是dropout》具体是：训练模型时，随机排除一定比例的神经元。而使用模型时，不排除任何神经元，但要乘以训练时的那个排除比例。具体实现不表。 6.5 超参数的验证超参数（如学习率、神经元数量）非常重要，但找到合适的取值比较困难。本节介绍如何尽可能高效地选择超参数。 6.5.1 验证数据切记：一定不要使用训练数据来验证超参数，否则会发生过拟合。 一般选取专门数据来验证超参数，称之为验证数据 训练数据用于学习（调整权重参数） 验证数据用于验证超参数 测试数据用于验证泛化能力（理想情况下，测试数据最好只使用一次） 以下代码用于选择出验证数据： (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True) # 这里还有一个函数，用于把数据打乱，实现不表。 # 検証データの分離 validation_rate = 0.20 validation_num = int(x_train.shape[0] * validation_rate) x_train, t_train = shuffle_dataset(x_train, t_train) x_val = x_train[:validation_num] t_val = t_train[:validation_num] x_train = x_train[validation_num:] t_train = t_train[validation_num:] 6.5.2 超参数的最优化步骤： 1，设定超参数的范围（很粗略就可以，比如10^{-3}~10^{3}） 2, 从设定的超参数范围内随机采样 3，完成学习步骤，再利用验证数据进行超参数验证。但注意，需要把epoch设定得比较小（因为只是要验证超参数，没必要完整地完成学习过程） 4，不断重复2、3步骤，逐渐缩小超参数范围 以上介绍的是一种经验式的做法，更精炼的方法可能是贝叶斯最优化方法 6.5.3 超参数最优化的实现代码如下： 我们设定权值衰减系数为10^{-8}~10^{-4},学习率为10^{-6}~10^{-2} # coding: utf-8 import sys, os sys.path.append(os.pardir) import numpy as np import matplotlib.pyplot as plt from dataset.mnist import load_mnist from common.multi_layer_net import MultiLayerNet from common.util import shuffle_dataset from common.trainer import Trainer (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True) x_train = x_train[:500] t_train = t_train[:500] validation_rate = 0.20 validation_num = int(x_train.shape[0] * validation_rate) x_train, t_train = shuffle_dataset(x_train, t_train) x_val = x_train[:validation_num] t_val = t_train[:validation_num] x_train = x_train[validation_num:] t_train = t_train[validation_num:] def __train(lr, weight_decay, epocs=50): network = MultiLayerNet(input_size=784, hidden_size_list=[100, 100, 100, 100, 100, 100], output_size=10, weight_decay_lambda=weight_decay) trainer = Trainer(network, x_train, t_train, x_val, t_val, epochs=epocs, mini_batch_size=100, optimizer=&#39;sgd&#39;, optimizer_param={&#39;lr&#39;: lr}, verbose=False) trainer.train() return trainer.test_acc_list, trainer.train_acc_list # ハイパーパラメータのランダム探索====================================== optimization_trial = 100 results_val = {} results_train = {} for _ in range(optimization_trial): # 探索したハイパーパラメータの範囲を指定=============== weight_decay = 10 ** np.random.uniform(-8, -4) lr = 10 ** np.random.uniform(-6, -2) # ================================================ val_acc_list, train_acc_list = __train(lr, weight_decay) print(&quot;val acc:&quot; + str(val_acc_list[-1]) + &quot; | lr:&quot; + str(lr) + &quot;, weight decay:&quot; + str(weight_decay)) key = &quot;lr:&quot; + str(lr) + &quot;, weight decay:&quot; + str(weight_decay) results_val[key] = val_acc_list results_train[key] = train_acc_list # グラフの描画======================================================== print(&quot;=========== Hyper-Parameter Optimization Result ===========&quot;) graph_draw_num = 20 col_num = 5 row_num = int(np.ceil(graph_draw_num / col_num)) i = 0 for key, val_acc_list in sorted(results_val.items(), key=lambda x:x[1][-1], reverse=True): print(&quot;Best-&quot; + str(i+1) + &quot;(val acc:&quot; + str(val_acc_list[-1]) + &quot;) | &quot; + key) plt.subplot(row_num, col_num, i+1) plt.title(&quot;Best-&quot; + str(i+1)) plt.ylim(0.0, 1.0) if i % 5: plt.yticks([]) plt.xticks([]) x = np.arange(len(val_acc_list)) plt.plot(x, val_acc_list) plt.plot(x, results_train[key], &quot;--&quot;) i += 1 if i &gt;= graph_draw_num: break plt.show() =========== Hyper-Parameter Optimization Result =========== Best-1(val acc:0.76) | lr:0.009849135982779367, weight decay:8.371126751378459e-08 Best-2(val acc:0.72) | lr:0.008465895756364618, weight decay:5.599344465686115e-06 Best-3(val acc:0.68) | lr:0.007463998530287792, weight decay:5.434999294796928e-06 Best-4(val acc:0.61) | lr:0.0059275054234944596, weight decay:7.217143257829478e-06 Best-5(val acc:0.54) | lr:0.003222780855302866, weight decay:1.5494577799060805e-05 Best-6(val acc:0.44) | lr:0.0030073951251438093, weight decay:1.1708444261159714e-07 Best-7(val acc:0.43) | lr:0.0021005853382527672, weight decay:7.179899890144345e-05 Best-8(val acc:0.41) | lr:0.0031555490566781397, weight decay:1.1570768776264578e-07 Best-9(val acc:0.35) | lr:0.002751737792997746, weight decay:1.0030928213849842e-06 Best-10(val acc:0.35) | lr:0.002530549949995383, weight decay:1.8429003004503172e-06 Best-11(val acc:0.34) | lr:0.003805297187578114, weight decay:2.9763771933588664e-08 Best-12(val acc:0.32) | lr:0.0018044953610692638, weight decay:1.633388106435468e-08 Best-13(val acc:0.31) | lr:0.003299654651673116, weight decay:1.3468893175173874e-05 Best-14(val acc:0.26) | lr:0.0013745036090004102, weight decay:3.349507714291408e-07 Best-15(val acc:0.24) | lr:0.002100802278572699, weight decay:2.5164597992132576e-07 Best-16(val acc:0.22) | lr:0.001228741710146572, weight decay:4.510320818341757e-05 Best-17(val acc:0.21) | lr:0.0015933677262844985, weight decay:4.13572569703448e-08 Best-18(val acc:0.2) | lr:0.0009158024090896935, weight decay:3.5597450057769847e-06 Best-19(val acc:0.19) | lr:0.0003545544553829815, weight decay:3.6634747810567344e-05 Best-20(val acc:0.19) | lr:5.3171828783850735e-05, weight decay:2.296395116949957e-06 实线是验证数据，虚线是训练数据可以看到，best5之前的学习效果都比较好 参照best-1到 best-5的数据，可以将学习率范围缩减到0.001到0.1， 权重衰减参数范围缩减到10^{-7}到10^{-5}","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"鱼书笔记","slug":"鱼书笔记","permalink":"/tags/鱼书笔记/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"JS笔记(一) 基础写法以及数据类型","slug":"jsNote-1","date":"2021-01-24T03:40:24.000Z","updated":"2021-02-08T04:40:36.225Z","comments":true,"path":"2021/01/24/jsNote-1/","link":"","permalink":"/2021/01/24/jsNote-1/","excerpt":"","text":"一、js程序写在哪里？（1）js程序可以写在&lt;script&gt;&lt;/script&gt;标签中&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //alert:弹出警告框 alert(&quot;Hello World!&quot;); //document.write:向body中写入文本 document.write(&quot;强行写入！&quot;); //console.log: 向控制台输出文本。（控制台的内容需要在开发者模式中才能看到） console.log(&quot;这段信息是瞎写的&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 上面展示的是三种基本输出语句。 (2)将js语句写到标签的onclick属性中&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;alert(&#39;想得美&#39;)&quot;&gt;点击获取100￥&lt;/button&gt; &lt;!-- 注意上行代码使用了两种引号 --&gt; &lt;/body&gt; &lt;/html&gt; (3)将js语句写到超链接的的href属性中&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;javascript:alert(&#39;我 秦始皇 打钱！&#39;)&quot;&gt;震惊！公园惊现穿着怪异男子！...&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 但是这样写，超链接就失去了跳转的功能。 (4)写在外部文件中（重要）&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script.js&quot; &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; script.js中的内容： alert(&quot;我是外部文件的js&quot;); script标签一旦用于引入外部文件，就不能用来编写代码了。但可以另创建一个script标签来编写代码 js代码按照在html文件中出现的先后顺序执行。 二、基本语法注释： 格式同c语言语句以分号结尾。 如果不写分号： 浏览器也会自动添加，但这会消耗系统资源。 浏览器有可能加错分号 三、变量变量声明：var a; a = 123; var b = 345; var person = &quot;Bill Gates&quot;, carName = &quot;porsche&quot;, price = 15000;//变量声明可横跨多行 重复声明对变量没有影响。 number最大值大致是1.7e308超过一定限度,就会显示infinity。 infinity是一个字面常量。类型也是number NaN类型也是number，但表示“不是数字”、比如”asd”*”dsa”返回值就是NaN 数字不要输入前导0比如071 有可能被认为是8进制数字 字符串1)字符串内置length属性如：ver str = “hello”;alert(str.length) 2)字符串换行末尾加个反斜杠 document.getElementById(“demo”).innerHTML = “Hello \\ Kitty!”; 字符串可以是对象var firstName = new String(“Bill”)此时firstName是object类型 下列语句： var str1 = “hello”;var str2 = new String(“hello”);str1 == str2;//返回truestr1 === str2;//返回false;（实际上object被强制转换为string）注意若将字符串声明为对象，容易拖慢程序运行 另外，对象之间无法比较var str1 = new String(“hello”);var str2 = new String(“hello”);str1 == str2;//return false; 数组创建方法： ver array[10] = new Array(); &lt;script&gt; var i; var cars = new Array(); cars[0] = &quot;aaa&quot;; cars[1] = &quot;bbb&quot;; cars[2] = &quot;ccc&quot;; for (i=0;i&lt;cars.length;i++) { document.write(cars[i] + &quot;&lt;br&gt;&quot;); } &lt;/script&gt; 输出：aaabbbccc 变量作用域js的全局变量与局部变量类似于c语言不需要任何保留字声明 对象var person={firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566}; 上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。 空格和折行无关紧要。声明可横跨多行： var person={ firstname : &quot;John&quot;, lastname : &quot;Doe&quot;, id : 5566 }; 有点儿像C++中的类！实际上就是类似的东西 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var person= { firstname : &quot;John&quot;, lastname : &quot;Doe&quot;, id : 5566 }; document.write(person.lastname + &quot;&lt;br&gt;&quot;); document.write(person[&quot;lastname&quot;] + &quot;&lt;br&gt;&quot;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 两种寻址方式。一种是类似字典的访问一种是类似结构体的访问 动态数据类型js支持动态数据类型 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h2&gt;JavaScript 数据类型&lt;/h2&gt; &lt;p&gt;JavaScript 拥有动态类型。这意味着相同变量可用于保存不同类型：&lt;/p&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt; var x; // 现在 x 是 undefined var x = 7; // 现在 x 是数值 var x = &quot;Bill&quot;; // 现在 x 是字符串值 document.getElementById(&quot;demo&quot;).innerHTML = x; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"JS笔记（三）","slug":"jsNote-3","date":"2021-01-24T03:40:24.000Z","updated":"2021-02-08T04:40:52.940Z","comments":true,"path":"2021/01/24/jsNote-3/","link":"","permalink":"/2021/01/24/jsNote-3/","excerpt":"","text":"基本运算符加法注意，假如+有字符串参与，那么其他数值会被视为字符串 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;JavaScript 变量&lt;/h1&gt; &lt;p&gt;相加 3 + 5 + &quot;8&quot; 的结果是：&lt;/p&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt; var e = 4; var x = e + e + &quot;8&quot; + e + e; document.getElementById(&quot;demo&quot;).innerHTML = x; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 输出为：8844在“8”之后的数值，是计算之后视为字符串而“8”之前的数值，是视为独立的字符串 除法注意:js中的数字不区分浮点数与整数，除法一律是按浮点数相除 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;+= 运算符&lt;/h1&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt; var x = 7; y = x / 8; document.getElementById(&quot;demo&quot;).innerHTML = y; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 输出：0.875 除以0结果是infinity 严格相等符号：===两边必须是数值和类型完全相同才返回true html事件HTML 事件可以是浏览器或用户做的某些事情。下面是 HTML 事件的一些例子： HTML 网页完成加载 HTML 输入字段被修改 HTML 按钮被点击 js可以在html事件被触发后执行 如:按钮被点击 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;JavaScript 事件&lt;/h1&gt; &lt;button onclick=&quot;document.getElementById(&#39;demo&#39;).innerHTML=Date()&quot;&gt;时间是？&lt;/button&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"JS笔记（二） 函数与对象方法","slug":"jsNote-2","date":"2021-01-24T03:40:24.000Z","updated":"2021-02-08T04:40:43.584Z","comments":true,"path":"2021/01/24/jsNote-2/","link":"","permalink":"/2021/01/24/jsNote-2/","excerpt":"","text":"对象方法类似：类的成员函数。 格式：&lt;函数名&gt; : function(){函数体} &lt;script&gt; var person = { firstName: &quot;John&quot;, lastName : &quot;Doe&quot;, id : 5566, fullName : function() { return this.firstName + &quot; &quot; + this.lastName; } }; document.getElementById(&quot;demo&quot;).innerHTML = person.fullName(); &lt;/script&gt; 函数格式：function &lt;函数名&gt;(){函数体}使用如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;测试实例&lt;/title&gt; &lt;script&gt; function myFunction() { alert(&quot;Hello World!&quot;); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 当然，函数可以有参数和返回值，基础用法和python类似 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;本例调用的函数会执行一个计算，然后返回结果：&lt;/p&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt; function myFunction(a,b){ return a*b; } document.getElementById(&quot;demo&quot;).innerHTML=myFunction(4,3); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; this方法中的this类似this指针如： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;JavaScript &lt;b&gt;this&lt;/b&gt; 关键词&lt;/h1&gt; &lt;p&gt;在本例中，&lt;b&gt;this&lt;/b&gt; 代表 &lt;b&gt;person&lt;/b&gt; 对象。&lt;/p&gt; &lt;p&gt;因为 person 对象“拥有” fullName 方法。&lt;/p&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt; // 创建对象： var person = { firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, id : 678, fullName : function() { return this.firstName + &quot; &quot; + this.lastName; } }; // 显示来自对象的数据： document.getElementById(&quot;demo&quot;).innerHTML = person.fullName(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 事件中的thisthis指代接受事件的html元素 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;JavaScript &lt;b&gt;this&lt;/b&gt; 关键词&lt;/h1&gt; &lt;button onclick=&quot;this.style.display=&#39;none&#39;&quot;&gt;单击来删除我！&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"JS笔记（四） 字符串的方法","slug":"jsNote-4","date":"2021-01-24T03:40:24.000Z","updated":"2021-02-08T04:41:07.082Z","comments":true,"path":"2021/01/24/jsNote-4/","link":"","permalink":"/2021/01/24/jsNote-4/","excerpt":"","text":"访问charAt() 方法charAt() 方法返回字符串中指定下标（位置）的字符串： var str = &quot;HELLO WORLD&quot;; str.charAt(0); // 返回 H charCodeAt() 方法charCodeAt() 方法返回字符串中指定索引的字符 unicode 编码： var str = &quot;HELLO WORLD&quot;; str.charCodeAt(0); // 返回 72 下标访问var str = &quot;HELLO WORLD&quot;; str[0]; // 返回 H 下标访问并不太合理，因为： 不适用 Internet Explorer 7 或更早的版本 它让字符串看起来像是数组（其实并不是） 如果找不到字符，[ ] 返回 undefined，而 charAt() 返回空字符串。 它是只读的。str[0] = “A” 不会产生错误（但也不会工作！） 查找indexOf()返回字符串中指定文本首次出现的索引（位置） &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;JavaScript 字符串方法&lt;/h1&gt; &lt;p&gt;indexOf() 方法返回指定文本首次出现的位置：&lt;/p&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt; var str = &quot;The full name of China is the People&#39;s Republic of China.&quot;; var pos = str.indexOf(&quot;China&quot;); document.getElementById(&quot;demo&quot;).innerHTML = pos; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 输出结果为17（即”China”中的第一个字母”C”的位置）注意该方法是搜索完整的字符串，而不是搜索单个字母 也可以设置起始点格式：indexOf(string, pos) lastIndexOf()与indexOf基本相同，只不过是查找的最后一次出现的位置。返回值仍然是第一个字母的位置 search()与indexOf基本相同不同之处在于： search() 方法无法设置第二个开始位置参数。 indexOf() 方法无法设置更强大的搜索值（正则表达式）。 子串slice()提取字符串的某个部分并在新字符串中返回被提取的部分（也可以省略第二个参数）。 该方法设置两个参数：起始索引（开始位置），终止索引（结束位置）。注意索引可以为负数 var str = &quot;Apple, Banana, Mango&quot;; var res = str.slice(7,13); /* res 的结果是： Banana */ substring() 方法substring() 类似于 slice()。 不同之处在于 substring() 无法接受负的索引。 substr() 方法substr() 类似于 slice()。 不同之处在于第二个参数规定被提取部分的长度。第二个参数也可以为空 转换确切的说，字符串不可以被修改，以下操作仅仅是返回一个新的字符串，而不是修改原字符串 replace()用另一个值替换在字符串中指定的值：实例 str = “Please visit Microsoft!”;var n = str.replace(“Microsoft”, “W3School”); replace只替换首个匹配 replace也可使用正则表达式 大小写转换通过 toUpperCase() 把字符串转换为大写 通过 toLowerCase() 把字符串转换为小写 cancat 连接concat() 方法可用于代替加运算符。下面两行是等效的： var text = &quot;Hello&quot; + &quot; &quot; + &quot;World!&quot;; var text = &quot;Hello&quot;.concat(&quot; &quot;,&quot;World!&quot;); cancat的参数可以是任意多个字符串 split() 将字符串转换为数组：function myFunction() { var str = &quot;a,b,c,d,e,f&quot;; var arr = str.split(&quot;,&quot;); document.getElementById(&quot;demo&quot;).innerHTML = arr[3]; } 返回值为”d”","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"JS笔记（五） 数字的方法","slug":"jsNote-5","date":"2021-01-24T03:40:24.000Z","updated":"2021-02-08T04:41:17.512Z","comments":true,"path":"2021/01/24/jsNote-5/","link":"","permalink":"/2021/01/24/jsNote-5/","excerpt":"","text":"原始值（比如 3.14 或 2016），无法拥有属性和方法（因为它们不是对象）。 但是通过 JavaScript，方法和属性也可用于原始值，因为 JavaScript 在执行方法和属性时将原始值视作对象。 转换为字符串toString() 方法返回值为字符串 var x = 123; x.toString(); // 从变量 x 返回 123 (123).toString(); // 从文本 123 返回 123 (100 + 23).toString(); // 从表达式 100 + 23 返回 123 toExponential() 方法返回值也是字符串，但用科学计数法表示.参数定义小数点后的字符数. var x = 9.656; x.toExponential(2); // 返回 9.66e+0 x.toExponential(4); // 返回 9.6560e+0 x.toExponential(6); // 返回 9.656000e+0 toFixed() 方法toFixed() 返回字符串值，它包含了指定位数小数的数字：实例 var x = 9.656; x.toFixed(0); // 返回 10 x.toFixed(2); // 返回 9.66 x.toFixed(4); // 返回 9.6560 x.toFixed(6); // 返回 9.656000 toPrecision() 方法toPrecision() 返回字符串值，它包含了指定长度的数字：实例 var x = 9.656;x.toPrecision(); // 返回 9.656x.toPrecision(2); // 返回 9.7x.toPrecision(4); // 返回 9.656x.toPrecision(6); // 返回 9.65600 几类全局方法全局方法，即非数字所独有的方法这三种 JavaScript 方法可用于将变量转换为数字： Number() 方法 parseInt() 方法 parseFloat() 方法 Number()x = true; Number(x); // 返回 1 x = false; Number(x); // 返回 0 x = new Date(); Number(x); // 返回 1404568027739 x = &quot;10&quot; Number(x); // 返回 10 x = &quot;10 20&quot; Number(x); // 返回 NaN 注意日期做参数：Number(new Date(“2019-04-15”)); // 返回 1506729600000 上面的 Number() 方法返回 1970 年 1 月 1 日至今的毫秒数。 parseInt() 方法parseInt() 解析一段字符串并返回数值。允许空格。只返回首个数字：实例 parseInt(&quot;10&quot;); // 返回 10 parseInt(&quot;10.33&quot;); // 返回 10 parseInt(&quot;10 20 30&quot;); // 返回 10 parseInt(&quot;10 years&quot;); // 返回 10 parseInt(&quot;years 10&quot;); // 返回 NaN 数字的几个属性： | MAX_VALUE | 返回 JavaScript 中可能的最大数。| | MIN_VALUE | 返回 JavaScript 中可能的最小数。| |NEGATIVE_INFINITY | 表示负的无穷大（溢出返回）。| |NaN |表示非数字值（”Not-a-Number”）。| |POSITIVE_INFINITY | 表示无穷大（溢出返回）。| 数字属性不可用于变量 数字属性属于名为 number 的 JavaScript 数字对象包装器。 这些属性只能作为 Number.MAX_VALUE 访问。 使用 myNumber.MAX_VALUE，其中 myNumber 是变量、表达式或值，将返回 undefined. var x = 6; var y = x.MAX_VALUE; // y 成为 undefined","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"数据库笔记（五）关系演算","slug":"databaseNote-5","date":"2021-01-22T03:40:24.000Z","updated":"2021-02-08T02:09:10.235Z","comments":true,"path":"2021/01/22/databaseNote-5/","link":"","permalink":"/2021/01/22/databaseNote-5/","excerpt":"","text":"元组公式三种原子公式：s\\inRs是R中的一个元组 s[A]\\thetac其中\\theta可以代指各种比较运算符。 s[A]\\thetau[B]以上三种原子公式的逻辑运算都是公式公式之间的逻辑运算也是公式 举例：例如：检索出年龄小于20岁并且是男同学的所有学生。{ t | t\\inStudent and t[Sage] &lt; 20 and t[Ssex] = ‘男’ }再例如：检索出年龄小于20岁或者03系的所有男学生。{ t | t\\inStudent ( t[Sage] &lt; 20 and t[D#] = ‘03’ ) and t[Ssex] = ‘男’ } 关系元组演算举例：已知：学生关系：Student(S#, Sname, Sage, Ssex, Sclass)课程关系：Course(C#, Cname, Chours, Credit, Tname)选课关系：SC(S#, C#, Score) 求学过李明老师讲授所有课程的学生姓名(全都学过) 关系域演算关系域演算和元组演算很类似： 域演算语言 QBE QBE命令 Print 或 P. —— 显示输出操作 Delete或D. —— 删除操作 Insert或I. —— 插入操作 Update或U. —— 更新操作 筛选示意找出年龄小于17岁的所有女同学 示例元素例如：找出年龄小于17岁或者年龄大于20岁的所有同学的姓名这里P.X的理解：P指的是Print，X是示例元素（相当于变量，用于接收结果） 这里上下使用的是两个变量(P.X和P.Y)，互相没有约束，可以认为是“或”但假如上下均使用的P.X,上下就构成了约束，两者就变成了“且”关系 用示例元素完成多个表的连接例如：李明老师教过的所有学生","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"数据库笔记（四）关系代数","slug":"databaseNote-4","date":"2021-01-22T03:40:00.000Z","updated":"2021-02-08T02:09:09.736Z","comments":true,"path":"2021/01/22/databaseNote-4/","link":"","permalink":"/2021/01/22/databaseNote-4/","excerpt":"","text":"关系代数分为： 集合操作：交、并、差、笛卡尔积 纯关系操作：投影、选择、连接、除。 并相容性某些运算、如交、并、差，需要满足并相容性。并相容性需要满足： 关系R和关系S的属性数目必须相同； 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同 交、并、差都很简单、不再赘述。 广义笛卡尔积操作形象地讲就是“拼接”。 选择操作基本写法：\\sigma_{con}(R)=\\left\\{t|t\\in R\\wedge con(t)=true\\right\\} 投影符号：\\prod即把某些属性单独拎出来。投影后的相同元素注意去重。 \\theta-连接操作查询数据结构成绩在90分以上的学生姓名(涉及Student, Course, SC)：这就需要\\theta-连接操作方法是：先进行笛卡尔积，再筛选。(注：形成笛卡尔积是方便理解，实际上这种做法会耗费算力) 有时候，\\theta-连接操作连接的是同一张表，为避免冲突，可以将表重命名（看成两张表） 等值连接： 举例： 自然连接:概念:给定关系R和关系S, R与S的自然连接运算结果也是一个关系，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。 自然连接是一种特殊的等值连接 要求关系R和关系S必须有相同的属性组B(如R,S共有一个属性B1,则B是B1 , 如R, S共有一组属性B1, B2, …, Bn，则B是这些共有的所有属性) R, S属性相同，值必须相等才能连接，即R.B1 = S.B1 and R.B2 = S.B2 … and R.Bn = S.Bn才能连接 要在结果中去掉重复的属性列(因结果中R.Bi 始终是等于S.Bi 所以可只保留一列即可) 自然连接举例： 除操作先看例子吧： 可以看到，R÷S 与 S 的笛卡尔积是R的子集。 外连接思考这个问题：列出所有老师的有关信息，包括姓名，工资，所教课程等。 如果使用普通的\\theta连接，003号教师的信息会丢失。 外连接解决的就是这个问题：当两个表内无法匹配，会生成一个空值。而不是把信息直接丢掉。 外连接= 自然连接(或\\theta连接) + 失配的元组(与全空元组形成的连接)外连接的形式：左外连接、右外连接、全外连接左外连接= 自然连接(或\\theta连接) + 左侧表中失配的元组右外连接= 自然连接(或\\theta连接) + 右侧表中失配的元组全外连接= 自然连接(或\\theta连接) + 两侧表中失配的元组","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"数据库笔记（二）","slug":"databaseNote-2","date":"2021-01-19T03:40:24.000Z","updated":"2021-02-08T06:01:25.477Z","comments":true,"path":"2021/01/19/databaseNote-2/","link":"","permalink":"/2021/01/19/databaseNote-2/","excerpt":"","text":"一、数据库系统的标准结构1、三个层次 用户层（User level）/ 外部层（External level） 概念层(Conceptual level)/逻辑层（Logic level） 内部层（Internal level） 2、模式•模式(Schema)对数据库中数据所进行的一种结构性的描述所观察到数据的结构信息•视图(View)/数据(Data)某一种表现形式下表现出来的数据库中的数据 如：模式可以是:学生登记表( 学号 char(8), 姓名 char(10),性别 Char(2), 出生年月datetime, 入学日期 Datetime, 家庭住址 Char(40) ) 而视图就是那一张表： 3、三级模式两层映像三级模式/三级视图 外部模式 External Schema —— (External) View某一用户能够看到与处理的数据的结构描述 全局模式(Conceptual) Schema —— Conceptual View从全局角度理解/管理的数据的结构描述, 含相应的关联约束体现在数据之间的内在本质联系 Internal Schema —— Internal View存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等 模式一般指全局模式 视图一般指外部视图 两层映像： E-C Mapping：External Schema-Conceptual Schema Mapping——将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换——便于用户观察和使用C-I Mapping：Conceptual Schema-Internal Schema Mapping——将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换——便于计算机进行存储和处理 DBMS的功能在于，让用户确定三级模式，系统自动生成两层映像 4、两个独立性 逻辑数据独立性当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序 物理数据独立性当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式 二、数据模型概念模式是对数据本身结构形式的抽象，数据模型是对模式本身结构的抽象。 数据模型是：数据结构的结构 数据模型举例： 关系模型：表的形式组织数据 层次模型：树的形式组织数据 网状模型：图的形式组织数据 关系模型举例：","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"数据库笔记（一）","slug":"databaseNote-1","date":"2021-01-18T03:40:24.000Z","updated":"2021-02-08T02:09:08.109Z","comments":true,"path":"2021/01/18/databaseNote-1/","link":"","permalink":"/2021/01/18/databaseNote-1/","excerpt":"","text":"一、 什么是数据库？数据库是电子化信息的集合。将信息规范化并使之电子化,形成电子信息‘库’,以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理 表 (table)注意这些术语：列/字段/属性/数据项行/元组/记录数据库就是若干个有关联关系的表的集合 二、什么是数据库系统？数据库系统由5个要素构成 数据库 DB(Database) 数据库管理系统 DBMS(Database management system) 数据库应用 DBAP(Database Application) 数据库管理员 DBA (Database Administrator) 计算机基本系统 数据库管理系统是由数据库管理员使用数据库应用由普通用户使用 数据库系统是一个大的环境！而不是某个软件。但数据库管理系统是一个软件 三、什么是数据库管理系统？1、从用户角度来看，数据库应该能拥有哪些功能：1）创建数据库： 数据库定义功能定义数据库中Table的名称、标题(内含的属性名称及对该属性的值的要求)等 DBMS提供一套数据定义语言(DDL:Data Definition Language)给用户 用户使用DDL描述其所要建立表的格式 DBMS依照用户的定义，创建数据库及其中的Table 2）修改数据库： 数据库操纵功能数据库操纵: 向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等 DBMS提供一套数据操纵语言(DML:Data Manipulation Language)给用户 用户使用DML描述其所要进行的增、删、改、查等操作 DBMS依照用户的操作描述，实际执行这些操作3）控制用户权限：数据库控制功能数据库控制: 控制数据库中数据的使用—-哪些用户可以使用,哪些不可以 DBMS提供一套数据控制语言(DCL:Data Control Language)给用户 用户使用DCL描述其对数据库所要实施的控制 DBMS依照用户的描述，实际进行控制 2、数据库语言1）概念数据定义语言(DDL:Data Definition Language)——DBMS提供给用户,以便用户定义数据格式数据操纵语言(DML:Data Manipulation Language)——DBMS提供给用户,以便用户对数据进行操作数据控制语言(DCL:Data Control Language)——DBMS提供给用户,以便用户对数据进行控制 SQL语言是一种结构化的数据库语言 2）与高级编程语言对比一条数据库语言语句相当于高级语言的一个或多个循环程序如：数据库语言也可以嵌入到高级语言中使用 3、从系统角度，数据库管理系统应该有哪些功能？解释语言并执行 语言编译器：将用数据库语言书写的内容，翻译成DBMS可执行的命令。例如: DDL编译器, DML编译器, DCL编译器等; 查询优化(执行引擎)与查询实现(基本命令的不同执行算法)：提高数据库检索速度的手段；例如贯穿于数据存取各个阶段的优化程序; 数据存取与索引：提供数据在磁盘、磁带等上的高效存取手段。例如:存储管理器，缓冲区管理器，索引/文件和记录管理器等; 通信控制：提供网络环境下数据库操作与数据传输的手段 事务管理：提供提高可靠性并避免并发操作错误的手段 故障恢复：使数据库自动恢复到故障发生前正确状态的手段，例如提供了备份、运行日志操控等实用程序 安全性控制：提供合法性检验，避免非授权非法用户访问数据库的手段 完整性控制：提供数据及数据操作正确性检查的手段 数据字典管理：管理用户已经定义的信息 应用程序接口(API)：提供应用程序使用DBMS特定功能的手段 数据库数据装载、重组等实用程序 数据库性能分析：统计在运行过程中数据库的各种性能数据，便于优化运行","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"C++ 将int变量存储在string中","slug":"save_num_in_str","date":"2021-01-18T03:40:24.000Z","updated":"2021-02-08T04:47:50.100Z","comments":true,"path":"2021/01/18/save_num_in_str/","link":"","permalink":"/2021/01/18/save_num_in_str/","excerpt":"","text":"原理：一个char型占用1Byte一个int型占用4Byte此方法使用四个字符存储一个整型 #include&lt;string&gt; string code(int n) { //存储 string code_; code_.push_back(char(n &amp; 0x000000ff)); code_.push_back(char((n &amp; 0x0000ff00) &gt;&gt; 8)); code_.push_back(char((n &amp; 0x00ff0000) &gt;&gt; 16)); code_.push_back(char(((n &amp; 0xff000000) &gt;&gt; 24) &amp; 0x000000ff)); return code_; } int deCode(string origin) {//恢复 int n = 0; for (int i = 0; i &lt; 4; ++i) { n |= (((int(origin[i])) &amp; 0x000000ff) &lt;&lt; (8 * i)); } return n; }","categories":[{"name":"C++","slug":"C","permalink":"/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"/categories/C/"}]},{"title":"鱼书笔记 第五章 误差反向传播法","slug":"DLFromScratch-5","date":"2021-01-18T02:30:00.000Z","updated":"2021-02-08T02:09:15.340Z","comments":true,"path":"2021/01/18/DLFromScratch-5/","link":"","permalink":"/2021/01/18/DLFromScratch-5/","excerpt":"","text":"误差反向传播法是一种高效地求解权重参数梯度的方法 5.1 计算图这是为了便于理解“误差反向传播法”而引入的一种图。类似“表达式树” 箭头上的数字即为上一步的运算结果。f = [(a x) +(b y)] * c计算图的特点是：每个结点仅需进行“局部运算”，只需要把箭头上传来的数据进行一步处理就ok 以上就是一次正向传播过程计算图的意义在于，可以反向传播高效求导数 5.2 链式法则5.2.1 &amp; 5.2.2 链式法则基本内容涉及到微积分（二）内容🐶已知f(u, v), u(x, y),v(x, y) \\frac{\\delta f} {\\delta x}=\\frac{\\delta f} {\\delta u}\\times\\frac{\\delta u} {\\delta x}+\\frac{\\delta f} {\\delta v}\\times\\frac{\\delta v} {\\delta x}这个规则可用于反向传播求梯度 5.2.3 链式法则和计算图t=x+yz=t^2 注：该图中**2是平方的意思可以看出，反向传播是基于链式法则的 5.3 反向传播对于加法节点，由于加法不会影响导数值，输入信号会原封不动地传入下一个节点 对于乘法节点呢？对于函数f(x,y)=xy \\frac{\\delta f}{\\delta x}=y,\\frac{\\delta f}{\\delta y}=x可见，在反向传播时，导数乘以正向传播时的翻转值 实现反向传播时需要用到正向传播的输入信号，所以需要保存正向传播时的数据 反向传播举例试求下面神经网络的正向传播和反向传播图： （答案在该文章最后） 5.4 简单层的实现乘法节点称为乘法层，加法节点称为加法层 1）乘法层以下为随书源码： # coding: utf-8 class MulLayer: def __init__(self): self.x = None self.y = None def forward(self, x, y): self.x = x self.y = y out = x * y return out def backward(self, dout): dx = dout * self.y dy = dout * self.x return dx, dy 乘法层的使用可以是这样： # coding: utf-8 from layer_naive import *#引入了上面创建的对象 apple = 100 apple_num = 2 tax = 1.1 mul_apple_layer = MulLayer() mul_tax_layer = MulLayer() # forward正向传播 apple_price = mul_apple_layer.forward(apple, apple_num) price = mul_tax_layer.forward(apple_price, tax) # backward 反向传播 dprice = 1 dapple_price, dtax = mul_tax_layer.backward(dprice) dapple, dapple_num = mul_apple_layer.backward(dapple_price) print(&quot;price:&quot;, int(price)) print(&quot;dApple:&quot;, dapple) print(&quot;dApple_num:&quot;, int(dapple_num)) print(&quot;dTax:&quot;, dtax) 2）加法层class AddLayer: def __init__(self): pass def forward(self, x, y): out = x + y return out def backward(self, dout): dx = dout * 1 dy = dout * 1 return dx, dy 使用一个含有加法层和乘法层的计算图： # coding: utf-8 from layer_naive import * apple = 100 apple_num = 2 orange = 150 orange_num = 3 tax = 1.1 # layer mul_apple_layer = MulLayer() mul_orange_layer = MulLayer() add_apple_orange_layer = AddLayer() mul_tax_layer = MulLayer() # forward apple_price = mul_apple_layer.forward(apple, apple_num) # (1) orange_price = mul_orange_layer.forward(orange, orange_num) # (2) all_price = add_apple_orange_layer.forward(apple_price, orange_price) # (3) price = mul_tax_layer.forward(all_price, tax) # (4) # backward dprice = 1 dall_price, dtax = mul_tax_layer.backward(dprice) # (4) dapple_price, dorange_price = add_apple_orange_layer.backward(dall_price) # (3) dorange, dorange_num = mul_orange_layer.backward(dorange_price) # (2) dapple, dapple_num = mul_apple_layer.backward(dapple_price) # (1) print(&quot;price:&quot;, int(price)) print(&quot;dApple:&quot;, dapple) print(&quot;dApple_num:&quot;, int(dapple_num)) print(&quot;dOrange:&quot;, dorange) print(&quot;dOrange_num:&quot;, int(dorange_num)) print(&quot;dTax:&quot;, dtax) 这是前面的答案！⬇⬇⬇⬇ 5.5 激活函数的实现5.51 ReLU(rectified liner unit)层ReLU函数表达式还能想起来吗？ ReLU函数的导数为： \\frac{\\delta y}{\\delta x}=\\left\\{\\begin{aligned}1,x>0\\\\0,x","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"鱼书笔记","slug":"鱼书笔记","permalink":"/tags/鱼书笔记/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"ipython的使用","slug":"ipython","date":"2021-01-15T03:40:24.000Z","updated":"2021-02-08T04:40:23.799Z","comments":true,"path":"2021/01/15/ipython/","link":"","permalink":"/2021/01/15/ipython/","excerpt":"","text":"安装/打开/关闭pip安装 &gt;&gt; pip install ipython 打开： &gt;&gt; ipython 关闭： &gt;&gt; exit 或者快捷键：ctrl + D 功能1 代码补全调用方式： 输入部分字母后按tab键 测试时发现该功能无法使用，运行下面的命令后解决： pip install -U jedi==0.17.2 parso==0.7.1 2 内省运行时可以获得一个对象的全部类型信息。调用方式：输入?信息可能很长，空格键翻页，q键退出输入两个？可以查看对象的源码（只能查看python源码） 3 快捷键： 上下箭头：上一行/下一行 代码 Ctrl + P/上箭头 搜索之前命令历史中以当前输入文本开头的命令 Ctrl + N/下箭头 搜索之后命令历史中以当前输入文本开头的命令 Ctrl + shift + V 粘贴代码或代码块 Ctrl + A 跳转到行头 Ctrl + E 跳转到行尾 4 魔术命令：ipython提供了以%开头的各种特殊命令，称为“魔术命令”如： %hist: 当前ipython下的输入历史 %quickref：显示快速参考 %who: 显示当前命名空间的变量 %debug：进入调试模式（q键退出） %magic: 查看所有的魔术命令 %env：查看系统环境变量 %xdel:删除变量及其引用 5 调试输入%debug进入pdb常用的调试命令如下： h(elp) 帮助信息 u(p) 在函数调用栈中向上移动 d(own) 在函数调用栈中向下移动 n(ext) 单步执行 执行下一步 s(tep) 单步进入当前函数的调用 a(rgs) 查看当前调用函数的参数 l(ist) 查看当前行的上下文参考代码 b(reak) 设置断点 q(uit) 退出","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"数据库笔记（三）关系模型","slug":"databaseNote-3","date":"2021-01-10T03:40:24.000Z","updated":"2021-02-08T02:09:09.223Z","comments":true,"path":"2021/01/10/databaseNote-3/","link":"","permalink":"/2021/01/10/databaseNote-3/","excerpt":"","text":"关系模型的三要素基本结构：表(table)/关系(relation)基本操作：交、并、差、等等等完整性约束： 实体完整性，操作完整性，用户自定义完整性 “表(table)”的定义第一步：定义“域” 第二步：组成“元组”表中的一行就是一个“元组”各个域之间可以自由组合，便形成笛卡尔积 第三步：形成“关系”笛卡尔积中的每个元组未必是有意义的比如。名字可以取值:“关公”，性别可以取值“女”，但是未必有一个这样的数据存在而“关系”是笛卡尔积的子集 一个“域”与表中的“列”不一定一一对应。因此，我们还要定义属性名。 关系模式关系可用R(A1:D1, A2:D2, … , An:Dn)表示，可简记为R(A1, A2, … , An)，这种描述又被称为关系模式(Schema)或表标题(head)R是关系的名字, Ai是属性, Di是属性所对应的域, n是关系的度或目(degree), 关系中元组的数目称为关系的基数(Cardinality)例如下图的关系为一3目关系，描述为家庭(丈夫:男人，妻子:女人, 子女:儿童)或家庭(丈夫，妻子, 子女) 什么是关系关系的特性：列是同质：即每一列中的分量来自同一域，是同一类型的数据不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。 列位置互换性：区分哪一列是靠列名行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分 理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量都相同 也就是说，“关系”和“表”有细微的差别 关系第一范式：属性不可再分特性:又被称为关系第一范式复合属性和多值属性都不满足关系第一范式 一些概念候选码/候选键关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。例如：“学生(S#, Sname, Sage, Sclass)”，S#就是一个候选码，在此关系中，任何两个元组的S#是一定不同的，而这两个元组的Sname, Sage, Sclass都可能相同(同名、同龄、同班)，所以S#是候选码 主码/主键多个候选码中可以选择一个作为主码 主属性与非主属性包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性如“选课”中的S# , C#为主属性，而Sname, Cname, Grade则为非主属性；最简单的，候选码只包含一个属性最极端的，所有属性构成这个关系的候选码，称为全码(All-Key)。比如：关系“教师授课”(T#,C#)中的候选码(T#,C#)就是全码 外码(Foreign Key)/外键关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。 例如“合同”关系中的客户号不是候选码，但却是外码。因它与“客户”关系中的候选码“客户号”相对应。两个关系通常是靠外码连接起来的 关系模型的完整性实体完整性关系的主码中的属性值不能为空值空值：不知道或无意义的值；意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的 参照完整性如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk值，或者为空值意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在例如关系Student在D#上的取值有两种可能:空值，表示该学生尚未分到任何系中若非空值，则必须是Dept关系中某个元组的D#值，表示该学生不可能分到一个不存在的系中 用户自定义完整性用户针对具体的应用环境定义的完整性约束条件如S#要求是10位整数，其中前四位为年度，当前年度与他们的差必须在4以内","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"leetcode 116 三角形最短路径","slug":"leetcode120","date":"2020-12-26T03:40:24.000Z","updated":"2021-02-08T04:45:06.253Z","comments":true,"path":"2020/12/26/leetcode120/","link":"","permalink":"/2020/12/26/leetcode120/","excerpt":"","text":"class Solution { public: int solu_sum; int solu_ans; int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { solu_ans = 0x7fffffff; solu_sum = 0; travel(0,0,triangle); return solu_ans; } int travel(int col, int row, vector&lt;vector&lt;int&gt;&gt;&amp; triangle){ solu_sum += triangle[row][col]; if(row+1 &gt;= triangle.size()) { if(solu_sum &lt; solu_ans) solu_ans = solu_sum; solu_sum -= triangle[row][col]; return 0; } travel(col,row+1,triangle); travel(col+1,row+1,triangle); solu_sum -= triangle[row][col]; return 0; } }; 超时！ class Solution { public: vector&lt;int&gt; sum_tmp; int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { sum_tmp = triangle.back(); for(int k = sum_tmp.size()-1; k &gt; 0; --k){ for(int i = 0; i &lt; k; ++i){ sum_tmp[i] = min(sum_tmp[i],sum_tmp[i+1]); } for(int i = 0; i &lt; k; ++i){ sum_tmp[i] += triangle[k-1][i]; } } return sum_tmp[0]; } };","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"python进阶 面向对象基础语法","slug":"python-note-2","date":"2020-12-24T03:40:24.000Z","updated":"2021-02-08T04:46:48.783Z","comments":true,"path":"2020/12/24/python-note-2/","link":"","permalink":"/2020/12/24/python-note-2/","excerpt":"","text":"1、‘dir’内置函数在Python 中对象几乎是无所不在的，我们之前学习的变量、数据、函数 都是对象 提示 __方法名__ 格式的方法是Python 提供的内置方法/ 属性，稍后会给大家介绍一些常用的内置方法/ 属性 | 序号| 方法名| 类型| 作用|| 01 | __new__ | 方法| 创建对象时，会被自动 调用|| 02 | __init__ | 方法| 对象被初始化时，会被自动 调用|| 03 | __del__ | 方法| 对象被从内存中销毁前，会被自动 调用|| 04 | __str__ | 方法| 返回对象的描述信息，print 函数输出使用| 2、定义简单的类“只包括方法” 在Python 中要定义一个只包含方法的类，语法格式如下：class 类名: def 方法1(self, 参数列表): pass def 方法2(self, 参数列表): pass 方法 的定义格式和之前学习过的函数 几乎一样* 区别在于第一个参数必须是self，“self”相当于c++中的this指针 3、构造/析构/强制转换函数作用就是初始化参数呗！python与c++不同，参数不需要声明，只需要初始化就可以。 class Cat: def __init__(self,new_name): self.name = new_name def __del__(self): print(&quot;%s爬走了&quot; % self.name) def __str__(self): return self.name tom = Cat(&quot;tom&quot;) print(tom.name) tip:身份运算符isis 是判断两个标识符是不是引用同一个对象x is y，类似id(x) == id(y)is not 是判断两个标识符是不是引用不同对象x is not y，类似id(a) != id(b) 4、私有成员类似c++中的private 在实际开发中，对象 的某些属性或方法 可能只希望在对象的内部被使用，而不希望在外部被访问到*私有属性 就是对象 不希望公开的属性*私有方法 就是对象 不希望公开的方法在定义属性或方法时，在属性名或者方法名前 增加两个下划线，定义的就是私有 属性或方法 总结：class Cat: def eat(self): print(&quot;吃吃吃吃吃&quot;) def sleep(self): print(&quot;睡睡睡睡睡&quot;) def __init__(self,new_name): self.name = new_name def __del__(self): print(&quot;%s爬走了&quot; % self.name) def __str__(self): return self.name def __lock(self): print(&quot;%s 被关进小黑屋&quot; %self.name) def lockk(self): self.__lock() tom = Cat(&quot;tom&quot;) tom.eat() tom.sleep() print(id(tom)) print(tom) tom.lockk()","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"python进阶 变量与函数","slug":"python-note-1","date":"2020-12-23T03:40:24.000Z","updated":"2021-02-08T04:46:39.372Z","comments":true,"path":"2020/12/23/python-note-1/","link":"","permalink":"/2020/12/23/python-note-1/","excerpt":"","text":"目标 变量的引用 可变和不可变类型 局部变量和全局变量 1、变量的引用1）引用的概念python中数据是不可变的，将数据赋给变量仅仅是让变量拥有了对数据的引用。 函数id:查看变量对应的数据所在地址 def test(num): print(&quot;-&quot; * 50) print(&quot;%d 在函数内的内存地址是%x&quot; % (num, id(num))) result = 100 print(&quot;返回值%d 在内存中的地址是%x&quot; % (result, id(result))) print(&quot;-&quot; * 50) return result a = test(7) print(&quot;返回值%d 在内存中的地址是%x&quot; % (a, id(a))) 输出结果 -------------------------------------------------- 7 在函数内的内存地址是7fff25577d00 返回值100 在内存中的地址是7fff255788a0 -------------------------------------------------- 返回值100 在内存中的地址是7fff255788a0 在Python 中，函数的实参/返回值 都是靠引用来传递来的 2）、可变类型与不可变类型不可变类型： 内存中的数据不可以修改数字类型：int、bool、float、complex元组类型：tuple字符串类型： str 可变类型: 内存中的数据可以被修改字典： dict列表： list 字典中的key只能使用不可变类型 2、局部变量和全局变量1）函数内修改全局变量函数内部不可以直接修改全局变量的值。如果需要修改，需要加上global关键字 num = 2 def test(): global num num = 5 print(num) test() print(num) 为了保证所有的函数都能够正确使用到全局变量，应该将全局变量定义在其他函数的上方2） 开发时的全局变量 开发时全局变量需要加上特定记号，以避免混淆如：g_ 或者gl_ 的前缀 函数的参数 问题1：在函数内部，针对参数使用赋值语句，会不会影响调用函数时传递的实参变量（的值）？——不会！ 无论传递的参数是可变 还是不可变 只要针对参数使用赋值语句，会在函数内部 修改局部变量的引用，*不会影响到外部变量的引用 问题2：如果传递的参数是可变类型，在函数内部，使用方法 修改了数据的内容，同样会影响到外部的数据 def mutable(num_list): # num_list = [1, 2, 3] num_list.extend([1, 2, 3]) print(num_list) gl_list = [6, 7, 8] mutable(gl_list) print(gl_list) 示例——`+=`* 在`python` 中，列表变量调用`+=` 本质上是在执行列表变量的`extend` 方法，不会修改变量的引用","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"KMP算法","slug":"KMP","date":"2020-12-21T03:40:24.000Z","updated":"2021-02-08T04:42:03.610Z","comments":true,"path":"2020/12/21/KMP/","link":"","permalink":"/2020/12/21/KMP/","excerpt":"","text":"KMP算法不算是多难的算法，它的困难之处在于没有人愿意将它讲清楚 先贴一个感觉比较清楚的教程：KMP算法最浅显理解——一看就明白。这里面的代码相对通俗易懂。 下面是自己实现时的感受：算法的原理还是比较好懂的，但在看别人代码时最最难受的事情就是next数组的确定…不同的人有不同的规则。比如next[i] 的值为 n，有可能是指前i+1个字符有长度为n的重复串，也有可能值前i+1个字符有长度为n+1的字符串，也有可能指前i个字符有长度为n的字符串，某些人还会特别的把next[0]设定为-1…关键的关键，是设定这种规则的人，还往往不把规则说清楚！！！（读这一大串字就够痛苦了，更别说我在阅读他人代码实现时是有多痛苦了☹） 下面的代码依照一般教科书上的官方版本，next[i] = n,表示前i+1个（注意下标从0到i共i+1）字符有长度为n+1的重复串，没有其他特殊约定。 |模式串:|a|b|a|b|a|c|a||next[i]|-1|-1|0|1|2|-1|0| #include&lt;string&gt; #include&lt;iostream&gt; using namespace std; int getNext(string target,int* next) { next[0] = -1; int k = -1; //重复子串长度为k for (int i = 1; i &lt; target.size(); ++i)//考虑：终点是target.size()-1还是target.size()-2 { while (~k &amp;&amp; (target[k + 1] != target[i]))//一定要注意条件~k，否则当没有重复子串时就会无限循环 k = next[k]; //k = next[k]是代码的核心 //循环跳出后，有两种可能：k=-1或target[k+1]==target[i] 这两种情况下，若target[k + 1] == target[i]，字串长度均要+1 if (target[k + 1] == target[i]) ++k; next[i] = k; } return 0; } /*上面这个函数函数处理的效果： 以target = &quot;abbcabbba&quot;为例，它的最终得到的next数组为：{-1,-1,-1,-1,0,1,2,-1,0} */ int KMP(string source, string target) { int* next = new int[target.size()]; getNext(target, next); int i = 0, j = -1;//j为target（模式串）的指针。 while (i &lt; source.size()) { if (source[i] == target[j+1])//若两指针所指元素相等，显然要右移。 { ++i; ++j; } else if (j == -1)//说明没有重合子串，只能让目标串的指针加1 ++i; else j = next[j];//source[i] != target[j]找到j的下一个位置 if (j == target.size()-1)//匹配完毕 break; } if (i &gt;= target.length()) { delete[]next; return i - target.length(); } else { delete[]next; return -1; } } int main() { int next[20]; getNext(&quot;ABACDABABC&quot;, next); for (int i = 0; i &lt; 10; ++i) cout &lt;&lt; &quot; &quot; &lt;&lt; next[i]; cout &lt;&lt; &quot;起始位置：&quot; &lt;&lt; KMP(&quot;abababc&quot;, &quot;bc&quot;); }","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"JLU数据结构 查找","slug":"datastructure-find-1","date":"2020-12-21T03:40:24.000Z","updated":"2021-02-08T04:39:17.936Z","comments":true,"path":"2020/12/21/datastructure-find-1/","link":"","permalink":"/2020/12/21/datastructure-find-1/","excerpt":"","text":"一、对半查找1、伪码：一定注意：该伪码中元素下标为1，2，3…N。不包括0 算法 B (N,R,K.i) /*N个记录，R为表中元素，查找目标为K*/ B1[初始化] s = 1. e = N B2[取中点] i = (s+e)/2 B3[比较并判断] IF e &lt; s THEN RETURN -1.//查找失败 IF Ki &lt; K THEN s = i + 1. IF Ki &gt; K THEN e = i - 1. GOTO B2 2、二叉判定树举例： 对于每一个结点：它的左孩子是它下次查找的起点它的右孩子是它下次查找的终点 3、查找长度分析：对于查找成功的情况。他的长度等于路径长度加1比如以下结点的查找长度： 23 ： 2 12 ： 3对于不成功的结点，它的查找长度等于路径长度比如以下结点： 38 ： 4 57 ： 3 4、平均查找长度计算内路径：查找成功的路径（以圆框为终点的路径）外路径： 查找失败的路径（以方框为终点的路径）设内、外路径总长分别为I_{N}、E_{N} 查找成功的平均比较次数：S_{N}= I+I_{N}/N查找失败的平均比较次数：S_{N}=E_{N}/(N+1) 外路径长总是比内路径长大2N 可以推出S_{N}=(1+1/N)U_N-1 对半查找二叉判定树的高度为log_{2}(e-s+2) (取上界)若不考虑外结点时的二叉树高度为k，则外结点的高度一定为k或k+1 5、一致对半查找对比：二分查找时用到了两个数据来确定区间 起点(s)和终点(e)一致对半查找改用另外两个数据: 中点位置 区间长度。 伪码 算法 U(N,R,K.i) U1.[初始化] i = N/2(取上界). m = N/2 (取下界) /*这里的i指的是中点位置，m是区间长度*/ U2.[比较] IF K &lt; Ki THEN GOTO U3. IF K &gt; Ki THEN GOTO U4. IF k = Ki THEN RETURN i U3.[减小i] IF m=0 THEN RETURN -1. m = m/2(取下界). i = i - m. GOTO U2 U4.[增大i] IF m=0 THEN RETURN -1. m = m/2(取下界). i = i + m. GOTO U2 其实上面算法的m是可以事先准备好。 二、斐波那契查找斐波拉契查找与二分查找相似，但构造树的方法不同 对于k阶斐波拉契树(即包括外结点时层数为k)， 其根节点为T_{k}.这样很容易确定左子树。对于右子树，每个结点的值减去根节点的值仍为斐波拉契树。 伪码: 算法 F(N,R,K.i) F1[初始化]. i = f[m].//m为阶数 f[m]为第m个斐波拉契数 p = f[m-1].//p为左子树的根节点 q = f[m-2].//q为左二子树的根节点，同时也是i与左右儿子结点的差值 F2[比较]. IF K &lt; Ki THEN GOTO F3. IF K &gt; Ki THEN GOTO F4. IF K = Ki THEN RETURN i. F3[i减小]. IF q = 0 THEN TRTURN -1. i = i - q.//转到左子树 t = p. p = q. q = t - q. F4[i增大]. IF q = 0 THEN TRTURN -1. i = i + q.//转到左子树 t = p. p = q. q = t - q. 斐波拉契树中，左子树高度等于右子树高度-1 三、插值查找与二分查找的区别仅在于：二分查找的比较元素 i = (s + e)/2插值查找的比较元素 i = s + (K - Ks)/(Ke - Ks) (取上界) 四、二叉查找树即：中序遍历为升序的树 二叉查找树的删除操作:需要已知：待删结点的父结点 待删结点。 用哪个结点代替被删结点呢？可以使用右子树的最大值。具体是右子树的最左端(左子树的最右端也可以) 五、高度平衡树1、定义平衡系数：左右子树高度之差比如 左子树高m，右子树高n，则平衡系数为m-n高度平衡树：任意子树的平衡系数绝对值小于等于1 二叉树的存储结点中，有一个值为b(root),它指的是该结点的平衡系数 2、平衡二叉树的调整定义如下两个结点：破坏者：平衡二叉树的平衡被破坏时，新插入的结点发现者：距离破坏者最近的、平衡系数绝对值大于1的结点 RR LL LR RL 旋转的方法？无非是调整三个结点的顺序，使链式结构改为树形结构。这三个结点，是从发现者开始向下遍历的连续三个结点。具体可百度。并且还需要调整各个节点的平衡系数。 六、B树详解请戳：《B树、B+树详解》 B树主要用于外查找 1、定义：B树是一个多叉平衡树。一个m阶B树满足： 每个结点有不多于m个孩子 除根节点和叶结点外，每个结点有不少于m/2个孩子 根节点至少有两个孩子(除非本身是叶结点) k个孩子的结点，包含k-1个关键词 所有的叶结点都在同一层 （根节点孩子个数也要小于m）同层的所有元素升序排列可以看到，父结点的每个元素都参与了孩子结点的划分 2、插入插入的前提是找到能插入的位置。查找操作与二叉树类似，不再赘述。找到插入位置后： 若该节点元素个数小于m-1，直接插入； 若该节点元素个数等于m-1，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中； 重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1； B树调整时是从枝到根调整。 3、删除直接删除之后有可能出现： 1） 子树划分问题 2） 当前结点的元素有可能小于m/2 - 1（取上界） 先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放； 七、数字查找注意一下检索表： 八、散列1、散列函数1）压缩法把一串数据压缩成一个。 比如: 各个位数字相加取平均值：h(378) = 6h(‘abc’) = ‘b’ 2) 除法h(K) = K mod MM最好取素数 3） 平方取中h(x) = (x^{2} mod 2^{w})2^{m}/2^{w}这里的w指的是机器字长，也就是数据长度上限。 2^{m}是表长 4） 抽取法也就是仅仅抽取数据中的部分字段作为散列函数的自变量 2、冲突调节1) 拉链法即用链表来存储冲突元素 2） 线性探查法发生冲突时寻找下一顺位如何删除元素呢？可以在每个元素上加一个标志位，标记该位置是否有元素。 九、最优二叉查找树《最优二叉查找树》重点在于这张图(这是前面那篇博客中的)： 十、次优二叉查找树《次优二叉查找树》这个也太简单了我就不写了🐶","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"单源最短路径/多源最短路径","slug":"dijkstra","date":"2020-12-21T03:40:24.000Z","updated":"2021-02-08T02:09:14.794Z","comments":true,"path":"2020/12/21/dijkstra/","link":"","permalink":"/2020/12/21/dijkstra/","excerpt":"","text":"Dijksra 单源最短路原理不再赘述，请参阅Dijkstra算法 本文对该算法进行伪码实现。 一、算法之前的准备：1、选择图的存储方式：邻接表。对于稠密图，也可考虑邻接矩阵。邻接表相对邻接矩阵的优点： 1）节约存储空间。 2）可以自由的将每个邻接链排序处理（比如可以按权值、按结点序号排序），可以进一步优化，降低复杂度。 缺点很显然，邻接表写起来麻烦。（伪码倒是不麻烦） 邻接表的设定：Head:主表Head[v]: 编号为v的点adjacent(Head[v]): 编号为v的点的第一个邻接点指针。 设p = adjacent(Head[v]),则：VerAdj(p): p的结点编号cost(p):&lt;v，VerAdj(p)&gt;p的权重link(p): v的下一个邻接点地址。 2、其他需要存储的内容：1）如何将结点收录到S集合中？设定数组s。s[i] = 1表示i号点已被收录2）如何记录距离？设定数组dist。dist[i] = m 表示i号点与起点距离为m3）如何记录路径？设定数组path。path[i]= j表示路径中i的前一个结点是j。 二、伪码： 算法 DSPath(Head,n,v.dist,path) /*计算v到其他顶点的最短路径，n表示顶点个数*/ DSPath1.[初始化] FOR i = 1 TO n DO { path[i] = -1. dist[i] = max. s[i] = 0. } dist[v] = 0. s[v] = 1. p = adjacent(Head[v]). u = v. DSPath2.[算！] FOR j = 1 TO n DO{ //循环n次。能保证把所有可收录结点均收录 WHILE p ≠ NULL DO{//遍历u结点所有邻接的结点，并更新dist/path值 k = VerAdj(p). IF(s[k] ≠ 1 AND dist[u] +cost(p) ＜ dist[k]) THEN{ dist[k] = dist[u] + cost(v). path[k] = u. } p = link(p). }//u是上一次循环新收录的结点。注意：收录u之后，仅有与u相邻的结点的dist、path值才可能改变。其他点的数据不会改变！ ldist = max. FOR i = 1 TO n DO{ IF (dist[i]&lt;ldist AND s[i]=0) THEN{ ldist = dist[i]. u = i. }//找到dist最小的点并收录。更新u } s[u] = 1. p = adjaecnt(Head[u]). } Floyd 多源最短路定义矩阵A[n][n],A[i][j]为i点到j点的最短距离 A^{(k)}[n][n]$$为经过处理的第k+1个矩阵。 初始状态 $$A^{(-1)}[i][j]$$ = w[i][j]. path[i][j]保存着ij之间路径上、j的前一个顶点. 该图的A[n][n]矩阵如下： ![floyd](https://cdn.jsdelivr.net/gh/ovenKiller/CDN/img/post/2020-12-3-2/1.png) $$A^{(-1)}=\\begin{pmatrix} 0 & max & 1 & max \\\\ max & 0 & 1 & 1 \\\\ 1 & 1 & 0 & max \\\\ max & 1 & max & 0 \\end{pmatrix}A^{(0)}=\\begin{pmatrix} 0 & max & 1 & max \\\\ max & 0 & 1 & 1 \\\\ 1 & 1 & 0 & max \\\\ max & 1 & max & 0 \\end{pmatrix}A^{(1)}=\\begin{pmatrix} 0 & max & 1 & max \\\\ max & 0 & 1 & 1 \\\\ 1 & 1 & 0 & \\textbf{2} \\\\ max & 1 & \\textbf{2} & 0 \\end{pmatrix}A^{(2)}=\\begin{pmatrix} 0 & \\textbf{2} & 1 & \\textbf{3} \\\\ \\textbf{2} & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 2 \\\\ \\textbf{3} & 1 & 2 & 0 \\end{pmatrix}A^{(3)}=\\begin{pmatrix} 0 & 2 & 1 & 3 \\\\ 2 & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 2 \\\\ 3 & 1 & 2 & 0 \\end{pmatrix}","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"JLU数据结构·选择排序","slug":"ssort","date":"2020-12-21T03:40:24.000Z","updated":"2021-02-08T04:47:57.034Z","comments":true,"path":"2020/12/21/ssort/","link":"","permalink":"/2020/12/21/ssort/","excerpt":"","text":"一、直接选择排序流程： 在前n个元素中选择最大值，放在n号位 在前n-1个元素中选择最大值，放在n-1号位 在前n-2个元素中选择最大值，放在n-2号位 。。。。 一定要区分： 直接插入排序与直接选择排序 算法SSort(R,n) FOR j = n TO 2 STEP -1 DO { t = 1.//t用来记录最大值的下标 FOR i = 2 TO j DO{ IF Kt &lt; Ki THEN t = i. } swap(Rj,Rt). } 二、堆排序","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"/tags/排序/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"JLU数据结构 绪论","slug":"datastructure-main","date":"2020-12-20T03:40:24.000Z","updated":"2021-02-08T04:39:38.273Z","comments":true,"path":"2020/12/20/datastructure-main/","link":"","permalink":"/2020/12/20/datastructure-main/","excerpt":"","text":"1、数据的逻辑结构 1) 线性结构 2）非线性结构 有的书会把非线性结构进一步细分，分为 图、树、集合 2、数据的存储结构1）顺序存储存放在连续的存储单元中，如c中的数组 2）链接存储如链表 3）索引存储将数据的指针放在一个数组中。表排序用到了这种方法。 4）散列存储是索引存储的延伸。 3、数据结构的基本操作 ①插入 ②删除 ③修改 ④排序 ⑤查找 4、算法的特征 有限性：一个算法必须在有限步骤内结束 确定性： 每个步骤都必须有精确的定义 输入：可以有0或多个输入 输出：可以有1或多个输出 可行性：算法的所有操作都是可行的，原则上人们用纸笔可以在有限时间内完成它们 5、ADL注意点 所有运算符均为大写字母 输入语句为READ(x) 输出语句为PRINT(x) FOR循环的格式： FOR i = 0 TO n STEP 1 DO 其中n也会被遍历到，STEP可以省略 6、算法的评价 正确性 时间复杂性 占用空间 可读性 鲁棒性","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"JLU数据结构 绪论","slug":"datastructure-tree","date":"2020-12-20T03:40:24.000Z","updated":"2021-02-08T04:39:46.373Z","comments":true,"path":"2020/12/20/datastructure-tree/","link":"","permalink":"/2020/12/20/datastructure-tree/","excerpt":"","text":"一、树的相关定义何为“结点的度”？结点的儿子的个数 何为“结点的次数”同“结点的度” 何为树的度树中结点度的最大值 二叉树的根在第几层？第0层 何为“叶子结点”？度为0的结点 何为“终端结点”？同“叶子结点” 何为“分支结点”？度不为0的结点 何为“结点的深度”？根到结点v的路径长度为v的结点深度根结点的深度为0 何为“结点的高度”？结点v到叶结点的最长路径长度 何为“树的高度”？根结点的高度 二、二叉树的定义及性质二叉树与树的主要区别二叉树是有序的，结点的子树分为左子树和右子树。即使某结点只有一棵子树，也要指明该子树是左子树还是右子树 何为“满二叉树”？高度为k 且结点个数为2^{k+1}-1个结点的二叉树 何为“完全二叉树”？层次遍历时，所有结点的位置能与一棵满二叉树的结点一一对应 具有n个结点的完全二叉树的高度为log_{2}n（取下界） 三、二叉树的遍历1、非递归中根遍历算法 NIO(t) NIO 1.[初始化] CREAT(S). p = t. NIO 2.[入栈] WHILE p ≠ NULL DO { S.push(p). p = left(p) } NIO 3.[栈为空？] IF S 空 THEN RETURN. S.peek(p). S.pop(). NIO 4 [访问p] PRINT(Data(p)). p = right(p) NIO 5[循环] GOTO NIO 2. 非递归后根遍历每个结点需要入栈3次，入栈3次。这样需要记录每个结点被访问的次数。所以建立的堆栈需要有两个值：(p,i). i记录了被访问的次数 当i=0时，左树入栈当i=1时，右树入栈当i=2时，输出 算法 NPO(t) NPO1.[初始化] IF t == NULL THEN RETURN CREAT(S). S.push(t,0). NPO2.[遍历] WHILE S 非空 DO{ S.peek((p,i)). S.pop(). IF i == 0 THEN{ S.push(p,2). IF Left(p) ≠ NULL THEN S.push(Left(p),0). } IF i == 1 THEN{ //略 } IF i == 2 THEN PRINT(Data(p)). } 四、表达式树表达式树主要用在编译器的设计领域该式表示: (a+b)×(c-d) - e 估计不是重点🐶 五、线索二叉树懒得写了戳这里—-&gt;《彻底理解线索二叉树》 六、哈夫曼树何为“扩充二叉树”？当原二叉树中出现空子树时，增加特殊的结点：空树叶。由此组成的二叉树称为扩充二叉树 何为“外通路长度”？根到外结点路径长度之和 何为“加权外通路长度”？emmm…乘以结点的权值它的加权外通路长度为34 何为“最优二叉树”？加权外通路最小的扩充树。 七、树的存储左儿子右兄弟表示法中，二叉树何时表示森林？根节点右子树非空。将根节点的右分支断开，则它的右儿子结点成为新的根，可以重复该操作得到所有的根。 八、并查集设计查找（查找元素所在的集合）与归并（合并两个集合）算法。 其中：查找需要完成路径压缩。归并需要完成小集合向大集合归并。 如何存储？使用Father[n]数组，存储父节点。 如何存储两个集合的秩？根节点的Father值保存它的秩（集合的元素个数）。为了与父节点下标相区别，使用他的相反数。Father[3] = 1: 3号结点的父节点为1Father[5] = -4: 5号结点为根节点，且该集合的秩为4 查找算法：算法 FIND(x) FIND 1.[x是根?] IF Father[x] ≤ 0 THEN RETURN x. FIND 2.[查找并压缩] fx = FIND(Father(x)). Father(x) = fx. RETURN fx. 归并算法算法 UNION(x, y) UNION 1.[找根] fx = FIND(x). fy = FIND(y). UNION 2.[相同根] IF fx == fy THEN RETURN. UNION 3.[归并] IF Father[fx] &lt; Father[fy] THEN Father[fy] = fx. ELSE{ IF Father[fx] == Father[fy] THEN Father[fy] = Father[fy]-1. Father[f] = fy. }","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"JLU数据结构 线性表","slug":"datastructure-linear","date":"2020-12-19T03:40:24.000Z","updated":"2021-02-08T04:39:24.989Z","comments":true,"path":"2020/12/19/datastructure-linear/","link":"","permalink":"/2020/12/19/datastructure-linear/","excerpt":"","text":"一、线性表可用顺序存储/链式存储（链表） 链表结点分为data和next指针两部分循环链表相对于单链表，表尾的next指针指向表头，实际上循环链表没有表头表尾 双向链表结点分为left、data、right三部分 二、栈1、顺序存储注意顺序存储的栈有大小size,栈顶下标top。入栈： 算法 Push(A,item. top) P1.[栈满？] IF top = size THEN (PRINT(&quot;栈满&quot;).RETURN.) P2.[入栈] top = top + 1. A[top] = item. 2、链式存储三、队列1、顺序存储需要定义以下量： front: 队头 （出队位置） rear: 队尾 （入队位置） count：队中元素数量。 Size：队列长度 默认使用循环队列。如队尾右移：rear = (rear + 1) MOD Size 2、链式存储需要定义的量： 队首指针 队尾指针 注意：对空队列进行入队操作或出队后队列变成空队列,需要同时操作rear和front指针 本章中的ADL描述： x\\LeftarrowAVAIL 释放存储空间：AVAIL\\Leftarrowx","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"JLU数据结构 数组和字符串","slug":"datastructure-list","date":"2020-12-19T03:40:24.000Z","updated":"2021-02-08T02:09:13.152Z","comments":true,"path":"2020/12/19/datastructure-list/","link":"","permalink":"/2020/12/19/datastructure-list/","excerpt":"","text":"数组的存储区分：行优先存储/列优先存储c语言中，数组按行优先顺序存储 三元组表存储方式: 顺序存储每个结点的包含的元素：row(b[n])col(b[n])val(b[n]) 十字链表 其中，每行每列均有一个表头，表头用数组存储。行表头（即左边的那一排）为BASEROW[m]列表头（即右边的那一排）为BASECOL[n] 每个结点的存储如下：LEFT指向左边的表头（即行表头）而行表头的LEFT指向该行最右边的非0元素UP同理。COL为该节点所处的列号。对于行表头，COL = -1ROW为该节点所处的行号。对于列表头，ROW = -1 字符串仅需注意KMP算法KMP算法","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"pycharm 基本快捷键","slug":"pycharm-note1","date":"2020-12-19T03:40:24.000Z","updated":"2021-02-08T04:46:29.495Z","comments":true,"path":"2020/12/19/pycharm-note1/","link":"","permalink":"/2020/12/19/pycharm-note1/","excerpt":"","text":"Ctrl + W/ Ctrl + Shift + W扩大选中语句块/缩小选中语句块 Ctrl + D重复当前行的语句 D指的是double也可以选中多行 Ctrl + Y删除当前行（也可选中多行后删除） Alt + Shift + 上箭头将当前行与上一行交换也可以是下箭头 Ctrl + Shift + 上箭头若此时光标在方法的第一行，将当前的方法与前一个方法交换。否则，该快捷键与Alt + Shift + 箭头等效 也可以是下箭头 Ctrl + NumPad-折叠当前方法/对象加号就是展开 Ctrl + Shift + NumPad-折叠当前文件所有方法/对象加号就是展开 Ctrl + Alt + R注意：默认为Ctrl + Alt + T但是该快捷键被QQ流氓占用了，只能自己改成了Ctrl + Alt + R将当前语句块包裹（比如包裹在while语句块中） Ctrl + Shift + Delete去除包裹在当前语句块之外的一层语句与Ctrl + Alt + R互为逆操作 Alt + J查找并选中当前标识符下一次出现的位置可以连续操作 Alt + Shift + J与Alt + J互为逆操作 Ctrl + ALt + Shift + J全选文件中的当前标识符 Shift + F10执行当前代码 Shift + F9调试当前代码（自动执行到断点） Ctrl + F8添加断点 F8单步调试","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"JLU数据结构·快速排序","slug":"quick-sort","date":"2020-12-18T03:40:24.000Z","updated":"2021-02-08T04:47:42.144Z","comments":true,"path":"2020/12/18/quick-sort/","link":"","permalink":"/2020/12/18/quick-sort/","excerpt":"","text":"注意，轴枢元素选取第一个元素。 1、伪码算法分为两部分：1)分划 算法 Partition(R,m,n. j) /*对文件R进行分划，起点为m，终点为n。 返回值为轴枢元素的下标*/ i = m. j = n + 1. K = Km. WHILE i &lt; j DO { i = i + 1. WHILE Ki &lt;= K DO i = i + 1. j = j - 1. WHILE Kj &gt; K DO j = j - 1. IF i &lt; j THEN swap(Ri, Rj). } swap(Rm,Rj). RETURN j. 2)主程序 算法 Qsort(R,m,n.R) IF m &lt; n THEN { j = Partition(R, m, n. R). Qsort(R, m, j-1). Qsort(R, j+1,n). } 最差情况下复杂度 O(N^2)最好情况下复杂度 O(NlogN)","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"/tags/排序/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"Git&Github (一)基本介绍及初始化git","slug":"git-note-1","date":"2020-12-15T03:40:24.000Z","updated":"2021-02-08T02:08:33.248Z","comments":true,"path":"2020/12/15/git-note-1/","link":"","permalink":"/2020/12/15/git-note-1/","excerpt":"","text":"一、版本控制工具应该具备的功能？1）协同修改·多人并行不悖的修改服务器端的同一个文件。2) 数据备份·不仅保存目录和文件的当前状态，还能够保存每一个提交过的历史状态。3) 版本管理·在保存每一个版本的文件信息的时候要做到不保存重复数据，以节约存储空间，提高运行效率4) 权限控制·对团队中参与开发的人员进行权限控制。·对团队外开发者贡献的代码进行审核——Git独有。5)历史记录·查看修改人、修改时间、修改内容、日志信息。·将本地文件恢复到某一个历史状态。6)分支管理·允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。 二、git结构 注意：图示的结构均是保存在本地 暂存区: index file工作区: working tree 三、本地库初始化1、init右键菜单“Git Bash Here”,执行以下操作 user@LAPTOP-VAFH00IB MINGW64 /d/笔记/git&amp;&amp;github $ git init Initialized empty Git repository in D:/笔记/git&amp;&amp;github/.git/ // 初始化完成，创建了.git文件夹 user@LAPTOP-VAFH00IB MINGW64 /d/笔记/git&amp;&amp;github (master) $ ll total 3500 -rw-r--r-- 1 user 197121 3583371 Dec 3 21:00 &#39;Git&amp;GitHub.pdf&#39; // ll命令查看文件夹下的文件。里面没有.git。因为以.开始的文件夹在系统中被隐藏 user@LAPTOP-VAFH00IB MINGW64 /d/笔记/git&amp;&amp;github (master) $ ls -lA total 3504 drwxr-xr-x 1 user 197121 0 Dec 3 21:53 .git/ -rw-r--r-- 1 user 197121 3583371 Dec 3 21:00 &#39;Git&amp;GitHub.pdf&#39; // 使用ls -lA命令查看所有的文件（包括被隐藏的文件） user@LAPTOP-VAFH00IB MINGW64 /d/笔记/git&amp;&amp;github (master) $ ll .git/ total 11 -rw-r--r-- 1 user 197121 23 Dec 3 21:53 HEAD -rw-r--r-- 1 user 197121 130 Dec 3 21:53 config -rw-r--r-- 1 user 197121 73 Dec 3 21:53 description drwxr-xr-x 1 user 197121 0 Dec 3 21:53 hooks/ drwxr-xr-x 1 user 197121 0 Dec 3 21:53 info/ drwxr-xr-x 1 user 197121 0 Dec 3 21:53 objects/ drwxr-xr-x 1 user 197121 0 Dec 3 21:53 refs/ // 查看.git中的文件 自此，本地库已初始化完成，.git文件夹中包括了本地库所需的文件夹与文件。既然.git被系统隐藏，意味着这个文件夹不要随意更改 签名设置形式：用户名+地址如：用户名：tomEmail地址：goodMorning@atguigu.com作用：区分不同开发人员的身份辨析：这里设置的签名和登录远程库(代码托管中心)的账号、密码没有任何关系 tips：命令作用范围。分为项目(仓库)级别和系统用户级别。项目(仓库)级别的命令作用于当前项目，系统用户级别的命令作用于当前电脑系统登陆的用户。 右键菜单“Git Bash Here”,执行以下操作 user@LAPTOP-VAFH00IB MINGW64 /d/笔记/git&amp;&amp;github (master) $ git config user.name maxl // 设置用户名 user@LAPTOP-VAFH00IB MINGW64 /d/笔记/git&amp;&amp;github (master) $ git config user.email hello@123.com // 设置E-mail user@LAPTOP-VAFH00IB MINGW64 /d/笔记/git&amp;&amp;github (master) $ cat .git/config [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true [user] name = maxl email = hello@123.com // 用户签名保存在了.git/config文件下。 tip: linus里的cat命令：将文件中的内容展示到标准输出设备上。 仅需要加上一个 —config 命令就可以设置全局签名。如： git config --globaluser.name ovenkiller user@LAPTOP-VAFH00IB MINGW64 /d/笔记/git&amp;&amp;github (master) $ cd ~ // 打开用户的主目录 user@LAPTOP-VAFH00IB MINGW64 ~ $ pwd /c/Users/user // pwd命令：显示当前目录的绝对路径 user@LAPTOP-VAFH00IB MINGW64 ~ $ ll|less // 分页查看 （注意less关键字起分页查看的作用。q键退出查看） user@LAPTOP-VAFH00IB MINGW64 ~ $ ls -lA|less // 分页查看 显示隐藏文件 user@LAPTOP-VAFH00IB MINGW64 ~ $ cat .gitconfig [user] name = ovenkiller email = light7777777@foxmail.com // 系统级的用户签名保存在这里 级别优先级就近原则： 项目级别优先于系统用户级别，二者都有时采用项目级别的签名 如果只有系统用户级别的签名，就以系统用户级别的签名为准 不允许没有任何签名","categories":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}],"tags":[{"name":"git&github","slug":"git-github","permalink":"/tags/git-github/"}],"keywords":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}]},{"title":"python 小白笔记","slug":"pythonNote","date":"2020-12-15T03:40:24.000Z","updated":"2021-02-08T04:47:05.721Z","comments":true,"path":"2020/12/15/pythonNote/","link":"","permalink":"/2020/12/15/pythonNote/","excerpt":"","text":"range(n)函数函数：range(start, stop[, step]) 参数说明： start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）; stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5 step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1) 返回值range()的返回值是一个range类对象。 print(type(range(5))) # 输出：&lt;class &#39;range&#39;&gt; 该range对象可强制转换为列表： print(list(range(5))) #输出：[0, 1, 2, 3, 4] 更多例子: range(10) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] range(1, 11) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] range(0, 30, 5) # [0, 5, 10, 15, 20, 25] range(0, 10, 3) # [0, 3, 6, 9] range(0, -10, -1) #[0, -1, -2, -3, -4, -5, -6, -7, -8, -9] range(0) #[] range(1, 0) #[] 字符串格式化中的精确度控制对比：“精确到小数点后两位”与“精确度为2”的区别： print(&quot;{:.2}&quot;.format(12.222)) #1.2e+01 print(&quot;{:.2f}&quot;.format(12.222)) #12.22 print(&quot;{:.2}&quot;.format(12.222)) #1.2e+01 print(&quot;{:.3}&quot;.format(12.222)) #12.2 print(&quot;{:.4}&quot;.format(12.222)) #12.22 print(&quot;{:.5}&quot;.format(12.222)) #12.222 print(&quot;{:.6}&quot;.format(12.222)) #12.222 Python之可变参数，参数，*参数参数用于接收普通元素，转化成元组类型。*参数用于接收字典类型，转化成字典 def func(a, *b, **c): print(a) print(b) print(c) func(1,2,3,4,score1=4,score2=7) #1 #(2, 3, 4) #{&#39;score1&#39;: 4, &#39;score2&#39;: 7} 函数的位置传递与名称传递def func(a, b): print(a,end=&quot;,&quot;) print(b) func(1,2) #1,2 func(b=1,a=2)#2,1 函数中哪些变量是全局变量呢？1 函数内用global声明的变量def func(): global a a = 3 a = 4 func() print(a)#3 注意这里的a是在函数之后声明的。(c++这样操作会报错) 2 未真实创建的列表可作全局变量def func(): ls.append(&quot;a&quot;) ls = [1,2] func() print(ls) # [1, 2, &#39;a&#39;] lambda函数&gt;函数名&lt; = lambda&gt;参数&lt;:&gt;表达式&lt; f = lambda a,b: a+b print(f(&quot;aa&quot;,&quot;bb&quot;))#aabb 列表间的赋值，传递的是引用！注意！！ =只能传递一个引用，而不是将列表的内容进行赋值 ls = [1,2,3] lt = ls ls += [4] print(lt) # [1, 2, 3, 4] 即便是重新创建列表也不可以！ ls = [1,2,3] lt = [] lt = ls ls += [4] print(lt) # [1, 2, 3, 4] 如何通过复制创建一个列表？可以用.copy()方法 ls = [1,2,3] lt = [] lt = ls.copy() ls += [4] print(lt) # [1, 2, 3] 删除列表中的元素如何删除列表中下标为2、4、6的元素？ ls = [1,2,3,4,5,6,7] del ls[2:8:2]#注意，ls[8]不会被删除 print(ls) # [1, 2, 4, 6] 字典类型中相同键的不同值di = {&#39;a&#39;:1, &#39;b&#39;:2, &#39;b&#39;:3} print(di[&#39;b&#39;]) #输出是3， 不是2哦 for循环中修改迭代器的值不会对循环产生影响for i in range(5): i = i + 1 print(i) 输出为1、2、3、4、5 ls = [&#39;a&#39;,&#39;e&#39;,&#39;r&#39;,&#39;f&#39;,&#39;3&#39;,&#39;2&#39;] for i in range(len(ls)): del ls[-1] print(i) 输出结果：012345也就是说，len只执行了一次","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"Git&Github (二)基本的添加提交操作","slug":"git-note-2","date":"2020-12-14T03:40:24.000Z","updated":"2021-02-08T02:08:47.766Z","comments":true,"path":"2020/12/14/git-note-2/","link":"","permalink":"/2020/12/14/git-note-2/","excerpt":"","text":"一、基础命令1、git status：功能：查看工作区、暂存区状态 $ git status 窗口反馈内容： On branch master //该工作区在master分支上 No commits yet //本地库无内容。（commits的内容是要提交到本地库里的） Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) Git-GitHub.pdf //工作区 nothing added to commit but untracked files present (use &quot;git add&quot; to track) //暂存区 2、git add：将工作区文件添加到暂存区(跟踪文件) $ git add Git-GitHub.pdf $ git status 窗口显示： On branch master No commits yet Changes to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: Git-GitHub.pdf 暂存区有了新文件。不过提示里的“git rm —cached …” to unstage”是什么意思？ 3、git rm —cached功能：将文件从缓冲区删除 $ git rm --cached Git-GitHub.pdf $ git status 窗口显示： On branch master No commits yet Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) Git-GitHub.pdf nothing added to commit but untracked files present (use &quot;git add&quot; to track) 文件已被从缓存区删除。 4、git commit$ git commit Git-GitHub.pdf 输入这条命令，弹出了如下窗口现在处于vim编辑器中。vim编辑器的简单使用：按“i”键进入Insert模式，编辑文本。(注意：#开始的文字会被屏蔽)编辑结束后，按Esc打开输入栏,再输入”:wq”保存。 $ git add Git-GitHub.pdf $ git commit Git-GitHub.pdf 窗口显示： [master (root-commit) f228a51] My first commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 Git-GitHub.pdf 分析: [master (root-commit) f228a51] My first commit /“root-commit”：由于这是该库的第一次提交，故被分配为root-commit，“My first commit”是commit时所标注的信息/ 1 file changed, 0 insertions(+), 0 deletions(-) /一个文件被修改，新增0行，减少0行。由于这是pdf文件，压根不存在行/ Tip: git commit -m “&lt;提交备注&gt;” [&lt;文件名&gt;]命令可以省去编辑备注的操作 二、新建和修改的区别新建文件文件并提交到本地库： $ vim hello.txt $ git add hello.txt $ git commit hello.txt 窗口显示： warning: LF will be replaced by CRLF in hello.txt. The file will have its original line endings in your working directory [master 36ac922] 测试一下新建文件的提交： 1 file changed, 2 insertions(+) create mode 100644 hello.txt hello.txt内的内容： 试一试新建文件 一共有两行 再修改文件： vim hello.txt hello.txt内的内容： a b c 再次查看状态： $ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: hello.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 注意最后一行：(use “git add” and/or “git commit -a”)修改后的文件也可以直接使用git commit -a提交到缓存区。 $ git add hello.txt $ git commit -m &quot;哈哈&quot; hello.txt 窗口显示： warning: LF will be replaced by CRLF in hello.txt. The file will have its original line endings in your working directory [master 0e1f499] 哈哈 1 file changed, 3 insertions(+), 2 deletions(-) 注意：这次的提交是：[master 0e1f499]。而不是root-commit。因为这不是该工作区的第一次提交","categories":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}],"tags":[{"name":"git&github","slug":"git-github","permalink":"/tags/git-github/"}],"keywords":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}]},{"title":"Git&Github (六) 远程库的操作 && 团队协作","slug":"git-note-6","date":"2020-12-11T03:40:24.000Z","updated":"2021-02-08T02:27:41.556Z","comments":true,"path":"2020/12/11/git-note-6/","link":"","permalink":"/2020/12/11/git-note-6/","excerpt":"","text":"远程库与本地库的交互：库的拥有者：执行push\\pull操作库的参与者：执行clone\\pull操作 1、创建并连接本地库与远程库1) 创建本地库： $ mkdir testGitHub $ cd testGitHub $ git init $ vim 混元功法.txt $ git add , $ git commit -m &quot;武林秘籍&quot; 2) 创建远程库 3)连接远程库与本地库 git remote add将远程库的地址存储在git本地库中 远程库地址： git remote add &lt;别名&gt; &lt;地址&gt; ： 此时 origin 代指 https://github.com/ovenKiller/hunyuanxingyi.git 4) git push$ git push origin master 这一步会将本地库的master分支推送到origin仓库的master分支。 5) git clone将其他仓库克隆到当前文件夹 $ git clone https://github.com/username/hunyuanxingyi.git 6) git fetch格式： git fetch &lt;远程库地址&gt; [&lt;远程库分支名&gt;]功能：拉取远程库内容，但不合并文件。 $ git fetch origin master $ git checkout origin/master fetch 会创建一个FETCH_HEAD指针，指向origin/master。git checkout origin/master 与 git checkout FETCH_HEAD是等效的这样我们就可以查看远程库的内容了。 7) git pullgit pull = git fetch + git mergepull会直接拉取远程库内容并完成合并。 2、团队内协同开发1) 邀请成员假如团队如果不是团队成员，无法对项目进行push操作 github中邀请的页面如下： 2）冲突的处理模式只有在最新版本基础上的修改，才能推送到远程库中。 比如：A先从远程库pull，之后远程库被B修改了，此时A无法再向远程库推送内容。只有重新从远程库拉取内容，才能完成推送，这样避免了远程库被修改后，成员不知道的情况。 3、SSH免密登录ssh-keygen$ ssh-keygen -t rsa -C &lt;githubE-mail地址&gt; $ cd .ssh $ cat rsa.pub ras.pub保存了需要的ssh密钥打开giyhub，在ssh中添加上刚刚生成的那个密钥。这样就能实现ssh免密登录","categories":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}],"tags":[{"name":"git&github","slug":"git-github","permalink":"/tags/git-github/"}],"keywords":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}]},{"title":"Git&Github (三)版本穿梭","slug":"git-note-3","date":"2020-12-10T03:40:24.000Z","updated":"2021-02-08T02:09:21.374Z","comments":true,"path":"2020/12/10/git-note-3/","link":"","permalink":"/2020/12/10/git-note-3/","excerpt":"","text":"1、 git log / git reflog功能：查看日志 1)直接查看$ git log 显示如下：注：查看时: b:上一页 空格:下一页 q：退出 按时间，由近及远显示了日志。注意：HEAD -&gt; master.这里的HEAD指的是目前分支的指针。有点类似于C++面向对象里的this? 这种模式下日志非常多，需要翻页才能查看。 2) git log —pretty=oneline此模式下仅显示哈希值和commit 3) git log —oneline相较于git log —pretty=oneline，此模式的哈希值仅显示一部分。 4) git reflog相较于git log —oneline，此模式增加了HEAD@{9}值，这里的9指的是与Head指针的距离。对于版本回溯，这个参数非常有用。 当版本回退后，git log仅能查看之前的commit.(比如，假如回退到了第一个版本，那么就只显示这一个版本) 而 git reflog始终能查看所有版本。 2、git reset功能：版本前进/后退 方法1： 基于索引值这里的索引值指的是精简后的哈希值。 示例：这时候HEAD指针已经改变，并且查看源文件夹后发现，内容已经回溯到以前的版本。 再次使用git reset可以恢复文件。 ^~：版本前进与回退git reset —hard HEAD^ 回退git reset —hard HEAD~ 前进 也可以控制回退/前进的步幅git reset —hard HEAD^^^回退3个版本git reset —hard HEAD^3 回退三个版本 3、hard / soft / mixed 比较 Tip:查看官方help文件的方法：git help &lt;命令&gt;。比如 git help reset。 查看官方help文件，reset的三个参数解释如下： —softDoes not touch the index file or the working tree at all (but resets the head to &lt;commit&gt;,just like all modes do). This leaves all your changed files “Changes to be committed”, as git status would put it.—mixedResets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action.If -N is specified, removed paths are marked as intent-to-add (see git-add(1)).—hardResets the index and working tree. Any changes to tracked files in the working tree since are discarded. soft: 仅仅在工作区移动HEAD指针 mixed: 移动HEAD指针，重置暂存区 hard: 移动HEAD指针，重置暂存区与工作区 3、rm 删除与恢复注意这是linux的基本命令，不是git命令 $ rm hahaha.txt $ git status 窗口提示： On branch master Changes not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) deleted: hahaha.txt rm仅仅会删除工作区文件，而暂存区和本地库文件仍被保留。 如果想删除暂存区与本地库文件，还需要： $ git add hahaha.txt $ git commit -m &quot;delete hahaha.txt&quot; 此时文件已被完全删除。 但是文件仍可恢复。 只需要使用git reset，回退到未删除之前的版本，文件就会被恢复。恢复文件的前提是：文件在删除之前已经被提交到了本地库 4、 git diff 比较文件差异1)git diff: 比较工作区和暂存区红色为工作区缺少的内容绿色为工作区增加的内容 2)git diff &lt;指针&gt; &lt;文件名&gt;，比较本地库和工作区的差异。也可以不指定文件名，会比较所有的文件。","categories":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}],"tags":[{"name":"git&github","slug":"git-github","permalink":"/tags/git-github/"}],"keywords":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}]},{"title":"Git&Github (四) 分支","slug":"git-note-4","date":"2020-12-10T03:40:24.000Z","updated":"2021-02-08T02:27:43.435Z","comments":true,"path":"2020/12/10/git-note-4/","link":"","permalink":"/2020/12/10/git-note-4/","excerpt":"","text":"1、分支的基本概念1)、什么是分支在版本控制过程中，使用多条线同时推进多个任务 2)、分支的好处 同时并行推进多个功能开发，提高开发效率 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。 2、分支的基本操作 git branch -v 查看分支 git branch &lt;分支名&gt; 新建分支 git checkout &lt;分支名&gt; 切换分支 3、 合并分支1）基本步骤第一步:切换到接受修改的分支上。比如要将hot-fix合并到master上，合并之后要保留的是master，则在合并前需要”git checkout master” 第二步:git merge &lt;分支名&gt;2)解决合并分支后的冲突问题两个分支对同一个文件作出了不同的修改，如何合并？ 假如两处的修改不在文件的同一处，则不会产生矛盾。若不在同一处：此时使用 vim &lt;文件名&gt; 操作查看文件：可以看到文件内容已经被修改，并且git给文件添加了特殊的标记。之后手动调整，调整完毕后执行add、commit操作，完成合并","categories":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}],"tags":[{"name":"git&github","slug":"git-github","permalink":"/tags/git-github/"}],"keywords":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}]},{"title":"Git&Github (五) git 的部分底层机理","slug":"git-note-5","date":"2020-12-10T03:40:24.000Z","updated":"2021-02-08T02:27:42.775Z","comments":true,"path":"2020/12/10/git-note-5/","link":"","permalink":"/2020/12/10/git-note-5/","excerpt":"","text":"1、哈希哈希是一个系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下几个共同点： ①不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定。 ②哈希算法确定，输入数据确定，输出数据能够保证不变③哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大 ④哈希算法不可逆 Git底层采用的是SHA-1算法。哈希算法可以被用来验证文件。原理如下图所示：","categories":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}],"tags":[{"name":"git&github","slug":"git-github","permalink":"/tags/git-github/"}],"keywords":[{"name":"git&github","slug":"git-github","permalink":"/categories/git-github/"}]},{"title":"拓扑排序","slug":"topoorder","date":"2020-12-07T03:40:24.000Z","updated":"2021-02-08T04:48:18.934Z","comments":true,"path":"2020/12/07/topoorder/","link":"","permalink":"/2020/12/07/topoorder/","excerpt":"","text":"一、拓扑排序思路 ①从从网中找到入度为0的点，输出并保存。 ②从网中删除该点。 ③不断重复①、②步骤 二、预先设定：1、如何存储？邻接表。邻接矩阵其实也可以。 2、如何找到入度为0的点？建立一个count数组，记录各个点的入度。通过扫描count数组就可以找到入度为0的点。但是，没有必要每次都扫描所有点。当v被删去时，仅仅需要扫描v邻接的点。 3、如何保存入度为0的点？课本给了一种巧妙的方式：利用模拟栈。建立方法： 初始状态，设定栈顶指针为-1. 扫描counti，当count[i] = 0时，count[i]赋值成top，top赋值为i。此时i便成了栈顶，且count[i]记录了上一个入栈元素的下标。 由于模拟栈是直接建立在count数组上的，需要考虑：模拟栈会不会受到删点操作的干扰？不会，入栈的元素不会是任何边的终点。 模拟栈会不会干扰入度的判断？ 由于0号元素也可能入栈，会不会栈中的“0”会被误认为是入度为0的点？ 答：那就…0号位不存结点 算法 TopoOrder(Head,n) /*拓扑排序，n为结点个数*/ TopoOrder 1.[初始化] FOR i = 1 TO n DO count[i] = 0. FOR i = 1 TO n DO { p = adjacent(Head[i]). WHILE p ≠ NULL DO{ count[VerAdj(p)] = count[VerAdj(p)] + 1. p = link(p). } } TopoOrder 2.[排序] FOR i = 1 TO n DO{//每次循环都会收录一个元素，故循环n次 IF top = -1 THEN{ PRINT(&quot;There is a cycle in network&quot;). RETURN. } j = top. PRINT(j).//输出栈顶元素 top = count[top]. p = adjacent(Head[j]). WHILE p ≠ NULL DO{ count[VerAdj(p)] = count[VerAdj(p)] - 1. IF count[VerAdj(p)] == 0 THEN{ count[k] = top. top = k. } p = link(p). } } 三、序列的改进 如上图。假如找到1号点后立即删除，2号点入度变为0，会导致2号点的拓扑序列先于3、4号点。这样好吗？这样不好。假如可以同时访问多个点——3、4号点应该是与1号点平级的，访问次序应该先于2号点。 如何存储度为0的结点呢？应该用队列而不是栈。代码略了 因为懒🤤","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"/tags/拓扑排序/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"Prim 求最优生成树","slug":"Prim","date":"2020-12-04T03:40:24.000Z","updated":"2021-02-08T04:46:13.611Z","comments":true,"path":"2020/12/04/Prim/","link":"","permalink":"/2020/12/04/Prim/","excerpt":"","text":"Prim算法是典型的贪心算法 第一步：任选1个结点，作为子图G’的第一个结点。 第二步：找出与G’相连、且不会与G’构成回路，且权值最小的边，并将该边及相邻结点收入G’。该步骤不断重复 一、伪码前的基本设定1、图的存储方式：邻接矩阵edgeedge[i][j] = w 表示i与j之间有一条权重为w的边 2、如何存储G’？设定一个TE数组，该数组存储着所有收入树中的边。TE[i]: 被收入树的第i个边head(TE[i]): 边TE[i]的起点tail(TE[i]): 边TE[i]的终点cost(TE[i]): 边TE[i]的权重 3、如何每次找到不会形成回路、且权值最小的边？设定数组closedge,closedge[i]表示序号为i的顶点。Vex(closedge[i])表示i号顶点的所有邻接点中，在G’中且边的权重最小的点。Lowcost(closedge[i])表示i该边的长度 当i被收入G’中后：Vex(closedge[i]) = -1Lowcost(closedge[i]) = 0 这样，通过遍历closedge数组，就可以找出未被收入G’且距离最小的点。 closedge表如何更新？当v被收入G’中后，与v相邻的点需要被更新 伪码： 算法Prim() /*构造最小生成树的Prim算法*/ Prim 1.[以顶点1为初始顶点，初始化数组closedge] FOR i = 1 TO n DO{ Lowcost(closedge[i]) = egde[1][i]. Vex(closedge[i]) = 1. } Vex(closedge[1]) = -1. count = 1//count用于对G&#39;中节点数量进行计数 Prim 2.[构造图的最小支撑树] FOR i = 2 TO n DO{ // 每次循环均能收录一个结点 min = max. v = 0.//待选中的点 FOR j = 1 TO n DO{ //遍历寻找权值最小的边 IF( Vex(closedge[j] ≠ -1) AND Lowcost(closedge[j]) &lt; min&gt;) THEN{ v = j. min = Lowcost(closedge[j]). } } } IF v == 0 THEN RETURN.//说明图不连通，无法建立树 //v是已经选中的点，现在需要把它收入G&#39;中 head(TE[count]) = Vex(closedge[v]). tail(TE[count]) = v. cost(TE[count]) = Lowcost(closedge[v]). count = count + 1. //将v标记为已收入状态。 Lowcost(closedge[v]) = 0. Vex(closedge[v]) = -1. //当v被收入后，与v相邻的点的值也需要被更新。 FOR j = 1 TO n DO{ IF(Vex(closedge[j]≠-1 AND edge[v][j] &lt; Lowcost(closedge[j]))) THEN { Lowcost(closedge[j]) = edge[v][j]. Vex(closedge[j]) = v. } }","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"JLU数据结构·插入排序","slug":"insertSort","date":"2020-12-02T03:40:24.000Z","updated":"2021-02-08T04:40:16.178Z","comments":true,"path":"2020/12/02/insertSort/","link":"","permalink":"/2020/12/02/insertSort/","excerpt":"","text":"一、直接插入排序基础版：伪码： 算法 InsertSort(R,n.R) /*排列n个记录，使之对应的关键字非递减排列*/ FOR j=2 TO n DO { i ← j-1. //每次循环将R[j]插入到R[1],...R[j-1]中 K ← K[j]. R ← R[j]. WHILE i &gt; 0 AND K &lt; K[i] DO { R[i+1]←R[i]. i ← i-1. }. R[i+1] ← R } 改进版本A基础版本算法有一个缺点：需要随时判断i是否大于0.我们可以通过在表头设定一个非常小的值来避免这步判断。 需要多小呢？比所有值都小就可以了！ 算法 InsertSortA(R,s,e.R) /*对记录R[s]、R[s+1]、R[s+2]、R[s+3]、R[e]进行排序 令R[s-1]对应的K[s-1] ≤ min{K[i] | s ≤ i ≤ e }*/ FOR j=s+1 TO e DO { i ← j-1. //每次循环将R[j]插入到R[1],...R[j-1]中 K ← K[j]. R ← R[j]. WHILE K &lt; K[i] DO { R[i+1]←R[i]. i ← i-1. }. R[i+1] ← R } 二、希尔排序先举简单的例子： 对长度为n的数组进行排序： step 1: 选取增量为8分组。比如R[1]、R[9]、R[17]为1组，R[2]、R[10]、R[19]为2组…每一组内通过简单插入排序保证有序 step 2: 选取增量4来分组。 step 3: 选取增量2来分组 step 4：选取增量1来分组。 经过以上四步，排序完成该例子中，选取的增量序列为8、4、2、1 算法 ShellSort(R,n.R) /*排列n个记录，使之对应的关键字非递减排列*/ d ← n/2 //（取下界） WHILE d &gt; 0 DO { FOR j=d TO n DO { i ← j-d. K ← K[j]. R ← R[j]. WHILE i &gt; 0 AND K &lt; K[i] DO { R[i+d]←R[i]. i ← i-d. }. R[i+d] ← R } d ← n/2 //（取下界） } 这个递增序列是相当低效的。 长度序列也可以有以下选择：1、 2^{k}-1 ，最坏复杂度O(n^(3/2))2、 形如2^{p}3^{q}且小于n的所有正整数的集合。{2^{p}3^{q}|2^{p}3^{q} &lt; n} 则希尔算法的复杂度为O(n{({log}_{2}n)}^2)3、目前已知的最好序列是{1、4、10、23、57、132、301、701、1750}。使用该序列时时间效率优于堆排序、插入排序。小规模数据优于快排，大规模数据不如快排。(也就是说这可能是处理小规模数据最好的算法)","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"python在Excel中的应用（一）","slug":"pyexcel1","date":"2020-12-02T03:40:24.000Z","updated":"2021-02-08T03:13:05.584Z","comments":true,"path":"2020/12/02/pyexcel1/","link":"","permalink":"/2020/12/02/pyexcel1/","excerpt":"","text":"一、 创建excel文件创建空文件: import pandas as pd df = pd.DataFrame() df.to_excel(&#39;D:/pyExcel/tmp.xlsx&#39;) 给表格加点儿内容: import pandas as pd df = pd.DataFrame({&#39;ID&#39;:[1,2,3,4],&#39;name&#39;:[&#39;liu&#39;,&#39;oio&#39;,&#39;sda&#39;,&#39;fss&#39;]}) df.to_excel(&#39;D:/pyExcel/tmp.xlsx&#39;) 文件内容： ID name 0 1 liu 1 2 oio 2 3 sda 3 4 fss 注意，这里第一列自动添加了0、1、2、3 作为索引如何让ID当做索引呢？ import pandas as pd df = pd.DataFrame({&#39;ID&#39;:[1,2,3,4],&#39;name&#39;:[&#39;liu&#39;,&#39;oio&#39;,&#39;sda&#39;,&#39;fss&#39;]}) df = df.set_index(&#39;ID&#39;) df.to_excel(&#39;D:/pyExcel/tmp.xlsx&#39;) 文件内容如下 ID name 1 liu 2 oio 3 sda 4 fss 二、读取excel文件1、读取与简单查看以选修课表为例： import pandas as pd opCourse = pd.read_excel(&#39;D:/pyExcel/jlucourse.xlsx&#39;) print(opCourse.head(3)) #查看前3行 print(&quot;======================&quot;) print(opCourse.tail(3)) #查看最后三行 输出结果： 吉林大学中心校区2020-2021学年第1学期普通教育公选课开课计划表 Unnamed: 1 Unnamed: 2 ... Unnamed: 7 Unnamed: 8 Unnamed: 9 0 序号 开课单位 公选课课程名称 ... 上课时间 上课地点/选课 人数 起止周 1 1 统战部 中国民主党派与社会发展 ... 25 李四光二阶 /300 8-17 2 2 哲学社会学院 哲学通论 ... 45 逸夫二阶/270 8-17 [3 rows x 10 columns] ====================== 吉林大学中心校区2020-2021学年第1学期普通教育公选课开课计划表 Unnamed: 1 ... Unnamed: 8 Unnamed: 9 163 158 公共外语教育学院 ... 逸夫十五阶/300 8-16双 164 NaN NaN ... NaN NaN 165 NaN NaN ... NaN NaN [3 rows x 10 columns] 注意:excel第一行的数据被视为key值，不算是行数。前三行其实是2-4行。并且无论输出哪几行，第一行的索引值都会被输出问题是：第一行明明是表格的名字啊，key值其实在第二行。如何处理呢？ 2、首行“脏数据”的处理。首先，假如第一行是空行，则不需要任何操作，程序会自动把第二行作为索引 但假如不是空行,可以在读取时设置header参数： import pandas as pd opCourse = pd.read_excel(&#39;D:/pyExcel/jlucourse.xlsx&#39;,header=1) print(opCourse.head(3)) 输出： 序号 开课单位 公选课课程名称 教师信息 卡号 课程信息（包括学时/学分/类别） 课程编号 上课时 间 上课地点/选课人数 起止周 0 1 统战部 中国民主党派与社会发展 马忠正 216251 30/2/2 gx02250210 25 李四光二阶 /300 8-17 1 2 哲学社会学院 哲学通论 杨晓 607334 30/2/2 tg01110201 45 逸夫二阶/270 8-17 2 3 哲学社会学院 西方哲学 赵雄峰 600480 30/2/2 tg01110203 45 逸夫七阶/300 8-17 这里注意:excel的行数是从1开始的，python中是从0开始，header=1指的是第2行 这时首行数据相当于被遗弃了，假如将DataFrame对象输出为excel文件，会发现首行数据被删除了。 3、在无key值的列表里添加key值假如数据是如下这样的呢? import pandas as pd opCourse = pd.read_excel(&#39;D:/pyExcel/jlucourse.xlsx&#39;,header=None) print(opCourse.columns) #输出为 Int64Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=&#39;int64&#39;) opCourse.columns = [&#39;序号&#39;,&#39;开课单位&#39;,&#39;公选课课程名称&#39;,&#39;教师信息&#39;,&#39;卡号&#39;,&#39;课程信息（包括学时/学分/类别）&#39;,&#39;课程编号&#39;,&#39;上课时间&#39;,&#39;上课地点/选课人数&#39;,&#39;起止周&#39; ] opCourse.to_excel(&#39;D:/pyExcel/jlucourse(1).xlsx&#39;) 得到的新表格： 这样，我们添加上了key值，只是表格间距看起来有点儿挤🙄但是，最左侧又多出来一列index值。实际上，在用pandas导入excel表格时，假如不指定index，会自动生成新的index。这些index假如再次存入excel，会在新的文件中占据一列。 假如文件中存在index： import pandas as pd opCourse = pd.read_excel(&#39;D:/pyExcel/jlucourse.xlsx&#39;,header=1,index_col=&#39;序号&#39;) print(opCourse.head()) 假如文件中不存在index名，可以在设置header后再设置index。 import pandas as pd opCourse = pd.read_excel(&#39;D:/pyExcel/jlucourse.xlsx&#39;,header=None) opCourse.columns = [&#39;序号&#39;,&#39;开课单位&#39;,&#39;公选课课程名称&#39;,&#39;教师信息&#39;,&#39;卡号&#39;,&#39;课程信息（包括学时/学分/类别）&#39;,&#39;课程编号&#39;,&#39;上课时间&#39;,&#39;上课地点/选课人数&#39;,&#39;起止周&#39; ] opCourse.set_index(&#39;序号&#39;,inplace=True) #与opCourse = opCourse.set_index(&#39;序号&#39;)的效果相同 opCourse.to_excel(&#39;D:/pyExcel/jlucourse(4).xlsx&#39;) 三、 行列操作1、SeriesSeries可以用于构建dataframe import pandas as pd s2 = pd.Series([1,2,3],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],name = &#39;A&#39;) print(s2) 输出结果： a 1 b 2 c 3 Name: A, dtype: int64 import pandas as pd s1 = pd.Series([1,2,3],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],name = &#39;A&#39;) s2 = pd.Series([10,20,30],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],name = &#39;B&#39;) s3 = pd.Series([100,200,300],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],name = &#39;C&#39;) df = pd.DataFrame({s1.name:s1,s2.name:s2,s3.name:s3}) print(df) A B C a 1 10 100 b 2 20 200 c 3 30 300 以字典的形式创建，index为列、name为行。 import pandas as pd s1 = pd.Series([1,2,3],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],name = &#39;A&#39;) s2 = pd.Series([10,20,30],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],name = &#39;B&#39;) s3 = pd.Series([100,200,300],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],name = &#39;C&#39;) df = pd.DataFrame([s1,s2,s3]) print(df) a b c A 1 2 3 B 10 20 30 C 100 200 300 以列表的形式创建，name为列、index为行 2、如何读取特定区块的数据？对于下面这样的表格该怎么处理？ import pandas as pd df = pd.read_excel(&#39;D:/pyExcel/tmp1.xlsx&#39;,skiprows=6, usecols=&#39;D:F&#39;,index_col=None) # skiprows=6: 跳过前6行 # usecols=&#39;D:F&#39; 使用D到F列。 usecols=&#39;D,E,F&#39;也是同样的效果 print(df) ID score data 0 1 NaN NaN 1 2 NaN NaN 2 3 NaN NaN 3 4 NaN NaN 4 5 NaN NaN 5 6 NaN NaN 6 7 NaN NaN 8 9 NaN NaN 9 10 NaN NaN 10 11 NaN NaN 11 12 NaN NaN 注意两点： usecols=’D:F’，包括了F列，这和python切片有区别skiprows=6和header=6的应用效果是不是相同的呢？…(这个问题以后要注意)读入时index_col设为None，而没有设成’ID’,这是为了便于之后对’ID’进行操作","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"/tags/pandas/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"小tip:对STL中的queue执行清空操作","slug":"clear-for-queue","date":"2020-11-21T03:00:24.000Z","updated":"2021-02-08T04:38:53.613Z","comments":true,"path":"2020/11/21/clear-for-queue/","link":"","permalink":"/2020/11/21/clear-for-queue/","excerpt":"","text":"STL中的queue没有clear(清空队列)操作。这里可以用到swap高效完成该功能： //假设已经定义了 queue&lt;int&gt; Q; queue&lt;int&gt;tmp; tmp.swap(Q); 这样Q的内容就被清空了。","categories":[{"name":"C++","slug":"C","permalink":"/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"STL","slug":"STL","permalink":"/tags/STL/"}],"keywords":[{"name":"C++","slug":"C","permalink":"/categories/C/"}]},{"title":"leetcode105 从前序与中序遍历序列构造二叉树","slug":"leetcode105","date":"2020-11-14T03:40:24.000Z","updated":"2021-02-08T04:44:14.432Z","comments":true,"path":"2020/11/14/leetcode105/","link":"","permalink":"/2020/11/14/leetcode105/","excerpt":"","text":"原题传送门—&gt;&gt; Given preorder and inorder traversal of a tree, construct the binary tree.Note:You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { //1 根据先序遍历确定根节点，再在中序遍历中找到该节点 if(preorder.empty()) return NULL; int leftSize = find(inorder.begin(), inorder.end(), preorder.front()) - inorder.begin();//左子树长度 TreeNode* base = new TreeNode(preorder.front()); vector&lt;int&gt; leftPreorder(preorder.begin()+1, preorder.begin()+1+leftSize);//左子树的先序遍历序列 vector&lt;int&gt; leftInorder(inorder.begin(), inorder.begin()+leftSize);//左子树的中序遍历序列 vector&lt;int&gt; rightPreorder(preorder.begin()+1+leftSize, preorder.end());//右子树的先序遍历序列 vector&lt;int&gt; rightInorder(inorder.begin()+1+leftSize, inorder.end());//右子树的中序遍历序列 base-&gt;left = buildTree(leftPreorder,leftInorder); base-&gt;right = buildTree(rightPreorder, rightInorder); return base; } }; tip: 临时变量不可作为引用类型参数的实参。 比如这句代码： base-&gt;left = buildTree(leftPreorder,leftInorder);我一开始其实是写成 base-&gt;left = buildTree(vector(preorder.begin()+1, preorder.begin()+1+leftSize),leftInorder(inorder.begin(), inorder.begin()+leftSize)); 这样是会报错的。","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"leetcode 106 由中序和后序遍历序列建立树","slug":"leetcode106","date":"2020-11-14T03:40:24.000Z","updated":"2021-02-08T04:44:22.027Z","comments":true,"path":"2020/11/14/leetcode106/","link":"","permalink":"/2020/11/14/leetcode106/","excerpt":"","text":"原题传送门—&gt;&gt; Given inorder and postorder traversal of a tree, construct the binary tree.Note:You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7]postorder = [9,15,7,20,3]Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 和105题如出一辙，不过这次我换种方式，避免了反复生成vector对象。并且这种方式比较容易改成c代码吧 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { return buildTree(inorder, 0, inorder.size(), postorder, 0, postorder.size()); } /*这几个参数分别是：中序遍历序列，中序遍历起点，中序遍历终点（不包含该点） 、后序遍历序列、起点、终点*/ TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, int s_in, int e_in, vector&lt;int&gt;&amp; postorder, int s_po, int e_po) { if(s_in &gt;= e_in) { return NULL; } TreeNode* root = new TreeNode(postorder[e_po - 1]); int leftSize = find(inorder.begin()+s_in, inorder.begin()+e_in, postorder[e_po - 1]) - inorder.begin() - s_in; root-&gt;left = buildTree(inorder, s_in, s_in+leftSize, postorder, s_po, s_po+leftSize); root-&gt;right = buildTree(inorder, s_in+1+leftSize, e_in, postorder, s_po+leftSize,e_po-1); return root; } };","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"leetcode 116 填充树中每个节点的next指针","slug":"leetcode116","date":"2020-11-13T03:40:24.000Z","updated":"2021-02-08T04:44:58.947Z","comments":true,"path":"2020/11/13/leetcode116/","link":"","permalink":"/2020/11/13/leetcode116/","excerpt":"","text":"原题传送门—&gt;&gt;给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node { int val; Node left; Node right; Node *next;}填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例： 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图所示。 提示： 你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 这个提示很明显要用递归啊。可俺没看到提示先用层序遍历做了： class Solution { public: Node* connect(Node* root) { if(!root) return NULL; queue&lt;Node*&gt;Q; Q.push(root); while(!Q.empty()) { Node* pre = Q.front(); int size = Q.size(); for(int i = 0; i &lt; size; ++i) { if(pre-&gt;left) Q.push(pre-&gt;left); if(pre-&gt;right) Q.push(pre-&gt;right); Q.pop(); Node* p = Q.front(); if(i &lt; size - 1) pre-&gt;next = p; pre = p; } } return root; } }; 时间复杂度O(N)空间复杂度O(logN) 递归思路待思考。。。","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"BBCnews 2020/11/8 败选那天的特朗普","slug":"BBC news 11-8","date":"2020-11-10T03:40:24.000Z","updated":"2021-02-08T02:06:14.923Z","comments":true,"path":"2020/11/10/BBC news 11-8/","link":"","permalink":"/2020/11/10/BBC news 11-8/","excerpt":"","text":"截至北京时间11月9日11点，本文阅读量在BBC新闻排在第三位 US election: Being with Trump the day he lostBy Tara McKelvey BBC White House reporter Trump arrives back at the White House after playing golf Over the past four years, I have seen President Donald Trump on good days and bad days. But 7 November, the day he lost the election, was a day like no other.Dressed in a black windbreaker, dark trousers and a white MAGA (Make America Great Again) hat the president left the White House a few minutes before 10:00. He had spent the early part of his day tweeting about election fraud.Now he leaned forward slightly, as if he were pushing into the wind. He climbed into a dark vehicle and headed to his golf club, Trump National in Sterling, Virginia, about 25 miles(40km) from the White House.In that moment, he projected an air of confidence. It was a lovely day, perfect for golf, and he was going to spend the day at the club.But the people who worked for him seemed on edge.“How are you doing?” I asked one of the junior staffers.“Fine,” she said. She smiled, but her eyes narrowed.She looked down at her phone. Election traumaThe White House has been through some trauma in the days since the election. It was only on Tuesday, but it feels like a lifetime ago.Many of the desks in the West Wing were empty when I walked through the building on Saturday morning. Several staffers have been infected with the coronavirus, and they were out of the office. Others were in quarantine.Then, starting at about 11:30, while the president was at his golf club, the BBC and the US networksbegan calling the election for Joe Biden, hisDemocratic rival. How US networks reported the Biden win I was sitting in an Italian restaurant about a mile from the club when I heard the news. I’m a member of the White House press pool, a small group of journalists who travel with the president. We were all waiting for him to emerge from the club.“He’s toxic,” said one woman outside the restaurant, who had, like most of her neighbours in this Democratic-leaning area, voted for his rival.Others wondered aloud when the president would leave the club and go back to the White House.The minutes passed, then hours.“He’s taking his time,” said a law-enforcementofficer, quietly, to a colleague.The president was in no hurry to leave. At the club,he was surrounded by friends. Outside the gates,supporters shouted at me and the other reporters:”Defund the media!” Donald Trump is seen playing golf as Joe Biden’s win was announced A woman in sturdy heels and a red-white-and-blue bandana carried a sign reading “Stop the steal.”A man drove his truck up and down the road in front of the club flying several flags, including one depicting the president standing on a tank, as if he were commander of the world. It showed how his supporters see him and how Mr Trump has seen himself for the past four years.Finally, he headed out of the club and began his journey home.His critics were waiting - in the thousands. ‘You lose and we all win’The president’s motorcade roared through Virginia, with me riding in the motorcade in a van that narrowly avoided a crash on Fairfax County Parkway. Sirens blared.The closer we got to the White House, the bigger the crowds became: people were out to celebrate his defeat. Someone held up a sign: “You lose and we all win.” People honked and jeered. Critics of the president were seen carrying placards onSaturday Then we got back at the White House, the president went in through a side door, an entrance that presidents rarely use. His shoulders were slumped, and his head down.He glanced over and saw me and the others in the press pool and gave us a thumbs-up. It was a half-hearted gesture; he did not raise his hand high or shake a fist, the way he often does.Whether at the White House or at the golf club, the president has never wavered: he makes unsubstantiated claims about election fraud and insists he will be vindicated.He tweeted in the morning about “illegally received” votes and by late afternoon he was declaring defiantly in all caps. “I WON THEELECTION.” But that was Mr Trump on Twitter. The man I saw left a different impression. As he ducked into the side door of the White House in the late afternoon, the swagger was gone. 美国大选： 败选后的特朗普 作者： Tara McKelvey BBC白宫报道 打完高尔夫球之后，特朗普返回白宫 在过去的四年里，我见证了唐纳德·特朗普总统的生活，其中既有好日子也有坏日子。但11月7日，也就是他选举失利的那天，注定极为特殊。 身穿黑色风衣、深色长裤和白色MAGA(让美国再次伟大)帽,总统在上午10点前几分钟离开了白宫。 他一大早就在推特上控诉选举存在舞弊。现在，他身体微微前倾，仿佛是在迎风前行。他登上一辆黑色汽车，前往距白宫约25英里（40公里）的高尔夫俱乐部，也就是位于Virginia州Sterling市的特朗普国民俱乐部。在那一刻，他散发着自信。今天天气真好，非常适合打高尔夫球，他打算在俱乐部度过一整天。但为他工作的人似乎有些不安。“你还好吗？” 我问一位普通职员。“很好，”她说。她微笑着，但眼睛眯了起来。她低头看着手机。 选举的创伤从大选开始那天起，白宫经历了一些创伤。虽然只是周二，但仿佛经历了一生那么久。周六早上，当我穿过大楼时，西侧的许多桌子旁空无一人。 几名工作人员感染了冠状病毒，所以不在办公室。其他人则正被隔离。然后，从大约11:30开始，当总统还在他的高尔夫俱乐部时，BBC和美国各大电视台开始宣布选举他的民主党对手乔•拜登获胜的消息 美国互联网报道拜登获胜的消息 听到这个消息时，我正坐在距俱乐部约一英里的一家意大利餐厅里。 我是白宫记者会的成员，也就是与总统同行的一小撮记者之一。 我们都在俱乐部门口等他出来。“他是个有毒的家伙” 餐馆外面的一位女士说。在这个亲民主党的地区，她和大多数邻居一样，把票投给了他的对手（拜登）。其他人则大声地猜测总统何时离开俱乐部返回白宫。 几分钟过去了，几个小时过去了。 “他在消磨时间”，一名执法人员悄悄地对同事说。总统并不急于离开。在俱乐部里，他周围都是朋友。在大门外，支持者对我和其他记者吼着：“让这些媒体走开！” 当拜登获胜的消息被宣布后，唐纳德·特朗普被拍到正在打高尔夫球一位女士穿着结实的高跟鞋，头戴红白蓝相间的头巾，举着一块牌子，上面写着“停止偷窃”。一个人开着卡车在俱乐部门前上下行驶，挥舞着几面旗帜，其中一面旗帜描绘着总统站在坦克上的肖像，仿佛他是世界的指挥官一样。最后，他离开了俱乐部，开始了回家的旅程。他的反对者正在外面等待着——人数数以千计。 “你输了，我们赢了”总统的车队呼啸着穿过弗吉尼亚州，我乘坐的是一辆面包车，恰好躲开了费尔法克斯县公园路上的一起车祸。 我听到警笛声响起。越接近白宫，人就变得越多：人们出来庆祝他的失败。 有人高举标语：“你输了，我们赢了。” 人们狂按喇叭，讥笑他。 周六，总统的反对者高举着标语 然后我们回到白宫。总统从侧门进入——这是他很少走的入口。 他垂下肩膀，低下头。他瞥了一眼，看到了记者席上的我和其他人，对我们竖起了大拇指。这手势心不在焉；他没有像从前那样高举手或挥舞拳头。无论是在白宫还是在高尔夫俱乐部，总统的态度从未动摇：他指控选举存在舞弊——尽管尚未有确凿证据。他坚称,自己会被证明是正确的。上午，他在推特上发文称”这些选票不合法！”，到下午晚些时候，他以全大写字母宣告： “我赢得了选举。”但这只是推特上的特朗普。 我亲眼看到的那个人并不是这样。 当那个午后他从侧门潜入白宫时，曾经那个昂首阔步的特朗普已经消失了。","categories":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"/tags/英语/"},{"name":"BBC新闻","slug":"BBC新闻","permalink":"/tags/BBC新闻/"}],"keywords":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}]},{"title":"leetcode 109 升序链表建立AVL树","slug":"leetcode109","date":"2020-11-10T03:40:24.000Z","updated":"2021-02-08T04:44:29.186Z","comments":true,"path":"2020/11/10/leetcode109/","link":"","permalink":"/2020/11/10/leetcode109/","excerpt":"","text":"原题传送门—&gt;&gt; Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: Input: head = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST. Example 2: Input: head = [] Output: [] Example 3: Input: head = [0] Output: [0] Example 4: Input: head = [1,3] Output: [3,1] 链表与数组定义： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ 方案1 数组法：（就是无脑但复杂度还挺低🐶） class Solution { public: vector&lt;int&gt; nodes; TreeNode* sortedListToBST(ListNode* head) { ListNode* p = head; while(p) { nodes.push_back(p-&gt;val); p = p-&gt;next; } return buildBST(0, nodes.size() - 1); } TreeNode* buildBST(int start, int end) { if(start &gt; end) return NULL; int mid = (start + end) / 2; TreeNode* base = new TreeNode(nodes[mid]); base-&gt;left = buildBST(start, mid - 1); base-&gt;right = buildBST(mid + 1, end); return base; } }; 时间复杂度O (N)空间复杂度O（N） 方案2 快慢指针法关于快慢指针法的应用，请戳：《快慢指针法L》 思路仍然是不变的：在链表中找到中位数作为根，然后分别建立左右子树区别是如何找中位数？ 方案1中采取了用向量存储链表。本方案采取快慢指针法定位中位数。定义一个快指针，每次循环前进2个结点一个慢指针，每次循环前进1个结点那么，当快指针到达链表尾部，慢指针大概到达了链表中间位置。 class Solution { public: TreeNode* sortedListToBST(ListNode* head) { return sortedListToBST(head, NULL); } TreeNode* sortedListToBST(ListNode* head, ListNode* rear) { if(head == rear) return NULL; if(head-&gt;next == rear) { return new TreeNode(head-&gt;val); } ListNode* fastPtr = head, *slowPtr = head; while((fastPtr != rear) &amp;&amp; (fastPtr-&gt;next != rear)) { slowPtr = slowPtr-&gt;next; fastPtr = fastPtr-&gt;next-&gt;next; } TreeNode* root = new TreeNode(slowPtr-&gt;val); root-&gt;left = sortedListToBST(head, slowPtr); root-&gt;right = sortedListToBST(slowPtr-&gt;next, rear); return root; } }; 时间复杂度 O(NlogN)空间复杂度 O(1) 方案3 由中序遍历查找树产生的灵感查找二叉树的重要特点是：中序遍历的结果为升序。用中序遍历的方式来建立树，得到的就是搜索树。但还要保证一个问题：左右子树的结点尽可能相等。所以还需要求得链表长度，逐步二分进行递归 class Solution { public: ListNode* p; TreeNode* sortedListToBST(ListNode* head) { int len = 0; p = head; while(p) { p = p-&gt;next; ++len; } p = head; return creatTree(len); } TreeNode* creatTree(int n) { if(!n) return NULL; int mid = n / 2; TreeNode* left = creatTree(mid); TreeNode* root = new TreeNode(p-&gt;val); p = p-&gt;next; TreeNode* right = creatTree(n - mid - 1); root-&gt;left = left; root-&gt;right = right; return root; } }; 时间复杂度O(N)空间复杂度O(log(N))","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"},{"name":"二分","slug":"二分","permalink":"/tags/二分/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"leetcode 114. Flatten Binary Tree to Linked List 二叉树原地变链表","slug":"leetcode114","date":"2020-11-10T03:40:24.000Z","updated":"2021-02-08T04:44:50.926Z","comments":true,"path":"2020/11/10/leetcode114/","link":"","permalink":"/2020/11/10/leetcode114/","excerpt":"","text":"原题传送门—&gt;&gt; Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \\ 2 5 / \\ \\ 3 4 6 The flattened tree should look like: 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 要求空间复杂度为O(1) 可以看到最后的结果应为先序遍历的顺序 对一棵树，作如下约定：尾： 树先序遍历的最后一个结点，一般是右下角的结点头： 树先序遍历的第一个结点， 也就是头结点同样，对于左右子树，可以定义左头（leftHead）、左尾（LeftRear）、右头（rightHead）、右尾（rightRear） 我所写的为一个递归函数，返回值为尾结点 大体流程： 1 定位左尾 2 存储右头 3 如果存在左尾，则左尾的right值赋为右头 4 left值赋成NULL 5 如果存在右尾则返回右尾 否则返回左尾 class Solution { public: void flatten(TreeNode* root) { flattenTree(root); } TreeNode* flattenTree(TreeNode* root) { if(!root) return NULL; if(!root-&gt;left &amp;&amp; !root-&gt;right) return root; TreeNode* rightHead = root-&gt;right; TreeNode* leftRear = flattenTree(root-&gt;left); TreeNode* rightRear = flattenTree(root-&gt;right); if(root-&gt;left) { root-&gt;right = root-&gt;left; root-&gt;left = NULL; leftRear-&gt;right = rightHead; } if(rightRear) return rightRear; else return leftRear; } }; 时间复杂度 O(N)空间复杂度 O(1)","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"快慢指针法的应用","slug":"快慢指针","date":"2020-11-07T03:40:24.000Z","updated":"2021-02-08T04:36:50.493Z","comments":true,"path":"2020/11/07/快慢指针/","link":"","permalink":"/2020/11/07/快慢指针/","excerpt":"","text":"所谓快慢指针法，指的是用两个前进步长不一致的指针对链表进行遍历。 1、快慢指针定位链表中点。该方法不借助计数器变量实现寻找链表的中间结点。 原理：快指针的移动速度是慢指针移动速度的2倍，因此当快指针到达链表尾时，慢指针到达中点。（当然，由于链表长度可能是奇数也可能是偶数，是否真的是中点还需要再判断） 部分代码如下。 ListNode* fastPtr = head; ListNode* slowPtr = head; while (fastPtr &amp;&amp; fastPtr-&gt;next) { fastPtr = fastPtr-&gt;next-&gt;next; slowPtr = slowPtr-&gt;next; } printf(slowPtr-&gt;val); 效率分析：部分帖子认为快慢指针的运行效率为O(N/2)。但我在用C++实际运行测试时，发现快慢指针遍历与普通遍历在查找中点时的效率基本相同。测试模式：将长度为1000的单链表遍历100000次。 测试代码： #include&lt;cstdio&gt; #include&lt;Windows.h&gt; using namespace std; struct ListNode { int val; ListNode* next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode* next) : val(x), next(next) {} }; int travelMode1(ListNode* head) { int count = 0; ListNode* p = head; while (p) { p = p-&gt;next; ++count; } count = count &gt;&gt; 1; p = head; while (count--) { p = p-&gt;next; } return 0; } int TravelMode2(ListNode* head) { ListNode* fastPtr = head; ListNode* slowPtr = head; while (fastPtr &amp;&amp; fastPtr-&gt;next) { fastPtr = fastPtr-&gt;next-&gt;next; slowPtr = slowPtr-&gt;next; } return 0; } int main() { ListNode* head = new ListNode(0); ListNode* p = head, *p1 = NULL; for (int i = 0; i &lt; 1000; ++i) { p1 = new ListNode(0); p-&gt;next = p1; p = p1; } /*以上代码建立了一个长度为1000的单链表*/ DWORD start = GetTickCount64(); for (int i = 0; i &lt; 100000; ++i) travelMode1(head); DWORD end = GetTickCount64(); printf(&quot;普通遍历时间： %dms\\n&quot;, end - start); start = GetTickCount64(); for (int i = 0; i &lt; 100000; ++i) travelMode1(head); end = GetTickCount64(); printf(&quot;快慢指针遍历时间： %dms\\n&quot;, end - start); return 0; } 运行结果：普通遍历时间： 797ms快慢指针遍历时间： 734ms 猜测：尽管快慢指针法循环次数仅有n/2，但是由于while循环的判定条件增多、fastPtr = fastPtr-&gt;next-&gt;next这句代码也需要消耗时间，所以快慢指针法的效率没有想象中那么高。 2、快慢指针判断链表回路 \\ 查找回路入口判断是否存在回路：类似跑步： 两个人以恒定速度绕圈跑，假如速度不一致，那么这两个人一定会在某时刻相遇。 定义一个步长为2的快指针、一个步长为1的慢指针 当快指针到达NULL，则无环。当快慢指针相遇，则有环。 思考：单纯的遍历链表能不能判断是否有环呢？答案是不能。找到NULL就是无环。但是假如有环，无法判定函数的结束。 bool exitLoop(ListNode* head) { ListNode* fastPtr = head; ListNode* slowPtr = head; while (fastPtr &amp;&amp; fastPtr-&gt;next) { fastPtr = fastPtr-&gt;next-&gt;next; slowPtr = slowPtr-&gt;next; if (fasePtr == slowPtr) return true; } return false; } 若已经判断出回路，可以进一步做以下功能： 测量环的长度 寻找环的入口 测量环的长度：只需要在环中找到两个指针，一个保持不动、一个进行遍历。两个指针相遇时遍历次数即为环的长度。 寻找环的入口：先测得环的长度为L，定义两个指针，均指向头节点。其中一个指针先前进L个结点。然后两个指针均以步长1进行遍历。当两个指针相遇时，所指地址即为入口。","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"leetcode 102 二叉树的层序遍历","slug":"leetcode102","date":"2020-11-04T03:40:24.000Z","updated":"2021-02-08T04:43:45.173Z","comments":true,"path":"2020/11/04/leetcode102/","link":"","permalink":"/2020/11/04/leetcode102/","excerpt":"","text":"原题传送门-&gt;&gt;&gt; 题目描述：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。示例： 二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7返回其层次遍历结果： [ [3], [9,20], [15,7] ] /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt; &gt; ans; vector&lt;TreeNode*&gt; pre; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { if(!root) return ans; pre.push_back(root); while(!pre.empty()) { vector&lt;TreeNode*&gt; cur; vector&lt;int&gt; tmp; for(vector&lt;TreeNode*&gt;::iterator i = pre.begin(); i != pre.end(); ++i) { tmp.push_back((*i)-&gt;val); if((*i)-&gt;left)//注意！！！！！ cur.push_back((*i)-&gt;left); if((*i)-&gt;right) cur.push_back((*i)-&gt;right); } pre = cur; ans.push_back(tmp); } return ans; } }; 唯一需要注意的是注释标“注意”的部分，(&lowast;i)&minus;&gt;left的括号不能去掉，因为&minus;&gt;的优先级高于&lowast;","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"leetcode 103  二叉树的锯齿形层次遍历","slug":"leetcode103","date":"2020-11-04T03:40:24.000Z","updated":"2021-02-08T04:43:57.513Z","comments":true,"path":"2020/11/04/leetcode103/","link":"","permalink":"/2020/11/04/leetcode103/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述：给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如： 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7返回锯齿形层次遍历如下： [ [3], [20,9], [15,7] ] 层序遍历的plus版本 需要注意：1：每次更新cur时需要将逆序遍历2：左右子树的访问顺序时不停交替的 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;TreeNode*&gt; pre; vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { int flag = 0; if(!root) return ans; pre.push_back(root); while(!pre.empty()) { flag = 1- flag; vector&lt;int&gt; tmp; vector&lt;TreeNode*&gt; cur; if(flag) { for(vector&lt;TreeNode*&gt;::reverse_iterator i = pre.rbegin(); i != pre.rend(); ++i) { tmp.push_back((*i)-&gt;val); if((*i)-&gt;left) { cur.push_back((*i)-&gt;left); } if((*i)-&gt;right) { cur.push_back((*i)-&gt;right); } } } else { for(vector&lt;TreeNode*&gt;::reverse_iterator i = pre.rbegin(); i != pre.rend(); ++i) { tmp.push_back((*i)-&gt;val); if((*i)-&gt;right) { cur.push_back((*i)-&gt;right); } if((*i)-&gt;left) { cur.push_back((*i)-&gt;left); } } } pre = cur; ans.push_back(tmp); } return ans; } };","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"leetcode 113. Path Sum II 二叉树路径和","slug":"leetcode113","date":"2020-11-04T03:40:24.000Z","updated":"2021-02-08T04:44:43.831Z","comments":true,"path":"2020/11/04/leetcode113/","link":"","permalink":"/2020/11/04/leetcode113/","excerpt":"","text":"原题传送门—&gt;&gt; Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children. Example:Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Return: [ [5,4,11,2], [5,8,4,5] ] /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ 不就是深搜嘛。但第一次还真没想清楚 WA代码共赏： class Solution { public: vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; ans; int counter = 0; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) { if(!root) return ans; travel(root,sum); return ans; } int travel(TreeNode* node, int num) { if(!num &amp;&amp; !node)//应当判别叶节点作为终点，而非空结点 { if((++counter)%2) ans.push_back(tmp); return 0; } if(!node) return 0; tmp.push_back(node-&gt;val); travel(node-&gt;left, num - node-&gt;val); travel(node-&gt;right, num - node-&gt;val); tmp.pop_back(); return 0; } }; 问题如注释所说。有空子树的未必是叶节点。并且将判定空结点改为判定叶节点，省去了那个尴尬的计数器counter AC代码： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) { if(!root) return ans; travel(root,sum); return ans; } int travel(TreeNode* node, int num) { if(!node) return 0; if(!node-&gt;left &amp;&amp; !node-&gt;right) { if(!(num - node-&gt;val)) { tmp.push_back(node-&gt;val); ans.push_back(tmp); tmp.pop_back(); } return 0; } tmp.push_back(node-&gt;val); travel(node-&gt;left, num - node-&gt;val); travel(node-&gt;right, num - node-&gt;val); tmp.pop_back(); return 0; } };","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"leetcode 95 不同的二叉搜索树 Ⅱ","slug":"leetcode95","date":"2020-11-04T03:40:24.000Z","updated":"2021-02-08T04:43:18.592Z","comments":true,"path":"2020/11/04/leetcode95/","link":"","permalink":"/2020/11/04/leetcode95/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。 示例:-输入：3-输出：-[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]-]-解释：-以上的输出对应以下 5 种不同结构的二叉搜索树：- 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 提示：0 &lt;= n &lt;= 8 这里采用的是官方思路 class Solution { public: vector&lt;TreeNode*&gt; generateTrees(int left, int right) { vector&lt;TreeNode *&gt; ans; if(left &gt; right) { ans.push_back(NULL); return ans; }//注意这里push NULL !! 因为左右子树都有可能是空指针 vector&lt;TreeNode*&gt; leftTrees; vector&lt;TreeNode*&gt; rightTrees; for(int i = left; i &lt;= right; ++i) { leftTrees = generateTrees(left, i-1); rightTrees = generateTrees(i + 1, right); for(int j = 0; j &lt; leftTrees.size(); ++j) { for(int k = 0; k &lt; rightTrees.size(); ++k) { TreeNode * root = new TreeNode(i); root -&gt; left = leftTrees[j]; root -&gt; right = rightTrees[k]; ans.push_back(root); } } } return ans; } vector&lt;TreeNode*&gt; generateTrees(int n) { if(n &lt; 1) return vector&lt;TreeNode*&gt;(); vector&lt;TreeNode *&gt; ans = generateTrees(1, n); return ans; } };","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"leetcode 98 验证二叉搜索树","slug":"leetcode97","date":"2020-11-04T03:40:24.000Z","updated":"2021-02-08T04:43:36.664Z","comments":true,"path":"2020/11/04/leetcode97/","link":"","permalink":"/2020/11/04/leetcode97/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 思路：二叉搜索树即为：中序遍历结果为升序的树这里采用非递归遍历 class Solution { public: int pre = 0; int cur = 0; int counter = 0; stack&lt;TreeNode*&gt; S; bool isValidBST(TreeNode* root) { TreeNode* p = root; while(!S.empty() || p) { while(p) { S.push(p); p = p-&gt;left; } pre = cur; p = S.top(); cur = p-&gt;val; if(counter) { if(pre &gt;= cur) return false; } ++counter; S.pop(); p = p-&gt;right; } return true; } };","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"leetcode 96 不同的二叉搜索树","slug":"leetcode96","date":"2020-11-04T03:40:24.000Z","updated":"2021-02-08T04:43:27.391Z","comments":true,"path":"2020/11/04/leetcode96/","link":"","permalink":"/2020/11/04/leetcode96/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述：给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例:-输入：3-输出：5-解释：-以下 5 种不同结构的二叉搜索树：- 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 简单动规。设dp[n]存储着n个结点共能组成多少不同的树。以n = 5为例：5个结点标记为1~5，取i号结点为根，则其左右子树分别有i-1、 5-i个结点。则共能生成dp[i-1] * dp[5-i]个结点 dp[5] = dp[0] dp[4] + dp[1] dp[3] + dp[2] dp[2] + dp[3] dp[1] + dp[4] * dp[0] class Solution { public: int numTrees(int n) { int * dp = new int[100]; dp[0] = 1; dp[1] = 1; for(int i = 2; i &lt;= n; ++i) { int sum = 0; for(int j = 1; j &lt;= i; ++j) { sum += dp[j - 1] * dp[i - j]; } dp[i] = sum; } int ans = dp[n]; delete []dp; return ans; } };","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"},{"name":"动态规划","slug":"动态规划","permalink":"/tags/动态规划/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"鱼书笔记 第四章 神经网络的学习","slug":"鱼书笔记 第四章 神经网络的学习","date":"2020-11-03T02:30:00.000Z","updated":"2021-02-08T02:04:15.335Z","comments":true,"path":"2020/11/03/鱼书笔记 第四章 神经网络的学习/","link":"","permalink":"/2020/11/03/鱼书笔记 第四章 神经网络的学习/","excerpt":"","text":"这里的“学习”是指从训练数据中自动获取最优权重参数的过程。 4.1 从数据中学习4.1.1 数据驱动如何从图片中识别“5”呢？如图4.2所示。机器学习领域，特征量仍是人工设计的，而深度学习中，特征量也是由机器来学习 tip:深度学习有时也被称为端到端机器学习（end-to-end machine learning）。这里的“端到端”指的是从原始数据（输入）到目标结果（输出）。而中间过程究竟使用了怎样的权重、怎样的神经网络、外界是无从得知的。 神经网络的优点是对所有的问题都可以用同样的流程来解决。无论是识别“5”、还是识别狗、识别人脸，均使用同样的模式。 4.1.2 训练数据和测试数据机器学习中，一般将数据分为训练数据和测试数据两部分。先利用训练数据来训练出模型、再用测试数据来评价训练得来的模型的实际能力。 训练数据也被称为“监督数据” 泛化能力: 处理未被观察过的数据（即训练集之外数据）的能力。 获得泛化能力是机器学习的最终目标 过拟合（over fitting）： 没有泛化能力，仅仅对某个数据集过度拟合的状态 4.2 损失函数损失函数（loss function）: 用于评价神经网络性能的指标。 4.2.1 均方误差均方误差（mean squared error） E=\\frac{1}{2}\\sum_{i=0} (y_{k}-x_{k})^2这里, y_{k} 表示神经网络的输出，t_{k}表示监督数据，k表示数据的维数。比如：在3.6节手写数字识别的例子中， y_{k} 和t_{k}是如下元素组成的数据 y = [0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0] t = [0, 0, 1, 0, 0, 0, 0, 0, 0, 0] y表示各种数字的概率t表示正确答案。这种将正确解标签表示为1，其他标签表示为0的方法称为one-hot表示。 python实现： import numpy as np def mean_squared_error(y, t): return 0.5 * np.sum((y - t)**2) t = [0, 0, 1, 0, 0, 0, 0, 0, 0, 0] # 例：&quot;2&quot;的概率最高的情况 y = [0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0] # 例：“7”的概率最高的情况 print(mean_squared_error(np.array(y), np.array(t))) # 输出为0.09750000000000003 y = [0.1, 0.05, 0.2, 0.0, 0.05, 0.1, 0.0, 0.6, 0.0, 0.0] print(mean_squared_error(np.array(y), np.array(t))) # 输出为0.5125000000000001 显然， 第二组数据误差很大 4.2.2 交叉熵误差交叉熵误差（cross entropy）也经常被用作损失函数 E=-\\sum_{k}t_{k}ln y_{k}式中：ln为自然对数，y_{k}为神经网络的输出， t_{k}中， 正确解的索引为1，其他均为0（one-hot表示）交叉熵误差的值是由正确解标签的输出结果所决定的。正确解标签的输出越大，则误差值越小极限情况：若正确解的输出为0，则误差值为正无穷 代码实现： import numpy as np def cross_entropy_error(y, t): delta = 1e-7 return -np.sum(t * np.log(y + delta)) 这里为什么定义一个delta呢？因为对数函数的自变量不可以是0,否则程序会终止。 t = [0, 0, 1, 0, 0, 0, 0, 0, 0, 0] y = [0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0] #正确解对应的输出为0.6 print(cross_entropy_error(np.array(y), np.array(t))) y = [0.1, 0.05, 0.1, 0.0, 0.05, 0.1, 0.0, 0.6, 0.0, 0.0] #正确解对应的输出为0.1 print(cross_entropy_error(np.array(y), np.array(t))) 输出结果为： 0.510825457099338 2.302584092994546 4.2.3 mini_batch学习前面介绍的损失函数的例子仅仅是针对单个数据，但机器学习时需要计算大量数据的损失函数。所以计算N条数据交叉熵函数可以写成： E=-\\frac{1}{N}\\sum_{n}\\sum_{k}t_{nk}ln y_{nk}公式解释： 数据一共有N条 t_{nk}表示第n个数据的第k个元素的标签 y_{nk}表示第n和数据的第k个元素的输出 mini-batch学习:神经网络的训练中，数据可能会达到几百万、几千万之多，这种情况下对所以数据求损失函数并不现实。我们取其中的一小部分数据（称为mini-batch），然后对每个mini-batch进行学习。这种学习方式称为mini-batch学习。 简而言之mini-batch就是取一部分样本来代表整体。 前面提到过MNIST数据集： import sys, os sys.path.append(os.pardir) from dataset.mnist import load_mnist (x_train, t_train),(x_test, t_test) = load_mnist(flatten=True,normalize=True, one_hot_label = True) # 线性化 规格化 one-hot表示 print(x_train.shape) # (60000, 784) print(t_train.shape) # (60000, 10) print(x_test.shape) # (10000, 784) print(t_test.shape) # (10000, 10) MINIST数据集中，共60000条训练数据， 每条数据为784（28×28）维，监督数据是10维。 如何从中抽取10组数据？？ 我们使用了random.choice()方法 array = np.random.choice(60000,10) # 从0到60000中随机取10个数字 print(array) # 输出结果：[11913 29114 14056 6304 11747 12412 43446 59074 46544 17836] 4.2.4 mini-batch版交叉熵误差一个可以同时处理单个数据和批量数据的函数： def cross_entropy_error(y, t): if y.ndim == 1: # 这一步为什么这样做俺也不明白，感觉不需要reshape啊 t = t.reshape(1, t.size) y = y.reshape(1, y.size) batch_size = y.shape[0] # 如果数据是one-hot表示： return -np.sum(t * np.log(y + 1e-7)) / batch_size # 如果数据是非one-hot表示： # return -np.sum(np.log(y[np.arange(batch_size), t] + 1e-7)) / batch_size 4.2.5 为何要设定损失函数？以前面的手写数字识别任务为例。问题：既然该任务的目的是尽可能得提高识别精度，那么直接使用识别精度作为指标不就可以了吗？为什么还要使用损失函数？ 首先解释一下“导数”在神经网络中的作用。在神经网络的学习中，我们需要利用“导数”来寻找最优算法。 如果导数为负值，则需要设法改变参数使该点损失函数的值增大 如果导数为负值，则需要设法改变参数使该点损失函数的值减小 假如以识别精度作指标，大部分点的导数值均为0.比如100张图片，成功识别了32张，识别精度为32%。现在调整权重后，识别精度仍为32%，那么如何继续调整参数呢？这样就很难调整了。 损失函数的意义在于，能评估权重细微的改变对模型效果的影响。 损失函数应当是连续可导的。 4.3 数值微分写一个求导的函数！ 导数定义 \\frac{df(x)}{d(x)} = {\\lim_{x \\to 0}} \\frac{f(x + h) - f(x)}{h}据此可以写一段函数： def numerical_diff(f,x): h = 10e-4 # 思考：h值过大或过小会有什么问题？ return (f(x + h)- f(x)) / h 这段函数计算的是函数f在(x + h)和 x 之间的差分，这称为前向差分，我们还可以利用中心差分，即 \\frac{df(x)}{d(x)} = {\\lim_{x \\to 0}} \\frac{f(x + h) - f(x - h)}{2 \\times h}def numerical_diff(f,x): h = 10e-4 return (f(x + h)- f(x - h)) / 2 * h 这样求得的导数值更精确。 tip:以上利用微小的差分求导的方法被称为数值微分(numercical differentiation)，而基于数字公式的求导过程，则用“解析性(analytic)”一词,利用解析性的求导是不含误差的。 4.4 梯度梯度的定义：对于函数f(x_{0},x_{1}), 的其所有自变量的偏导数组成的向量称为梯度。 f(x_{0},x_{1})的梯度为(\\frac{\\delta f}{\\delta x_{0}},\\frac{\\delta f}{\\delta x_{1}})代码实现： import numpy as np def numerical_gradient(f, x): h = 1e-4 grad = np.zeros_like(x) # 生成一个和x形状相同、元素全为1 的数组 for idx in range(x.size): tmp_val = x[idx] # f(x + h)的计算 x[idx] = tmp_val + h fxh1 = f(x) #疑惑：应该是f(x[idx])还是f(x)呢？ # f(x - h)的计算 x[idx] = tmp_val - h fxh2 = f(x) #疑惑：应该是f(x[idx])还是f(x)呢？ grad[idx] = (fxh1 - fxh2) / (2 * h) x[idx] = tmp_val # 还原数据 return grad #其实这段程序的代码我感觉怪怪的 实例：求f(x_{0},x_{1}) = x^2_{0} + x^2_{1}的梯度并完成绘图。(随书源码) # coding: utf-8 # cf.http://d.hatena.ne.jp/white_wheels/20100327/p3 import numpy as np import matplotlib.pylab as plt from mpl_toolkits.mplot3d import Axes3D def _numerical_gradient_no_batch(f, x): h = 1e-4 # 0.0001 grad = np.zeros_like(x) for idx in range(x.size): tmp_val = x[idx] x[idx] = float(tmp_val) + h fxh1 = f(x) # f(x+h) x[idx] = tmp_val - h fxh2 = f(x) # f(x-h) grad[idx] = (fxh1 - fxh2) / (2*h) x[idx] = tmp_val return grad def numerical_gradient(f, X): if X.ndim == 1: return _numerical_gradient_no_batch(f, X) else: grad = np.zeros_like(X) for idx, x in enumerate(X): grad[idx] = _numerical_gradient_no_batch(f, x) return grad def function_2(x): if x.ndim == 1: return np.sum(x**2) else: return np.sum(x**2, axis=1) def tangent_line(f, x): d = numerical_gradient(f, x) print(d) y = f(x) - d*x return lambda t: d*t + y if __name__ == &#39;__main__&#39;: x0 = np.arange(-2, 2.5, 0.25) x1 = np.arange(-2, 2.5, 0.25) X, Y = np.meshgrid(x0, x1) X = X.flatten() Y = Y.flatten() grad = numerical_gradient(function_2, np.array([X, Y]).T).T plt.figure() plt.quiver(X, Y, -grad[0], -grad[1], angles=&quot;xy&quot;,color=&quot;#666666&quot;) plt.xlim([-2, 2]) plt.ylim([-2, 2]) plt.xlabel(&#39;x0&#39;) plt.ylabel(&#39;x1&#39;) plt.grid() plt.draw() plt.show() 得到的图像： 请务必牢记：梯度指向的方向是各点处函数值减少最多的方向 4.4.1 梯度法神经网络学习的目的在于寻找最优参数，即损失函数取最小值时的参数。利用梯度来寻找损失函数最小值的方法就是梯度法 注意： 函数值减少最多的方向 ≠ 函数值最小的方向，所以梯度方向未必是最小值的方向，梯度仅仅是寻找最小值的一个依据。 请辨析以下高数知识： 极小值 最小值 鞍点(saddle point 国内一般称之为”驻点”） 梯度法求得的是极小值 神经网络的目标是最小值 在梯度法中，函数的取值从当前位置沿着梯度方向前进一定距离，然后在新的地方求梯度，再沿着梯度方向前进，如此反复，不断沿梯度方向前进。 像这样，通过不断沿梯度方向前进，逐渐减小函数值的过程就是梯度法(gradient method)。 根据目的是寻找极大值还是极小值，梯度法的叫法也不同。寻找最小值的梯度法称为梯度下降法(gradient desent method) 寻找最小值的梯度法称为梯度上升法(gradient ascent method) 神经网络中的梯度法一般是梯度下降法。 我们用数学公式来表示梯度法： x_{0}=x_{0}-\\eta \\frac{\\delta f}{\\delta x_{0}}x_{1}=x_{1}-\\eta \\frac{\\delta f}{\\delta x_{1}}式（4.7） 式(4.7)中的\\eta表示更新量，在神经网络的学习中，称为学习率(learning rate)。学习率决定在一次学习中，需要在多大程度上更新参数。 （个人理解：当偏导数为正数，该式能够使自变量的值减少，反正则会增加，直到自变量抵达极小值点） 学习率过大或过小都会影响学习效果，在神经网络的学习中，学习率被预先设定为某个值，在学习过程中，学习率也会随之改变 梯度下降法的python实现： import numpy as np def gradient_descent(f, init_x, lr=0.01, step_num=100): x = init_x for i in range(step_num): grad = numerical_gradient(f, x) x -= lr * grad return x 梯度法求f(x_{0},x_{1}) = x^2_{0} + x^2_{1}的最小值 # coding: utf-8 import numpy as np import matplotlib.pylab as plt from gradient_2d import numerical_gradient def gradient_descent(f, init_x, lr=0.01, step_num=100): x = init_x x_history = [] for i in range(step_num): x_history.append( x.copy() ) grad = numerical_gradient(f, x) x -= lr * grad return x, np.array(x_history) def function_2(x): return x[0]**2 + x[1]**2 init_x = np.array([-3.0, 4.0]) lr = 0.1 step_num = 20 x, x_history = gradient_descent(function_2, init_x, lr=lr, step_num=step_num) plt.plot( [-5, 5], [0,0], &#39;--b&#39;) plt.plot( [0,0], [-5, 5], &#39;--b&#39;) plt.plot(x_history[:,0], x_history[:,1], &#39;o&#39;) plt.xlim(-3.5, 3.5) plt.ylim(-4.5, 4.5) plt.xlabel(&quot;X0&quot;) plt.ylabel(&quot;X1&quot;) plt.show() 得到的图像： 可以看到，自变量不断向（0，0）点逼近。 实际上，(x,y) = (0,0)就是该问题的解。我们可以把神经网络的参数看成这里的x、y,就能逐步得出loss = 0的时候神经网络的参数取值了 像学习率这样的参数称为超参数(hyperparameter),神经网络中的权重参数等是在学习中自动获得的，而超参数则是人工设定的。一般来说，超参数需要不断尝试新的值 4.4.2 神经网络的梯度神经网络的学习中，“梯度”一般指的是损失函数关于权重参数的梯度。设权重为W, 损失函数为L： W = \\begin{pmatrix}w_{11} & w_{12} & w_{13}\\\\w_{21} & w_{22} & w_{23}\\\\ \\end{pmatrix}\\frac{\\delta L}{\\delta W} = \\begin{pmatrix}\\frac{\\delta L}{\\delta w_{11}} & \\frac{\\delta L}{\\delta w_{12}} & \\frac{\\delta L}{\\delta w_{13}}\\\\\\frac{\\delta L}{\\delta w_{21}} & \\frac{\\delta L}{\\delta w_{22}} & \\frac{\\delta L}{\\delta w_{23}}\\\\ \\end{pmatrix}求梯度代码的python实现(随书源码): 先定义一个simpleNet类 import sys, os sys.path.append(os.pardir) import numpy as np from common.functions import softmax, cross_entropy_error from common.gradient import numerical_gradient class simpleNet: def __init__(self): self.W = np.random.randn(2,3) #用高斯分布进行初始化 def predict(self, x): # 预测函数。返回值为神经网络的输出结果 return np.dot(x, self.W) def loss(self, x, t): #损失函数 z = self.predict(x) y = softmax(z) loss = cross_entropy_error(y, t) return loss 下面是具体使用： import sys, os sys.path.append(os.pardir) import numpy as np from common.functions import softmax, cross_entropy_error from common.gradient import numerical_gradient class simpleNet: def __init__(self): self.W = np.random.randn(2,3) def predict(self, x): return np.dot(x, self.W) def loss(self, x, t): z = self.predict(x) y = softmax(z) loss = cross_entropy_error(y, t) return loss x = np.array([0.6, 0.9]) t = np.array([0, 0, 1]) net = simpleNet() p = net.predict(x) print(p) # [-0.64406265 0.75226208 0.3971255 ] print(np.argmax(p)) # 1 print(net.loss(x, t)) # 1.0222385512028003 上面的代码测试了随机生成的神经网络的预测值。可以看到误差非常大。接下来求梯度： f = lambda w: net.loss(x, t) dW = numerical_gradient(f, net.W) print(dW) 4.5学习算法的实现复习一下之前的内容：前提:何为 “学习”？。调整神经网络的权重和参数以便拟合训练数据的过程称为“学习”。 步骤1 (mini-batch)从训练数据中随机选出一部分数据。我们将其视作全体数据 步骤2 (计算梯度)计算梯度是为了更好地减少损失函数的值 步骤3 (更新参数)将权重参数沿梯度方向进行微小更新。 步骤4（重复）重复步骤1、2、3 该算法采用的数据来自于随机选择的mini-batch数据，因此也被称为随机梯度下降法 4.5.1 2层神经网络的实现# coding: utf-8 import sys, os sys.path.append(os.pardir) # from common.functions import * from common.gradient import numerical_gradient import numpy as np class TwoLayerNet: def __init__(self, input_size, hidden_size, output_size, weight_init_std=0.01): # 初始化。 self.params = {} self.params[&#39;W1&#39;] = weight_init_std * np.random.randn(input_size, hidden_size) self.params[&#39;b1&#39;] = np.zeros(hidden_size)#返回值为一个用0填充的数组 self.params[&#39;W2&#39;] = weight_init_std * np.random.randn(hidden_size, output_size) self.params[&#39;b2&#39;] = np.zeros(output_size) # params保存着神经网络的参数。其中W1表示第一层的权重、权重为随机值，偏置为0， # hidden_size是隐藏层的神经元数，设置为一个合适的值即可 #第0、1、2层分别是输入层、隐藏层、输出层 def predict(self, x): W1, W2 = self.params[&#39;W1&#39;], self.params[&#39;W2&#39;] b1, b2 = self.params[&#39;b1&#39;], self.params[&#39;b2&#39;] a1 = np.dot(x, W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, W2) + b2 y = softmax(a2) return y # 预测函数，两层神经网络分别用sigmoid函数和softmax函数作激活函数 def loss(self, x, t): y = self.predict(x) return cross_entropy_error(y, t) # x为输入数据，t为正确解标签 返回的是交叉熵误差 def accuracy(self, x, t): y = self.predict(x) y = np.argmax(y, axis=1) t = np.argmax(t, axis=1) accuracy = np.sum(y == t) / float(x.shape[0]) return accuracy #应该是评估精确度 def numerical_gradient(self, x, t): loss_W = lambda W: self.loss(x, t) grads = {} grads[&#39;W1&#39;] = numerical_gradient(loss_W, self.params[&#39;W1&#39;]) grads[&#39;b1&#39;] = numerical_gradient(loss_W, self.params[&#39;b1&#39;]) grads[&#39;W2&#39;] = numerical_gradient(loss_W, self.params[&#39;W2&#39;]) grads[&#39;b2&#39;] = numerical_gradient(loss_W, self.params[&#39;b2&#39;]) return grads #计算梯度 def gradient(self, x, t): W1, W2 = self.params[&#39;W1&#39;], self.params[&#39;W2&#39;] b1, b2 = self.params[&#39;b1&#39;], self.params[&#39;b2&#39;] grads = {} batch_num = x.shape[0] # forward a1 = np.dot(x, W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, W2) + b2 y = softmax(a2) # backward dy = (y - t) / batch_num grads[&#39;W2&#39;] = np.dot(z1.T, dy) grads[&#39;b2&#39;] = np.sum(dy, axis=0) dz1 = np.dot(dy, W2.T) da1 = sigmoid_grad(a1) * dz1 grads[&#39;W1&#39;] = np.dot(x.T, da1) grads[&#39;b1&#39;] = np.sum(da1, axis=0) return grads # 误差反向传播法 高速计算梯度 每一个参数对应着一个梯度如grads[‘b1’]和params[‘b1’]维度是相同的。 4.5.2 mini-batch的实现神经网络的学习主要是使用mini-batch学习mini-batch学习：从训练数据中选择一部分数据（称为mini-batch）,再以这些mini-batch为输入数据，使用梯度法更新参数。 下面我们以TwoLayerNet为对象，进行mini-batch学习以下为随书源码 # coding: utf-8 import sys, os sys.path.append(os.pardir) import numpy as np import matplotlib.pyplot as plt from dataset.mnist import load_mnist from two_layer_net import TwoLayerNet # 读入完整的MINIST数据 (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, one_hot_label=True) #初始化一个神经网络 network = TwoLayerNet(input_size=784, hidden_size=50, output_size=10) iters_num = 10000 #循环次数 train_size = x_train.shape[0] batch_size = 100 #批（batch）大小 learning_rate = 0.1 # 学习率 train_loss_list = [] #train_acc_list = [] #test_acc_list = [] #iter_per_epoch = max(train_size / batch_size, 1) for i in range(iters_num): batch_mask = np.random.choice(train_size, batch_size) x_batch = x_train[batch_mask] t_batch = t_train[batch_mask] # 计算梯度 grad = network.gradient(x_batch, t_batch) # 更新参数 for key in (&#39;W1&#39;, &#39;b1&#39;, &#39;W2&#39;, &#39;b2&#39;): network.params[key] -= learning_rate * grad[key] loss = network.loss(x_batch, t_batch) train_loss_list.append(loss) # if i % iter_per_epoch == 0: # train_acc = network.accuracy(x_train, t_train) # test_acc = network.accuracy(x_test, t_test) # train_acc_list.append(train_acc) # test_acc_list.append(test_acc) # print(&quot;train acc, test acc | &quot; + str(train_acc) + &quot;, &quot; + str(test_acc)) # 绘制图像 # markers = {&#39;train&#39;: &#39;o&#39;, &#39;test&#39;: &#39;s&#39;} # x = np.arange(len(train_acc_list)) # plt.plot(x, train_acc_list, label=&#39;train acc&#39;) # plt.plot(x, test_acc_list, label=&#39;test acc&#39;, linestyle=&#39;--&#39;) # plt.xlabel(&quot;epochs&quot;) # plt.ylabel(&quot;accuracy&quot;) # plt.ylim(0, 1.0) # plt.legend(loc=&#39;lower right&#39;) # plt.show() 注意被注释掉的代码，涉及到下一个问题：评价识别精度。 4.5.3 基于测试数据的评价经过神经网络的学习，损失函数的值可以不断减小,但这个“减小”仅仅是针对某个特定mini-batch的，假如换成另外的数据，是不是也能减小呢？这就涉及到神经网络的评价。需要利用训练用的mini-batch以外的数据来进行评价。 每经过一个epoch，就评估一次识别精度。 何为epoch? 即：完整地“看”过一次训练数据所用的次数。比如训练数据大小为1000，mini-batch大小为100，经过10次就可以“看”完所有的训练数据上面的代码中，每次更新参数后都会重新随机选择mini-batch，10次未必能看完所有数据。但是实际应用中，一般是将训练数据随机打乱。比如训练数据为1000，mini-batch大小为100，将1000个数据标为1、2、…1000,第一次训练选择1~100,第二次选择101~200…这样经过10次，就能看完所有数据 可以看到，刚才的那段代码识别精度在稳步提升","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"鱼书笔记","slug":"鱼书笔记","permalink":"/tags/鱼书笔记/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"leetcode 93 复原IP地址","slug":"leetcode93","date":"2020-10-26T13:10:00.000Z","updated":"2021-02-08T04:43:04.400Z","comments":true,"path":"2020/10/26/leetcode93/","link":"","permalink":"/2020/10/26/leetcode93/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述： 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。 示例1： 输入：s = “25525511135” 输出：[“255.255.11.135”,”255.255.111.35”] 示例2： 输入：s = “0000” 输出：[“0.0.0.0”] 标准DFS 不过第一次提交没有剪枝，导致超时，记录一下 class Solution { public: vector&lt;string&gt; ans; string ans_; vector&lt;string&gt; tmp; vector&lt;string&gt; restoreIpAddresses(string s) { solve(s, 0); return ans; } int solve(string &amp; s, int start) { if(tmp.size() &gt; 4)//注意这里的剪枝！！！否则当数据过长会超时 return 0; if(start == s.size()) { if(tmp.size() == 4) { ans_.clear(); ans_+=tmp[0]; for(int i = 1;i &lt; 4; ++i) { ans_ += &quot;.&quot;; ans_+= tmp[i]; } ans.push_back(ans_); } return 0; } for(int i = 1; i &lt; 4; ++i)//i为长度 { if((s[start] == &#39;0&#39;)&amp;&amp; (i &gt; 1)) { break; } if(start + i &gt; s.size()) break; string a(s.begin() + start, s.begin() + start + i); if((a &gt; &quot;255&quot;)&amp;&amp;(i == 3)) break; tmp.push_back(a); solve(s, start + i); tmp.pop_back(); } return 0; } };","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"leetcode 94 二叉树中序遍历","slug":"leetcode94","date":"2020-10-26T12:02:00.000Z","updated":"2021-02-08T04:43:11.794Z","comments":true,"path":"2020/10/26/leetcode94/","link":"","permalink":"/2020/10/26/leetcode94/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述：给定一个二叉树，返回它的中序 遍历。 示例: 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] 递归很简单，这里采用堆栈代替递归 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: stack&lt;TreeNode*&gt; S; vector&lt;int&gt; inorderTraversal(TreeNode* root) { TreeNode* t = root; vector&lt;int&gt; ans; while((t)||!S.empty()) { while(t) { S.push(t); t = t-&gt;left; } /* if(!S.empty())//******************* { t = S.top(); S.pop(); ans.push_back(t-&gt;val); t = t-&gt;right; } } */ t = S.top(); S.pop(); ans.push_back(t-&gt;val); t = t-&gt;right; return ans; } }; 注意注释掉的部分： 在浙大陈越数据结构课中，有一步 if(!S.empty())的判定…我在应用时发现这其实是废操作","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"二叉树","slug":"二叉树","permalink":"/tags/二叉树/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"单链表基本操作","slug":"链表基本操作","date":"2020-10-23T03:40:24.000Z","updated":"2021-02-08T04:37:00.659Z","comments":true,"path":"2020/10/23/链表基本操作/","link":"","permalink":"/2020/10/23/链表基本操作/","excerpt":"","text":"链表的定义：/** Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} };*/ 1、交换元素以交换单链表中第m和n号结点为例。以头节点为第一个结点，保证m&gt;n，且m、n均小于链表长度。做法是将待交换的两结点的前驱及自身地址记录下来，然后逐个交换。 需要考虑的特殊情况： 可能涉及到头节点。这里的处理是建立一个哨兵 可能待交换的结点是紧挨着的,这样就不可以简单地交换了，这里进行了特判 class Solution { public: ListNode* swapNode(ListNode* head, int m, int n) { ListNode* headTmp = new ListNode(1); headTmp-&gt;next = head; ListNode* pre1 = NULL; ListNode* lat1 = NULL; ListNode* pre2 = NULL; ListNode* lat2 = NULL; int counter = 0; ListNode* p = headTmp; while(p &amp;&amp; (counter &lt;= n)) { if(counter == m-1) pre1 = p; if(counter == m) lat1 = p; if(counter == n-1) pre2 = p; if(counter == n) lat2 = p; ++counter; p = p-&gt;next; } ListNode* tmp = lat1-&gt;next; lat1-&gt;next = lat2-&gt;next; pre1-&gt;next = lat2; if(n == m+1)//结点紧挨着的情况 { lat2-&gt;next = lat1; } else { pre2-&gt;next = lat1; lat2-&gt;next = tmp; } ListNode* newHead = headTmp-&gt;next; delete headTmp; return newHead; } }; 2、链表反转反转从位置 m 到 n 的链表。使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。示例： 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 大体思路：采用三指针，前两个指针用于反转，后一个指针用于记录next的值 注意：反转如果涉及到头或尾节点需要特殊处理. class Solution { public: ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* headTmp = new ListNode(1); headTmp-&gt;next = head;//设置哨兵 ListNode *pre = NULL; ListNode *rear = NULL; ListNode *p = headTmp; int counter = 0; while(p &amp;&amp; (counter + 1 &lt; m)) { ++counter; p = p-&gt;next; }//循环后p指向反转部分的前驱(第m-1个结点) pre = p; p = p-&gt;next; rear = p;//反转部分的头部(第m个结点，也就是反转后的尾部) ++counter; ListNode *p1 = p-&gt;next, *p2; if(!p1)//m=n=链表长度，啥也不用做 { delete headTmp; return head; } p2 = p1-&gt;next; while(p2 &amp;&amp; (counter &lt; n))//交换第counter和第counter+1个结点 { p1-&gt;next = p; p = p1; p1 = p2; p2 = p2-&gt;next; counter++; }//p为第n个结点，p1为尾结点的后继 if(n &gt; counter ) { p1-&gt;next = p; p = p1; p1 = p2; } pre-&gt;next = p; rear-&gt;next = p1; ListNode* newhead = headTmp-&gt;next; delete headTmp; return newhead; } }; 下面是在leetcode上找到的比较优美的代码： 范例1：这个不需要特判，太舒服了。需要弄明白如何迭代（建议画画图）。 class Solution { public: ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* headTmp = new ListNode(1); headTmp-&gt;next = head; ListNode* pre = headTmp; int counter = 0; while(counter &lt; m - 1) { ++counter; pre = pre-&gt;next; }//pre定位到m-1的位置 ListNode* back = pre-&gt;next; while(counter &lt; n-1) { ListNode* front = back-&gt;next;//back-&gt;next指向反转部分的最后一个结点 back-&gt;next = front-&gt;next;//front-&gt;next是下一个反转的结点 front-&gt;next = pre-&gt;next;//pre-&gt;next指向反转之后、反转部分的尾结点 pre-&gt;next = front; ++counter; } return headTmp-&gt;next; } };","categories":[{"name":"C++","slug":"C","permalink":"/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"C++","slug":"C","permalink":"/categories/C/"}]},{"title":"大二。","slug":"2020_10","date":"2020-10-20T10:55:00.000Z","updated":"2021-02-08T01:58:41.484Z","comments":true,"path":"2020/10/20/2020_10/","link":"","permalink":"/2020/10/20/2020_10/","excerpt":"","text":"刚上大学那会儿，姐姐跟我聊了几句。她没有老生常谈式地叮嘱我“好好学习”，她告诉我的反而是：“好好玩，我大学四年最后悔的事情是把时间全花在学习上了。该旅游旅游、该恋爱恋爱，毕业了可没这么好的时间了”。 姐姐本科毕业后就工作了，加班是常态。 姐姐蛮了解我，从小因为家里各种各样的原因，我比较内向比较自卑，大学所谓的多彩生活吧，我可能真的不太能体验。旅游、恋爱、聚餐、或者是各种爱好——我接触得越少越没办法破圈。多彩的大学生活到底和我有什么交集呢？ 现在我大二，准备着课设、期末、竞赛、力扣……不知不觉已经处在高校的内卷之中。身处“卷”中，焦虑会逼着我前进。但好像我真的不清楚这一切是为了什么 ...今天、代码敲的恶心的时候，我关上编译器就觉得自己蛮可怜的。对我来说，大学只是给未来工作做好铺垫，我没办法过上有趣的生活、找到交心的人。 我想问自己这条路真的是我选的吗。 写于10月20日傍晚 经信楼","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"音乐","slug":"音乐","permalink":"/tags/音乐/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"JLU C语言课设：医院管理系统 源码","slug":"C","date":"2020-10-16T03:40:24.000Z","updated":"2021-02-08T04:42:37.096Z","comments":true,"path":"2020/10/16/C/","link":"","permalink":"/2020/10/16/C/","excerpt":"","text":"实验说明：《程序设计基础课程设计》（2019级） 1、编写一个C语言程序，实现一个医院的诊疗管理系统，能够管理至少30位患者，每位患者至多30条诊疗记录。其中：1）每条诊疗记录包括患者信息、医生信息、诊疗情况三部分。请自行组织相关信息的存储方式（冗余信息可不存储）和显示格式。2）患者信息包括：姓名、年龄、挂号；挂号唯一。3）医生信息包括：姓名、级别、科室、工号、出诊时间；工号唯一；每位医生只在规定时间出诊（如每周一、周三，默认出诊即全天出诊）。4）诊疗情况分为3类信息：检查、开药、住院。对于检查，仅记录每种检查费用，以及所有检查的总费用；对于开药，仅记录每种药品名称、单价、数量，以及所有药品的总价；对于住院，仅记录住院开始日期、预计出院日期、住院押金。5）住院费用按实际天数计算。在办理住院时（即开始日期）需要交纳住院押金，住院押金要求为100元的整数倍，且不低于200*N（N为拟住院天数）元。特殊约定：在00:00-08:00之间办理出院不收取当天的住院费。对于拟继续住院的患者则系统会自动在08:00从患者的住院押金中扣除当天的住院费用，患者住院期间需随时保证住院押金一直不低于1000元。 为了简化，特做如下约定：1）如涉及时间，仅包括月、日、时、分（默认为当年）。2）患者最多100位，医生最多30位；药品最多30种，药品充足；患者每次开药最多100盒（或其它合适的数量单位）。3）医生的级别限定为：主任医师、副主任医师、主治医师、住院医师1，尽可能符合实际情况。医生仅隶属于某个科室。提醒：医生之间、患者之间、医生患者之间均可能重名。4）每天，医院可最多受理500个号，每位医生可最多受理20个号，每位患者可最多挂5个号、同一科室最多挂1个号；需自行设计挂号的编码规则，可隐含挂号日期、挂号当天的顺序号、对应的医生等信息，保证每条诊疗记录的挂号唯一。5）金额要精确到元、角、分，不允许有误差，最高额度不超过10万；最大数量不超过int允许最大整数。 具体功能要求如下：0）开始时，管理系统默认医院的运营资金为0元。1）【增加】能够从文件中录入多条诊疗记录，也能够随时录入1条诊疗记录。注意：需要考虑各种类型的不规范、不合理或错误数据，如：数据位数不对、格式不对等。【重点考察】2）【修改】能够随时修改1条诊疗记录。按照财务规范，如需修改错误的诊疗记录，应将当前错误的诊疗记录予以撤销后，再补充添加正确的诊疗记录。【重点考察】3）【删除】能够随时删除1条诊疗记录。1 住院医师只是医生的一种级别，并不表示诊疗情况中的住院只能与住院医师对应。4）【查询】能够按照合理顺序打印某个科室的诊疗信息（按照科室检索）。5）【查询】能够按照合理顺序打印某位医生的诊疗信息（按照医生的工号检索）。6）【查询】能够按照合理顺序打印某位患者的历史诊疗信息（按照患者的相关信息检索）。7）【统计】能够统计医院目前的营业额（检查费用+药品费用+住院费用，不含住院押金）；能够生成目前的住院患者报表。【重点考察】8）【统计】能够统计每位医生的出诊情况和工作繁忙程度。9）【某段时间范围】能够打印某段时间范围内的所有诊疗信息。【重点考察】10）【存储】能够将当前系统中的所有信息保存到文件中。11）其它你认为有用的附加功能，可酌情添加。 2、课程设计要求《程序设计基础课程设计》最终成绩（五分制）=《程序设计基础课程设计》超星MOOC成绩×10% + 育信OJ在线评测成绩×10% + 分组报告答辩成绩×80%。《程序设计基础课程设计》超星MOOC：由教师导入学生名单，学生无需注册；学生在规定时间内登录并独立完成在线任务（视频学习、单元测验和PBL提交）。育信OJ在线评测：学生独立在实验室在线评测。分组报告答辩：学生分组在实验室现场评测。1）自由分组，每组3人（特殊情况以指导教师安排为准），每组1份实验报告（请严格按照模板撰写）。2）答辩前在超星平台上以PBL形式提交材料（源代码、相关测试文件和实验报告等），所提交的C语言源程序需要含有必要的代码注释。3）答辩时现场提交实验报告的打印版。4）指导教师按照平时考核、代码和实验报告质量、任务分工和完成比例、界面美观和人性化、个人和团队答辩情况等环节综合评定成绩。重要说明1：全程链表实现。重要说明2：请按照人性化的方式设计具体功能，如：增加的诊疗信息仅含有部分数据，灵活的数据输入方式，软件使用人员操作失误，用户希望的多样化的查询和统计方式，清晰美观的输出方式，合理划分为多个源文件。重要说明3：请自行构造原始数据文件用于测试，文件类型为txt，每个文件至少包含30条诊疗记录。3、成绩说明五分制：优秀15%左右；良好35%左右；中等35%左右；及格和不及格15%左右。旷课比例达到20%（2次），最高成绩为中等；旷课比例达到30%（3次），最高成绩为及格；旷课比例达到50%（4次），取消答辩资格，成绩为不及格。4、特殊说明1）对于计算机科学与技术学院、软件学院的2019级学生，所有事宜以具体指导教师安排为准。2）对于软件学院2019级荣誉班，除此文件外，另有一个命名为“《程序设计基础课程设计》（软2019级补充材料）”的附件。3）对于计算机科学与技术学院、软件学院的重修、转专业学生，请尽快加入QQ群：**，主动联系任课教师（**），所有事宜以任课教师安排为准。 源码注：该源码脱离资源文件不能运行,运行请下载附件中的工程文件 //文件basic.h #ifndef OPEN_H_INCLUDED #define OPEN_H_INCLUDED struct Doctor{ int number;//工号 char name[20];//姓名 int level; //级别 int department;//科室 int workingHours[7];//工作时间。索引值0~6对应周日~周六,存储值为1则为上班，0则为不上班 struct Doctor *next; int registed;//今日挂号量统计 int w_registed;//周挂号量统计 }; struct ExaminationFee{ char name[20]; int cost; struct ExaminationFee *next; }; struct Medicine{ int number; char name[20]; int price; struct Medicine *next; }; struct Hospitalization{ int zhuyuanyajin;//住院押金 int ruyuanshijian;//入院时间：月、日、时、分 int chuyuanshijian;//出院时间：月、日、时、分 }; struct Treatment{ int total; int totalExaminationFee; //总检查费 struct ExaminationFee exminationFee; int totalMedicineCharge; //总药费 struct Medicine medicine; struct Hospitalization hospitalization; }; /*数据类*/ struct Data{ int number; //挂号序列 需是唯一值 int ID;//患者ID，对于每位患者来说是唯一值 char name[20]; //患者姓名 int age; //患者年龄 struct Doctor doctor; //医生 struct Treatment treatment; //治疗方法 struct Data *next;//链 }; int clearMedList();//回收药品链表内存 int clearDoctorList();//回收医生链表 int clearExamList();//回收诊疗项目链表内存 void saveData(char *location);//在location路径下将dataHead链表的所有数据存储到文件中 int registe();//挂号模块 void inputMedData();//从文件中读取并加载药品仓库数据 void buildDoctorList();//加载医生值班数据 int compStr(char *s1, int len1, char *s2, int len2);//字符串比对函数，用于检索 void buyMedicine(struct Data* newnode);//购药函数 int printDeparList(int n);//输出某个科室的情况 void hospitalize(struct Data* newNode);//住院模块 void selectExaminations(struct Data * newnode);//选择检查项目 void menu();//主菜单 int viewData();//浏览数据模块 void inputExamData();//加载所有的检查项目 void clearList1(struct Medicine *base);//回收base链表内存 void clearList2(struct ExaminationFee * base);//回收base链表内存 int findExamStart(int left, int right, FILE *pf_exam, int target); //二分查找，在文件中寻找对应的购药数据 int findMedStart(int left, int right, FILE *pf_med, int target); //二分查找，在文件中寻找对应的检查项目数据 int buildMedList(struct Medicine *base, FILE *pf_med, int start, int end);//建立诊疗记录中的购药单链表 int buildExamList(struct ExaminationFee *base, FILE *pf_exam, int start, int end);//建立诊疗记录中的检查项目链表 void clearList(struct Data *base);//回收base链表内存 struct Data* input(const char *dir);//建立链表的主函数，文件路径为dir，返回值为哨兵节点 void openUTDfile();//打开最新的数据文件 int preDay(char *ori);//输入为&quot;data/1009/&quot;型字符串，输出为前一天的字符串，如“data/1008/” int nextDay(char *ori);//输入为&quot;data/1009/&quot;型字符串，输出为后一天的字符串，如“data/1010/” int scanInt(int *num, int length);//输入整型变量，回车键结束输入，非法字符会被忽略,输入过长返回-2，无输入返回-1； int scanStrNum(char *num,int length);//输入数字的字符串，回车键结束输出，非法字符会被忽略，若无符合要求的输入则返回1，长度过长返回-2. int scanName(char *s, int length);//输入姓名,返回-2为输入过长 void loadHospitalizeData();//加载住院数据 void saveHosData();//存储主链表数据 int inputDate(int *month, int *day);//输入日期的函数 struct Data* reInput(const char* dir);//从路径为dir的文件中倒序建立链表 int viewUTDdata(int n);//浏览最新的n条数据 int showDepartStatus();//显示挂号情况模块 void showDocRegisted(struct Doctor *head);//显示科室中所有医生的情况 int leaveHospital(struct Data *p);//出院模块 int timeSpan(int start, int end);//日期不合法返回0 int printfMoneyStatus();//打印医院的营业额 void w_countAllDoc();//统计所有医生近一周的挂号量 int scanStr(char *s, int length);//安全读取字符串的函数 int dataChangeMenu();//数据修改菜单 int changeDataMenu();//修改数据的主界面 int setPassWord();//加密函数 char * deCode();//解密函数 int dataViewMenu(); //数据浏览模块 int inpatientDapart();//住院部模块 int patientAdminMenu();//住院病人管理菜单 int delayTime(struct Data *p);//延期出院模块 int printMargin(int n) ;//用于排版 void loading() ;//加载动效 int printSingleData(struct Data *p);//打印单条数据 int saveMedData(); int reSeek(FILE *pf); #endif // OPEN_H_INCLUDED //文件basic.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include &lt;io.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include&lt;windows.h&gt; #include&quot;basic.h&quot; #include&quot;view.h&quot; #include&quot;change.h&quot; /* 设定：每个医生一天最多挂10个号 每个科室最多挂20个号 */ const char DoctorLevel[5][12] = {&quot;&quot;,&quot;住院医师&quot;,&quot;主治医师&quot;,&quot;副主任医师&quot;,&quot;主任医师&quot;}; struct Medicine * mediStorage;//医院药品仓库 struct ExaminationFee * examlists; //医院所有可检查的项目 struct Data* dataHead;//链表头结点.有哨兵 struct Data* dataRear;//链表尾结点 struct Data* inHospital;//所有正在住院的病人，无哨兵 struct Data* inHospitalRear; struct Doctor doctor_departments[5];//设置5个科室,每个科室都是一个医生链表，有哨兵结点 char departments[7][20] = {&quot;内科&quot;,&quot;外科&quot;,&quot;儿科&quot;,&quot;五官科&quot;,&quot;传染病科&quot;}; int countDepartment[7];//记录每个科室挂了多少号 int sequence = 1;//挂号序列 /*考虑：几种模式的浏览：*/ int viewData() { system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;1、浏览最新数据\\n\\n&quot;); printMargin(40); printf(&quot;2、浏览历史数据\\n\\n&quot;); printMargin(40); printf(&quot;0、返回上一层\\n\\n\\n\\n\\n&quot;); printf(&quot;请选择：&quot;); int command; for(;;) { scanInt(&amp;command, 3); if((command &lt; 0)||(command &gt; 3)) { printf(&quot;输入非法!\\n请重新输入:&quot;); } else break; } if(!command) return 0; if(command == 1) { printf(&quot;请输入要查看多少条数据（最多100条）:&quot;); for(;;) { scanInt(&amp;command, 4); if((command &lt; 0)||(command &gt; 100)) { printf(&quot;输入非法\\n请重新输入:&quot;); } else break; } viewUTDdata(command); } else viewDataSpan(); return 0; } struct Data* input(const char* dir)//打开以路径“dir”为参数的所有文件,路径格式：“data/1001/” { FILE *pf, *pf_med, *pf_exam; char position[40]; strcpy(position,dir); strcpy(position+10,&quot;data.txt&quot;); sequence = 0; struct Data * base = (struct Data*)malloc(sizeof(struct Data)); base-&gt;next = NULL; if(pf = fopen(position,&quot;r&quot;),pf==NULL) { dataRear = base; dataHead = base; return base; } strcpy(position+10,&quot;examination.txt&quot;); pf_exam = fopen(position,&quot;r&quot;); strcpy(position+10,&quot;medicine.txt&quot;); pf_med = fopen(position,&quot;r&quot;); struct Data *p1, *p2 = NULL; p1 = base; struct Data *ptmp = NULL; while(!feof(pf)) { p2 = (struct Data *)malloc(sizeof(struct Data)); p2-&gt;next = NULL; p1-&gt;next = p2; fscanf(pf,&quot;%d%d%s%d%d%s&quot;,&amp;(p2-&gt;number),&amp;(p2-&gt;ID),p2-&gt;name,&amp;(p2-&gt;age),&amp;(p2-&gt;doctor.number),p2-&gt;doctor.name); fscanf(pf,&quot;%d%d&quot;,&amp;p2-&gt;doctor.level,&amp;p2-&gt;doctor.department); int i; for(i = 0; i &lt; 7; ++i) fscanf(pf,&quot;%d&quot;,&amp;(p2-&gt;doctor.workingHours[i])); fscanf(pf,&quot;%d&quot;,&amp;(p2-&gt;treatment.total)); int med_start,med_end,exam_start,exam_end; fscanf(pf,&quot;%d%d%d%d&quot;,&amp;med_start,&amp;med_end,&amp;exam_start,&amp;exam_end); fscanf(pf,&quot;%d%d&quot;,&amp;(p2-&gt;treatment.hospitalization.ruyuanshijian),&amp;(p2-&gt;treatment.hospitalization.chuyuanshijian)); p2-&gt;treatment.medicine.next = NULL; fgetc(pf); p2-&gt;treatment.totalMedicineCharge = buildMedList(&amp;(p2-&gt;treatment.medicine),pf_med,med_start,med_end); p2-&gt;treatment.totalExaminationFee = buildExamList(&amp;(p2-&gt;treatment.exminationFee), pf_exam,exam_start,exam_end); ptmp = p1; sequence = (ptmp-&gt;number)%10000; p1 = p2; } dataRear = ptmp; ptmp-&gt;next = NULL; free(p2); fclose(pf); fclose(pf_exam); fclose(pf_med); return base; } /*建立购药单链表*/ int buildMedList(struct Medicine *base, FILE *pf_med, int start, int end)//建立药品链表(需要读取购药单所在的文件) { base-&gt;next = NULL; if(start &gt; end) return 0; if(!start) return 0; int totalcost = 0; int right; fseek(pf_med,-38,SEEK_END);//共有right条数据 fscanf(pf_med,&quot;%d&quot;,&amp;right); --right; struct Medicine *p1, *p2; p1 = (struct Medicine *)malloc(sizeof(struct Medicine)); //文件尾记录了总共有多少条数据，8字节 base-&gt;next = p1; p1-&gt;next = NULL; int s; s = findMedStart(0, right, pf_med,start);//二分查找开始的记录 fseek(pf_med,s * 38, SEEK_SET); int tmp; fscanf(pf_med,&quot;%d%s%d%d&quot;,&amp;(tmp),p1-&gt;name,&amp;(p1-&gt;price),&amp;(p1-&gt;number)); totalcost += ((p1-&gt;price) * (p1-&gt;number)); if(start &gt; end) return 0; while((tmp &lt; end)&amp;&amp;(!feof(pf_med))) { p2 = (struct Medicine*)malloc(sizeof(struct Medicine)); p2-&gt;next = NULL; p1-&gt;next = p2; p1 = p2; fscanf(pf_med,&quot;%d%s%d%d&quot;,&amp;tmp,p1-&gt;name,&amp;(p1-&gt;price),&amp;(p1-&gt;number)); totalcost += ((p1-&gt;price) * (p1-&gt;number)); } return totalcost; } /*寻找购药单起点*/ int findMedStart(int left, int right, FILE *pf_med, int target) { int mid = (left + right) / 2; fseek(pf_med,mid * 38, SEEK_SET); int tmp; fscanf(pf_med,&quot;%d&quot;,&amp;tmp); if(tmp == target) return mid; if(left &gt; right) return -1; if(tmp &gt; target) return findMedStart(left,mid - 1, pf_med,target); else return findMedStart(mid + 1,right , pf_med, target); } /*建立检查项目链表*/ int buildExamList(struct ExaminationFee *base, FILE *pf_exam, int start, int end) { base-&gt;next = NULL; int total = 0; if(end &lt; start) return total; if(!end) return total; int right; fseek(pf_exam,-29,SEEK_END); fscanf(pf_exam,&quot;%d&quot;,&amp;right); --right; struct ExaminationFee *p1, *p2; p1 = (struct ExaminationFee *)malloc(sizeof(struct ExaminationFee)); //文件尾记录了总共有多少条数据，8字节 base-&gt;next = p1; int s; s = findExamStart(0, right, pf_exam,start);//二分查找开始的记录 fseek(pf_exam,s * 30, SEEK_SET); int tmp; fscanf(pf_exam,&quot;%d%s%d&quot;,&amp;tmp,p1-&gt;name,&amp;(p1-&gt;cost)); total += (p1-&gt;cost); p1-&gt;next = NULL; while((tmp &lt; end)&amp;&amp;(!feof(pf_exam))) { p2 = (struct ExaminationFee*)malloc(sizeof(struct ExaminationFee)); p1-&gt;next = p2; p1 = p2; fscanf(pf_exam,&quot;%d%s%d&quot;,&amp;(tmp),p1-&gt;name,&amp;(p1-&gt;cost)); total += (p1-&gt;cost); p2-&gt;next = NULL; } return total; } /*在检查项目总文件中寻找需要的数据段*/ int findExamStart(int left, int right, FILE *pf_exam, int target) { int mid = (left + right) / 2; fseek(pf_exam,mid * 30, SEEK_SET); int tmp; fscanf(pf_exam,&quot;%d&quot;,&amp;tmp); if(tmp == target) return mid; if(left &gt; right) return -1; if(tmp &gt; target) return findExamStart(left,mid - 1, pf_exam,target); else return findExamStart(mid + 1,right , pf_exam, target); } /*释放总诊疗记录链表*/ void clearList(struct Data *base) { if(!base) return; struct Data *p = base-&gt;next; free(base); struct Data *p2; while(p) { p2 = p; p = p-&gt;next; clearList2(p2-&gt;treatment.exminationFee.next); clearList1(p2-&gt;treatment.medicine.next); free(p2); } return; } /*释放购药链表*/ void clearList1(struct Medicine *base) { struct Medicine *p = base; struct Medicine *p2; while(p) { p2 = p; p = p-&gt;next; free(p2); } return; } /*释放诊疗记录链表*/ void clearList2(struct ExaminationFee *base) { struct ExaminationFee *p = base; struct ExaminationFee *p2; while(p) { p2 = p; p = p-&gt;next; free(p2); } return; } int printSingleData(struct Data * p) { printf(&quot;挂号序列：%d 患者姓名：%s ID:%d 患者年龄： %d &quot;, p-&gt;number, p-&gt;name,p-&gt;ID, p-&gt;age); printf(&quot;医生：%s %s %s 工号：%d\\n药品费： %d元 %d角\\n&quot;,departments[p-&gt;doctor.department],DoctorLevel[p-&gt;doctor.level],p-&gt;doctor.name,p-&gt;doctor.number,(p-&gt;treatment.totalMedicineCharge)/10,(p-&gt;treatment.totalMedicineCharge)%10); printMedList(&amp;(p-&gt;treatment.medicine)); printf(&quot;检查费： %d元 %d角&quot;,(p-&gt;treatment.totalExaminationFee)/10,(p-&gt;treatment.totalExaminationFee)%10); printExamList(&amp;(p-&gt;treatment.exminationFee)); if(p-&gt;treatment.hospitalization.ruyuanshijian) { int a = p-&gt;treatment.hospitalization.ruyuanshijian; int b = p-&gt;treatment.hospitalization.chuyuanshijian; printf(&quot;入院时间:%d月 %d日 %d时&quot;,a /1000000,(a%1000000)/10000, (a%10000)/100); printf(&quot;出院时间:%d月 %d日 %d时&quot;,b /1000000,(b%1000000)/10000, (b%10000)/100); } printf(&quot;\\n\\n\\n\\n&quot;); return 0; } /*将dataHead链表的所有信息存在路径为location的文件中*/ void saveData(char *location) { strcpy(location+10,&quot;data.txt&quot;); FILE *pf_data = fopen(location,&quot;w&quot;); strcpy(location+10,&quot;examination.txt&quot;); FILE *pf_exa = fopen(location,&quot;w&quot;); strcpy(location+10,&quot;medicine.txt&quot;); FILE *pf_med = fopen(location,&quot;w&quot;); struct Data * p = dataHead-&gt;next; int k_med = 1,k_exa = 1; while(p) { fprintf(pf_data,&quot;%09d %08d %8s %03d %06d %8s %d %02d &quot;,p-&gt;number,p-&gt;ID,p-&gt;name,p-&gt;age,p-&gt;doctor.number,p-&gt;doctor.name,p-&gt;doctor.level,p-&gt;doctor.department); for(int i = 0; i &lt; 7; ++i) fprintf(pf_data,&quot;%d &quot;,p-&gt;doctor.workingHours[i]); fprintf(pf_data,&quot;%06d &quot;,p-&gt;treatment.total); struct Medicine* p_med = p-&gt;treatment.medicine.next; if(p_med) { fprintf(pf_data,&quot;%06d &quot;,k_med); while(p_med) { fprintf(pf_med,&quot;%06d %20s %03d %04d\\n&quot;,k_med++,p_med-&gt;name,p_med-&gt;number,p_med-&gt;price); p_med = p_med-&gt;next; } fprintf(pf_data,&quot;%06d &quot;,k_med-1); } else { fprintf(pf_data,&quot;%06d %06d &quot;,0,0); } struct ExaminationFee* p_exa = p-&gt;treatment.exminationFee.next; if(p_exa) { fprintf(pf_data,&quot;%06d &quot;,k_exa); while(p_exa) { fprintf(pf_exa,&quot;%06d %14s %06d\\n&quot;,k_exa++,p_exa-&gt;name,p_exa-&gt;cost); p_exa = p_exa-&gt;next; } fprintf(pf_data,&quot;%06d &quot;,k_exa-1); } else { fprintf(pf_data,&quot;%06d %06d &quot;,0, 0); } fprintf(pf_data,&quot;%08d %08d\\n&quot;,p-&gt;treatment.hospitalization.ruyuanshijian,p-&gt;treatment.hospitalization.chuyuanshijian); p = p-&gt;next; } fclose(pf_data); fclose(pf_exa); fclose(pf_med); } /*建立一个药品链表：该链表存储着医院所有药品*/ void inputMedData() { FILE *pf_med = fopen(&quot;hospital/medicine.txt&quot;,&quot;r&quot;); mediStorage = (struct Medicine *)malloc(sizeof(struct Medicine)); struct Medicine * p = mediStorage,*p1,*p2; while(!feof(pf_med)) { p1 = (struct Medicine *)malloc(sizeof(struct Medicine)); int tmp; fscanf(pf_med,&quot;%d%s%d%d&quot;,&amp;tmp,p1-&gt;name,&amp;(p1-&gt;number),&amp;(p1-&gt;price)); p1-&gt;next = NULL; p-&gt;next = p1; p2 = p; p = p1; } free(p); p2-&gt;next = NULL; fclose(pf_med); } int clearMedList() { struct Medicine * p = mediStorage,*p1; while(p) { p1 = p; p = p-&gt;next; free(p1); } return 0; } /*在每一个科室之下建立医生链表*/ void buildDoctorList()// { FILE *pf_doctor = fopen(&quot;hospital/doctor.txt&quot;,&quot;a+&quot;); struct Doctor *p1[5], *p2; for(int i = 0; i &lt; 5; ++i) p1[i] = &amp;(doctor_departments[i]); while(!feof(pf_doctor)) { p2 = (struct Doctor*) malloc(sizeof(struct Doctor)); p2-&gt;next = NULL; fscanf(pf_doctor,&quot;%s%d%d%d&quot;,p2-&gt;name,&amp;(p2-&gt;level), &amp;(p2-&gt;department),&amp;(p2-&gt;number)); for(int i = 0; i &lt; 7; ++i) fscanf(pf_doctor,&quot;%d&quot;,&amp;(p2-&gt;workingHours[i])); p1[(p2-&gt;department)-1]-&gt;next = p2; p1[(p2-&gt;department)-1] = p2; } } int clearDoctorList() { for(int i = 0; i &lt; 5; ++i) { struct Doctor * p = doctor_departments[i].next, *p1; while(p) { p1 = p; p = p-&gt;next; free(p1); } } return 0; } int compStr(char *s1, int len1, char *s2, int len2)//字符串比对,返回匹配度 { int count = 0; for(int i = 0; i &lt; len1; ++i) { for(int j = 0; j &lt; len2; ++j) { if(s1[i] == s2[j]) { ++count; break; } } } return count==len1; } /*患者的购药函数*/ void buyMedicine(struct Data* newnode) { char s[20]; struct Medicine *p1 = &amp;newnode-&gt;treatment.medicine,*p2; newnode-&gt;treatment.totalMedicineCharge = 0; for(;;) { int flag = 0; printf(&quot;请输出欲购买药品的名称，输入exit退出购药界面\\n输入：&quot;); scanStr(s,19); if(s[0]==&#39;e&#39;) break; if(strlen(s) &lt; 3) { printf(&quot;检索的关键词过短！&quot;); continue; } struct Medicine * container[100]; int itr = 0; struct Medicine *p = mediStorage-&gt;next;//p是药仓，p1p2是新建链表 printf(&quot;\\n\\n\\n&quot;); while(p) { if(compStr(s,strlen(s),p-&gt;name,strlen(p-&gt;name))) { flag = 1; container[itr++] = p; printMargin(5); printf(&quot;%d、%s 单价 %d 元 %d 角 库存剩余 %d\\n\\n&quot;,itr, p-&gt;name, p-&gt;price/10, p-&gt;price%10, p-&gt;number); } p = p-&gt;next; } container[itr] = NULL; if(!flag) { printf(&quot;并没有找到该药品，请重新输入\\n&quot;); continue; } printf(&quot;请选择欲购买药品的序号:&quot;); int command; for(;;) { scanInt(&amp;command, 3); if((command &lt; 1)||(command &gt; itr)) printf(&quot;输入不合法，请重新输入:&quot;); else break; } p = container[command-1]; printf(&quot;您要购买：\\n%s 单价 %d 元 %d 角 库存剩余 %d\\n&quot;, p-&gt;name, p-&gt;price/10, p-&gt;price%10, p-&gt;number); for(;;) { printf(&quot;请输入数量:&quot;); scanInt(&amp;command, 3); if((command &lt; 0)||(command &gt; p-&gt;number)||(command &gt; 99)) printf(&quot;输入不合法，请重新输入:&quot;); else break; } if(!command) { printf(&quot;继续购买请输入1，结束购买请输入0:&quot;); for(;;) { scanInt(&amp;command, 3); if((command &lt; 0)||(command &gt; 1)) { printf(&quot;非法输入，请重新输入:&quot;); } else break; } if(command == 0) break; } else { p2 = (struct Medicine *)malloc(sizeof(struct Medicine)); p2-&gt;number = command; p2-&gt;next = NULL; p2-&gt;price = p-&gt;price; p1-&gt;next = p2; p-&gt;number -= command; newnode-&gt;treatment.totalMedicineCharge += (command* p-&gt;price); strcpy(p2-&gt;name,p-&gt;name); p1 = p2; } itr = -1; printf(&quot;继续购买请选择1，结束购买请选择0&quot;); for(;;) { scanInt(&amp;command, 2); if((command &lt; 0)||(command &gt; 1)) { printf(&quot;输入非法，请重新输入：&quot;); } else break; } if(command == 0) break; } printMedList(&amp;newnode-&gt;treatment.medicine); return ; } /*打印出某个科室的所有值班医生(不值班的不会被打印)*/ int printDeparList(int n) { if(countDepartment[n] &gt;= 20) { printMargin(40); printf(&quot;该科室患者已经达到上限20\\n&quot;); return -1; } printf(&quot;\\n\\n\\n&quot;); printMargin(40); printf(&quot;该科室目前有%d位患者\\n\\n\\n&quot;,countDepartment[n]); struct Doctor * p = doctor_departments[n].next; time_t rawtime; time(&amp;rawtime); struct tm *ti = localtime(&amp;rawtime); printMargin(40); printf(&quot;%s坐诊医生如下:\\n\\n\\n&quot;,departments[n]); int ii = 0; while(p) { if(p-&gt;workingHours[ti-&gt;tm_wday]) { printMargin(40); printf(&quot;| %d:医生：%s %s&quot;,++ii,p-&gt;name,DoctorLevel[p-&gt;level]); printf(&quot; 目前有%d名患者\\n&quot;,p-&gt;registed); printMargin(40);printf(&quot;|\\n&quot;); } p = p-&gt;next; } printMargin(44); return 0; } /*挂号函数*/ int registe() { countAllDoc(); printfMoneyStatus(); time_t timep; time(&amp;timep); char location[20] = &quot;data/&quot;; strftime(location+5,sizeof(location),&quot;%m%d&quot;,localtime(&amp;timep)); if ( access(location, F_OK) != 0) { mkdir(location); } location[9] = &#39;/&#39;; int money = 0; openUTDfile();//这里建立最新数据的链表。需要统计各个科室、各个医生挂了多少号 FILE *pf_money = fopen(&quot;data/money.txt&quot;,&quot;r&quot;); fscanf(pf_money,&quot;%d&quot;,&amp;money); fclose(pf_money); for(;;) { struct Data * newNode = (struct Data*) malloc(sizeof(struct Data)); newNode-&gt;next = NULL; newNode-&gt;treatment.totalExaminationFee = 0; newNode-&gt;treatment.totalMedicineCharge = 0; newNode-&gt;treatment.hospitalization.zhuyuanyajin = 0; printf(&quot;正在挂号...\\n\\n&quot;); time_t now; struct tm* tm_now; time(&amp;now); tm_now = localtime(&amp;now); int seq = (tm_now-&gt;tm_mon+1) * 10e6 + tm_now-&gt;tm_mday * 10e4; seq += (++sequence); printf(&quot;挂号序号:%d\\n&quot;,seq%1000); newNode-&gt;number = seq; int command = 0; int m; struct Doctor * p; for(;;) { printf(&quot;\\n\\n\\n\\n\\n\\n\\n\\n&quot;); for(int i = 0; i &lt; 5; ++i) { printMargin(40);printf(&quot;%d,%s&quot;,i+1,departments[i]); printf(&quot; 目前有患者%d人\\n\\n&quot;,countDepartment[i]); } printf(&quot;\\n\\n\\n\\n\\n\\n\\n\\n请选择(输入0则返回主菜单)：&quot;); scanInt(&amp;m,2); if((m &gt; 5)||(m &lt;0)) { printf(&quot;请正确输入！\\n&quot;); continue; } if(m == 0) { system(&quot;cls&quot;); return 0; } p = doctor_departments[m-1].next; system(&quot;cls&quot;); if(printDeparList(m-1) == 0) { break; } } int n; while(1) { printf(&quot;\\n\\n\\n&quot;); printMargin(10); printf(&quot;请输入医生序号，输入0则返回上一层（医生的患者上限为10人）:&quot;); scanInt(&amp;command,3); n = command; if(n &lt; 0) { printf(&quot;请正确输入\\n&quot;); continue; } if(n == 0) { free(newNode); break; } p = doctor_departments[m-1].next; while(p) { if((p-&gt;workingHours[tm_now-&gt;tm_wday])) { if(!(--n)) break; } p = p-&gt;next; } if(p == NULL) { printf(&quot;请正确输入\\n&quot;); continue; } if(p-&gt;registed &gt;= 10) { printf(&quot;该医生患者数已达上限\\n&quot;); continue; } else { ++(p-&gt;registed); break; } } if(!command) continue; system(&quot;cls&quot;); printf(&quot;%s\\n&quot;,p-&gt;name); strcpy(newNode-&gt;doctor.name,p-&gt;name); newNode-&gt;doctor.department = m; newNode-&gt;doctor.level = p-&gt;level; newNode-&gt;doctor.number = p-&gt;number; newNode-&gt;doctor.next = NULL; for(int i = 0; i &lt; 7; ++i) newNode-&gt;doctor.workingHours[i] = p-&gt;workingHours[i]; printf(&quot;请输入身份码（8位数字）：&quot;); while((scanInt(&amp;(newNode-&gt;ID),8)!= 8)) { printf(&quot;请检查输入长度!重新输入!\\n&quot;); } int num = countPatientDoc(newNode-&gt;ID,newNode-&gt;doctor.number); if(num) { printf(&quot;注意：您今天在%s 下已有挂号\\n&quot;,newNode-&gt;doctor.name); printf(&quot;如要取消本次挂号请输入0,否则输入其他数字\\n&quot;); scanInt(&amp;command,2); if(command == 0) { free(newNode); continue; } } countDepartment[newNode-&gt;doctor.department]++; printf(&quot;请输入患者姓名 :&quot;); scanName(newNode-&gt;name,10); for(;;) { printf(&quot;请输入性别，0为女，1为男\\n&quot;); int sex; scanInt(&amp;sex,3); if((sex &gt; 1)||(sex &lt; 0)) printf(&quot;请正确输入\\n&quot;); else { newNode-&gt;number += (sex * 10000); break; } } for(;;) { printf(&quot;请输入年龄 :&quot;); scanInt(&amp;(newNode-&gt;age),5); if((newNode-&gt;age &gt; 150)||(newNode-&gt;age&lt; 0)) { printf(&quot;请检查输入！\\n&quot;); } else { break; } } newNode-&gt;treatment.medicine.next = NULL; newNode-&gt;treatment.exminationFee.next = NULL; printf(&quot;如需购药请输入1， 输入其他数字则不购药\\n&quot;); newNode-&gt;treatment.totalExaminationFee = 0; newNode-&gt;treatment.totalMedicineCharge = 0; newNode-&gt;treatment.total = 0; scanInt(&amp;command,3); if(command == 1) buyMedicine(newNode); else newNode-&gt;treatment.medicine.next = NULL; printf(&quot;如需进行检查请输入1，否则输入其他数字\\n&quot;); scanInt(&amp;command,3); if(command == 1) selectExaminations(newNode); else newNode-&gt;treatment.exminationFee.next = NULL; printf(&quot;如需住院请输入1，否则输入其他数字\\n&quot;); scanInt(&amp;command,3); newNode-&gt;treatment.hospitalization.chuyuanshijian = 0; newNode-&gt;treatment.hospitalization.ruyuanshijian = 0; newNode-&gt;treatment.hospitalization.zhuyuanyajin = 0; if(command == 1) hospitalize(newNode); dataRear-&gt;next = newNode; dataRear = dataRear-&gt;next; printf(&quot;挂号成功！\\n&quot;); saveData(location); printf(&quot;序号：%d 姓名:%s &quot;,newNode-&gt;number,newNode-&gt;name); printf(&quot; ID %d 年龄 %d 医生：%s\\n\\n&quot;,newNode-&gt;ID,newNode-&gt;age,newNode-&gt;doctor.name); printf(&quot;输入1继续挂号，输入0退出挂号系统\\n&quot;); money += newNode-&gt;treatment.totalExaminationFee; money += newNode-&gt;treatment.totalMedicineCharge; money += newNode-&gt;treatment.hospitalization.zhuyuanyajin * 10; scanInt(&amp;command,1); if(!command) break; } int moneyy = money; pf_money = fopen(&quot;data/money.txt&quot;,&quot;w&quot;); fprintf(pf_money,&quot;%d&quot;,moneyy); fclose(pf_money); printfMoneyStatus(); printf(&quot;按任意键返回\\n&quot;); getchar(); system(&quot;cls&quot;); clearList(dataHead); return 0; } int nextDay(char *ori)//输入为&quot;data/1009/&quot;型字符串，输出为后一天的字符串，如“data/1010/” { if(ori[8]==&#39;0&#39;) { ori[8]=&#39;1&#39;; return 0; } if(ori[7] == &#39;3&#39;)//肯定为31号 { ori[7] = &#39;0&#39;; ori[8] = &#39;1&#39;; ori[6] += 1; return 0; } if(ori[8] == &#39;9&#39;) { ori[8] = &#39;0&#39;; ori[7] += 1; return 0; } ori[8] += 1; return 0; } int preDay(char *ori)//输入为&quot;data/1009/&quot;型字符串，输出为前一天的字符串，如“data/1008/” { if((ori[7] == &#39;0&#39;)&amp;&amp;(ori[8] == &#39;1&#39;)) { ori[7] = &#39;3&#39;; ori[8] = &#39;1&#39;; if(ori[6]==&#39;0&#39;) { ori[6] = &#39;9&#39;; ori[5] -= 1; } else { ori[6] -= 1; } return 0; } if(ori[8] == &#39;0&#39;) { ori[8] = &#39;9&#39;; ori[7] -= 1; return 0; } ori[8] -= 1; return 0; } /*患者的住院函数*/ void hospitalize(struct Data* newNode)//住院 { struct Data * p = inHospital; while(p) { if(newNode-&gt;ID == p-&gt;ID) { printf(&quot;该患者已经正在住院，无法重复办理住院\\n&quot;); return; } p = p-&gt;next; } int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31}; printf(&quot;请输入入院时间,格式：月 日 时如： \\&quot;9 10 10\\&quot;,数字间以空格间隔 \\n&quot;); int m,d,h,s; newNode-&gt;treatment.hospitalization.zhuyuanyajin = 0; int time1 = 0; for(;;) { scanInt(&amp;m, 2); scanInt(&amp;d, 2); scanInt(&amp;h, 2); s = 0; if((m &gt; 0)&amp;&amp;(m &lt; 13)&amp;&amp;(d &gt; 0)&amp;&amp; (d &lt;= months[m])&amp;&amp;(h &gt;= 0)&amp;&amp;(h &lt; 24)&amp;&amp;(s &gt;= 0)&amp;&amp;(s &lt; 60)) { } else { printf(&quot;请检查输入格式重新输入:&quot;); continue; } time1 = m * 1000000; time1 += (d * 10000); time1 += (h * 100); time_t now; struct tm* tm_now; time(&amp;now); tm_now = localtime(&amp;now); int tmp = (tm_now-&gt;tm_mon+1) * 1000000 + tm_now-&gt;tm_mday * 10000 + tm_now-&gt;tm_hour * 100; if(tmp &gt; time1) { printf(&quot;请保证入院时间晚于当前时间\\n&quot;); continue; } else break; } newNode-&gt;treatment.hospitalization.ruyuanshijian = time1; int m1,d1,h1; printf(&quot;请输入预计出院时间,格式：月 日 时如： \\&quot;9 10 10\\&quot;,数字间以空格间隔 \\n&quot;); int time2; for(;;) { scanInt(&amp;m1, 2); scanInt(&amp;d1, 2); scanInt(&amp;h1, 2); if((m1 &gt; 0)&amp;&amp;(m1 &lt; 13)&amp;&amp;(d1 &gt; 0)&amp;&amp; (d1 &lt;= months[m])&amp;&amp;(h1 &gt;= 0)&amp;&amp;(h1 &lt; 24)) { time2 = m1 * 1000000; time2 += (d1 * 10000); time2 += (h1 * 100); if(time1 &lt; time2) { } else { printf(&quot;请保证出院时间晚于入院时间\\n&quot;); continue; } time_t now; struct tm* tm_now; time(&amp;now); tm_now = localtime(&amp;now); int tmp = (tm_now-&gt;tm_mon+1) * 1000000 + tm_now-&gt;tm_mday * 10000 + tm_now-&gt;tm_hour; if(tmp &gt; time2) { printf(&quot;请保证出院时间晚于当前时间\\n&quot;); continue; } break; } else { printf(&quot;请检查输入格式\\n请重新输入出院时间：&quot;); } } newNode-&gt;treatment.hospitalization.chuyuanshijian = time2; int money = timeSpan(newNode-&gt;treatment.hospitalization.ruyuanshijian,newNode-&gt;treatment.hospitalization.chuyuanshijian) * 200; for(;;) { printf(&quot;请缴纳押金 至少为 %d元,至多为99900元，且必须为100的整数倍\\n&quot;, money+1000); scanInt(&amp;(newNode-&gt;treatment.hospitalization.zhuyuanyajin),7); if(((newNode-&gt;treatment.hospitalization.zhuyuanyajin) &lt; money+1000) ||(newNode-&gt;treatment.hospitalization.zhuyuanyajin &gt; 99999)||(newNode-&gt;treatment.hospitalization.zhuyuanyajin%100)) printf(&quot;非法输入\\n&quot;); else break; } printf(&quot;已缴纳！\\n&quot;); struct Data* node_hospital = (struct Data*)malloc(sizeof(struct Data)); node_hospital-&gt;next = NULL; if(inHospital == NULL) { inHospital = node_hospital; inHospitalRear = node_hospital; } else { inHospitalRear-&gt;next = node_hospital; inHospitalRear = node_hospital; } node_hospital-&gt;age = newNode-&gt;age; node_hospital-&gt;ID = newNode-&gt;ID; node_hospital-&gt;number = newNode-&gt;number; strcpy(node_hospital-&gt;name,newNode-&gt;name); node_hospital-&gt;treatment.hospitalization.chuyuanshijian = newNode-&gt;treatment.hospitalization.chuyuanshijian; node_hospital-&gt;treatment.hospitalization.ruyuanshijian = newNode-&gt;treatment.hospitalization.ruyuanshijian; node_hospital-&gt;treatment.hospitalization.zhuyuanyajin = newNode-&gt;treatment.hospitalization.zhuyuanyajin; node_hospital-&gt;treatment.exminationFee.next = NULL; node_hospital-&gt;treatment.medicine.next = NULL; return; } /*患者进行检查的函数*/ void selectExaminations(struct Data * newnode) { char s[20]; struct ExaminationFee *p1 = &amp;(newnode-&gt;treatment.exminationFee),*p2; struct ExaminationFee * container[200]; int command; for(;;) { int flag = 0; printf(&quot;请输入检查项目名，输入exit退出界面\\n&quot;); scanStr(s,10); if(s[0]==&#39;e&#39;) break; if(strlen(s) &lt; 3) { printf(&quot;检索关键词过短&quot;); continue; } struct ExaminationFee *p = examlists; int itr = 0; printf(&quot;\\n\\n\\n&quot;); while(p) { if(compStr(s,strlen(s),p-&gt;name,strlen(p-&gt;name))) { container[itr++] = p; flag = 1; printMargin(5); printf(&quot;%d 、%s 单价： %d元 %d角\\n\\n&quot;,itr,p-&gt;name, p-&gt;cost/10, p-&gt;cost % 10); } p = p-&gt;next; } if(!flag) { printf(&quot;未找到匹配的检查项目，请重新输入\\n&quot;); continue; } for(;;) { printf(&quot;请选择检查项目的序号,选择0则重新检索:&quot;); scanInt(&amp;command, 3); if((command &lt; 0) ||(command &gt; itr)) { printf(&quot;输入非法!\\n&quot;); } else break; } if(command == 0) continue; p = container[command - 1]; printf(&quot;%s 已选择√\\n&quot;,p-&gt;name); newnode-&gt;treatment.totalExaminationFee += p-&gt;cost; p2 = (struct ExaminationFee*) malloc (sizeof(struct ExaminationFee)); p2-&gt;cost = p-&gt;cost; strcpy(p2-&gt;name,p-&gt;name); p2-&gt;next = NULL; p1-&gt;next = p2; p1 = p2; printf(&quot;继续选择请选择1，结束选择请选择0\\n&quot;); for(;;) { scanInt(&amp;command, 2); if((command &lt;0)||(command &gt; 1)) { printf(&quot;输入非法！\\n&quot;); } else break; } if(command == 0) break; } printExamList(&amp;(newnode-&gt;treatment.exminationFee)); return; } /*主菜单*/ void menu() { int (*mainMenu[5])() = {registe,inpatientDapart,dataViewMenu,dataChangeMenu}; int command = 0; while(1) { system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;|----------主菜单----------|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|&quot;);printMargin(8); printf(&quot;1、挂号&quot;);printMargin(11);printf(&quot;|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|&quot;);printMargin(8); printf(&quot;2、住院部&quot;);printMargin(9);printf(&quot;|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|&quot;);printMargin(8); printf(&quot;3、浏览数据&quot;);printMargin(7);printf(&quot;|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|&quot;);printMargin(8); printf(&quot;4、修改数据&quot;);printMargin(7);printf(&quot;|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|&quot;);printMargin(8); printf(&quot;0、退出系统&quot;);printMargin(7);printf(&quot;|\\n&quot;); printMargin(40); printf(&quot;| |\\n&quot;); printMargin(40); printf(&quot;|--------------------------|\\n\\n\\n\\n\\n\\n\\n&quot;); printf(&quot;请选择：&quot;); scanInt(&amp;command,1); if((command &gt; 4)||(command&lt;0)) { printf(&quot;请检查输入！\\n&quot;); continue; } if(!command) break; system(&quot;cls&quot;); mainMenu[command-1](); } } /*从文件中加载医院所有的检查项目*/ void inputExamData() { FILE *pf_exa = fopen(&quot;hospital/examination.txt&quot;,&quot;r&quot;); examlists = (struct ExaminationFee *)malloc(sizeof(struct ExaminationFee)); struct ExaminationFee * p = examlists,*p1; while(!feof(pf_exa)) { p1 = (struct ExaminationFee *)malloc(sizeof(struct ExaminationFee)); int tmp; fscanf(pf_exa,&quot;%d%s%d&quot;,&amp;tmp,p1-&gt;name,&amp;(p1-&gt;cost)); p1-&gt;next = NULL; p-&gt;next = p1; p = p1; } fclose(pf_exa); } int clearExamList() { struct ExaminationFee * p, *p1; p = examlists; while(p) { p1 = p; p = p-&gt;next; free(p1); } return 0; } void openUTDfile()//打开最新的数据文件 { time_t timep; time(&amp;timep); char location[20] = &quot;data/&quot;; strftime(location+5,sizeof(location),&quot;%m%d&quot;,localtime(&amp;timep)); location[9] = &#39;/&#39;; location[10] = 0; dataHead = input(location); return; } int scanInt(int *num,int length)//输入整型变量，回车键或空格键结束输入，非法字符会被忽略,过长输入会被截取,输入过长返回-1; { *num = 0; char c = getchar(); int len = 0; while((c &gt; &#39;9&#39;)||(c &lt; &#39;0&#39;)) { c = getchar(); } while((c != &#39;\\n&#39;) &amp;&amp; (c != &#39; &#39;)) { if((c &lt;= &#39;9&#39;)&amp;&amp; (c &gt;= &#39;0&#39;)) { *num *= 10; *num += (c - &#39;0&#39;); ++len; if(len &gt;= length) { c = getchar(); if(c == &#39;\\n&#39;) return len; while((c != &#39;\\n&#39;) &amp;&amp; (c != &#39; &#39;)) { c = getchar(); } return -1; } } c = getchar(); } return len; } int scanName(char *s,int length)//输入姓名,返回-1为输入过长,非法字符会被过滤 { char c = getchar(); while(!((c &lt; 0)||((c &lt;= &#39;Z&#39;)&amp;&amp;(c &gt;= &#39;A&#39;))||((c &lt;= &#39;z&#39;)&amp;&amp;(c &gt;= &#39;a&#39;)))) { c = getchar(); } s[0] = c; int i = 0; if(c &lt; 0)//中文 { while(c != &#39;\\n&#39;) { c = getchar(); if(c &gt;= 0) continue; s[++i] = c; if(i &gt;= length-1) { s[++i] = 0; while(c != &#39;\\n&#39;) { c = getchar(); } return -1; } } } else { while(c != &#39;\\n&#39;) { c = getchar(); if(!(((c &lt;= &#39;Z&#39;)&amp;&amp;(c &gt;= &#39;A&#39;))||((c &lt;= &#39;z&#39;)&amp;&amp;(c &gt;= &#39;a&#39;))||(c == &#39; &#39;))) continue; s[++i] = c; if(i &gt;= length-1) { s[++i] = 0; while(c != &#39;\\n&#39;) { c = getchar(); } return -1; } } } s[++i] = 0; return i; } int scanStrNum(char *num,int length)//输入数字的字符串,回车结束输入，其他非数字的字符会被过滤，返回值为长度，长度过长返回-1. { char c = getchar(); int i = 0; while((c &gt; &#39;9&#39;) || (c &lt; &#39;0&#39;)) { c = getchar(); } while(c != &#39;\\n&#39;) { if((c &lt;= &#39;9&#39;)&amp;&amp;(c &gt;= &#39;0&#39;)) { num[i++] = c; if(i &gt;= length) { num[i] = 0; while(c != &#39;\\n&#39;) { c = getchar(); } return -1; } } c = getchar(); } num[i] = 0; return (i-1); } void saveHosData() { FILE *pf = fopen(&quot;hospital/hospital.txt&quot;,&quot;w&quot;); struct Data * p = inHospital; while(p) { int sex = (p-&gt;number % 100000) / 10000; fprintf(pf,&quot;%08d %20s %d %03d %08d &quot;,p-&gt;ID,p-&gt;name,sex ,p-&gt;age,p-&gt;treatment.hospitalization.ruyuanshijian); fprintf(pf,&quot;%08d %08d\\n&quot;,p-&gt;treatment.hospitalization.chuyuanshijian,p-&gt;treatment.hospitalization.zhuyuanyajin); p = p-&gt;next; } fclose(pf); } /*加载住院数据*/ void loadHospitalizeData() { inHospital = NULL; inHospitalRear = NULL; FILE *pf = fopen(&quot;hospital/hospital.txt&quot;,&quot;r&quot;); if(!pf) return; inHospital = (struct Data*)malloc(sizeof(struct Data)); inHospital-&gt;treatment.medicine.next = NULL; inHospital-&gt;treatment.exminationFee.next = NULL; struct Data *p = inHospital, *p1; p-&gt;next = NULL; while(!feof(pf)) { int sex; p1 = p; p-&gt;next = (struct Data*)malloc(sizeof(struct Data)); p = p-&gt;next; p-&gt;next = NULL; p-&gt;treatment.medicine.next = NULL; p-&gt;treatment.exminationFee.next = NULL; fscanf(pf,&quot;%d%s%d%d%d&quot;,&amp;(p-&gt;ID),p-&gt;name,&amp;sex,&amp;(p-&gt;age),&amp;(p-&gt;treatment.hospitalization.ruyuanshijian)); fscanf(pf,&quot;%d%d&quot;,&amp;(p-&gt;treatment.hospitalization.chuyuanshijian),&amp;(p-&gt;treatment.hospitalization.zhuyuanyajin)); p-&gt;number = sex * 10000; } inHospitalRear = p1; p1-&gt;next = NULL; free(p); p = inHospital; inHospital = p-&gt;next; free(p); fclose(pf); } void countAllDoc()//统计所有医生的繁忙情况 { openUTDfile(); extern int countDepartment[7]; extern struct Doctor doctor_departments[5]; extern struct Data* dataHead; for(int i = 0; i &lt; 5; ++i) { countDepartment[i] = 0; struct Doctor *p_doc = doctor_departments[i].next; while(p_doc) { struct Data * p_data = dataHead-&gt;next; p_doc-&gt;registed = 0; while(p_data) { if(p_data-&gt;doctor.number == p_doc-&gt;number) { ++(p_doc-&gt;registed); ++countDepartment[i]; } p_data = p_data-&gt;next; } p_doc = p_doc-&gt;next; } } return; } int showDepartStatus()//繁忙情况统计的交互界面 { countAllDoc(); w_countAllDoc(); system(&quot;cls&quot;); extern struct Doctor doctor_departments[5]; extern char departments[7][20]; printf(&quot;要查看哪个科室的情况? 输入0返回上一层\\n&quot;); for(int i = 0; i &lt; 5; ++i) { printMargin(40); printf(&quot;%d、%s\\n\\n&quot;,i+1,departments[i]); } printf(&quot;请选择：&quot;); int command; for(;;) { scanInt(&amp;command,3); if((command &lt; 0)||(command &gt; 5)) { printf(&quot;输入非法\\n&quot;); } else break; } system(&quot;cls&quot;); printMargin(40); printf(&quot;%s 所有医生挂号状况如下：\\n\\n\\n&quot;,departments[command-1]); printMargin(40); printf(&quot;该科室今天共有%d个病人\\n&quot;,countDepartment[command-1]); showDocRegisted(doctor_departments[command-1].next); printMargin(40);printf(&quot;按任意键返回上一层&quot;); getchar(); return 0; } void showDocRegisted(struct Doctor *head)//以科室头指针为参数，显示该科室医生的繁忙情况 { char dic[7][3] = {&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;}; struct Doctor * p_doc = head; int counter = 0; while(p_doc) { int workDay = 0; printMargin(40); printf(&quot;%d %10s 今天共有%2d病人 本周共有%d病人\\n&quot;,++counter,p_doc-&gt;name,p_doc-&gt;registed,p_doc-&gt;w_registed); printMargin(40);printf(&quot;上班时间： 周&quot;); for(int i = 0; i &lt; 7; ++i) { if(p_doc-&gt;workingHours[i]) { printf(&quot;%s、&quot;,dic[i]); ++workDay; } } printf(&quot;\\n&quot;); printMargin(40); printf(&quot;今天挂号率:%.2f%% 本周挂号率: %.2f%%\\n\\n&quot;,(float)(p_doc-&gt;registed)*10, (float)(p_doc-&gt;w_registed*10/workDay)); p_doc = p_doc-&gt;next; } return; } int leaveHospital(struct Data *p) { time_t now; struct tm* tm_now; time(&amp;now); tm_now = localtime(&amp;now); int tmp = (tm_now-&gt;tm_mon+1) * 1000000 + tm_now-&gt;tm_mday * 10000 + tm_now-&gt;tm_hour; extern struct Data* inHospital; int hos_time = timeSpan(p-&gt;treatment.hospitalization.ruyuanshijian,tmp); int hos_money = 200 * hos_time; printf(&quot;您共住院%d天，产生住院费%d元 住院押金剩余%d&quot;,hos_time,hos_money,p-&gt;treatment.hospitalization.zhuyuanyajin-hos_money ); if(p-&gt;treatment.hospitalization.zhuyuanyajin-hos_money &gt;= 0) printf(&quot;余额已返还，请确认\\n&quot;); else { printf(&quot;请缴纳欠款！\\n&quot;); } FILE *pf_money = fopen(&quot;data/money.txt&quot;,&quot;r+&quot;); fseek(pf_money,0,SEEK_SET); int money; fscanf(pf_money,&quot;%d&quot;,&amp;money); if(p-&gt;treatment.hospitalization.zhuyuanyajin-hos_money &gt;= 0) money = money - p-&gt;treatment.hospitalization.zhuyuanyajin + hos_money; else money = money + p-&gt;treatment.hospitalization.zhuyuanyajin - hos_money; fseek(pf_money,0,SEEK_SET); fprintf(pf_money,&quot;%d&quot;,money); fclose(pf_money); printfMoneyStatus(); printf(&quot;出院成功！\\n\\n\\n\\n\\n\\n&quot;); printf(&quot;按任意键返回主菜单\\n&quot;); getchar(); system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;出院成功！\\n\\n\\n\\n\\n\\n&quot;); printf(&quot;按任意键返回主菜单\\n&quot;); getchar(); return 0; } int patientAdminMenu() { struct Data* p = inHospital; struct Data * p1 = p; printf(&quot;请输入病人ID,输入0返回上一层\\n&quot;); int id; for(;;) { int length = scanInt(&amp;id, 9); if(!id) return 0; if(length != 8) { printf(&quot;输入非法！请重新输入:&quot;); continue; } while(p) { if(p-&gt;ID == id) break; p1 = p; p = p-&gt;next; } if(p == NULL) printf(&quot;未找到该患者\\n&quot;); else break; } system(&quot;cls&quot;); showPatientsInfo(p); printf(&quot;\\n\\n\\n&quot;); printMargin(40); printf(&quot;1、办理出院\\n\\n&quot;); printMargin(40); printf(&quot;2、延迟出院\\n\\n&quot;); printMargin(40); printf(&quot;0、退出系统\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;请选择：&quot;); int command; for(;;) { scanInt(&amp;command,3); if((command &lt; 0)|| (command &gt; 2)) printf(&quot;输入非法&quot;); else break; } switch(command) { case 1: { leaveHospital(p); if(p == inHospital) inHospital = p-&gt;next; else p1-&gt;next = p-&gt;next; free(p); break; } case 2: delayTime(p); break; case 0: break; } return 0; } int delayTime(struct Data *p) { int b; int money = 0; while(1) { int a = p-&gt;treatment.hospitalization.chuyuanshijian; int t[3]; printf(&quot;请输入月 日 时中间用空格分隔，如:9 2 1 :&quot;); scanInt(&amp;(t[0]),2); scanInt(&amp;(t[1]),2); scanInt(&amp;(t[2]),2); b = t[0] * 1000000 + t[1] * 10000 + t[2] * 100; if(timeSpan(a,b) != 0) { int cost = timeSpan(p-&gt;treatment.hospitalization.ruyuanshijian,b) * 200; if(cost+1000 &gt; p-&gt;treatment.hospitalization.zhuyuanyajin) printf(&quot;请续缴住院费，至少缴纳%d 元,至多缴纳99999元&quot;,cost+1000 - p-&gt;treatment.hospitalization.zhuyuanyajin); else break; for(;;) { scanInt(&amp;money, 7); if((money &lt; cost+1000 - p-&gt;treatment.hospitalization.zhuyuanyajin)||(money &gt; 99999)) printf(&quot;请检查输入！\\n&quot;); else break; } break; } printf(&quot;输入不合法，请检查\\n&quot;); } printf(&quot;操作成功！ 任意键返回上一级\\n&quot;); getchar(); FILE *pf_money = fopen(&quot;data/money.txt&quot;,&quot;r+&quot;); int money_; fseek(pf_money,0,SEEK_SET); fscanf(pf_money,&quot;%d&quot;,&amp;money_); money_ = money + money_; fseek(pf_money,0,SEEK_SET); fprintf(pf_money,&quot;%d&quot;,money_); fclose(pf_money); p-&gt;treatment.hospitalization.chuyuanshijian = b; printfMoneyStatus(); printf(&quot;操作成功！ 任意键返回上一级\\n&quot;); getchar(); return 0; } int timeSpan(int start, int end)//日期不合法返回0 { int a = start / 100; int b = end / 100; if(end &lt;= start) return 0; int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31}; int m1,d1,h1,m2,d2,h2; h1 = a % 100; a /= 100; d1 = a % 100; a /= 100; m1 = a; h2 = b % 100; b /= 100; d2 = b % 100; b /= 100; m2 = b; if((m1&lt;1)||(m1&gt;12)||(m2&lt;1)||(m2&gt;12)) return -1; if((d1&lt;1)||(d1&gt;months[m1])||(d2&lt;1)||(d2&gt;months[m2])) return -1; if((h1&lt;0)||(h1&gt;23)||(h2&lt;0)||(h2&gt;23)) return -1; int sum = 0; for(int i = m1; i &lt; m2; ++i) sum += months[i]; sum += d2; sum -= d1; if(h2 &gt; 8) ++sum; return sum; } int printfMoneyStatus() { FILE *pf_money = fopen(&quot;data/money.txt&quot;,&quot;r&quot;); int money; fscanf(pf_money,&quot;%d&quot;,&amp;money); printf(&quot;\\n\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;当前医院总营业额为%d元%d角\\n\\n\\n\\n\\n\\n&quot;,money/10,money%10); fclose(pf_money); return 0; } int inputDate(int *month, int *day)//输入月、日，并检查格式 { int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31}; printf(&quot;请输入月 日 中间用空格隔开&quot;); for(;;) { scanInt(month,9); if((*month &gt; 12)||(*month &lt;0)) { printf(&quot;输入不正确，请检查\\n&quot;); } else break; } for(;;) { scanInt(day,9); if((*day &lt; 0) || (*day &gt; months[*month]) ) { printf(&quot;输入不正确，请检查\\n&quot;); } else break; } return 0; } struct Data* reInput(const char* dir)//打开以路径“dir”为参数的所有文件,路径格式：“data/1001/”,并逆序建立链表。 { FILE *pf, *pf_med, *pf_exam; char position[40]; strcpy(position,dir); strcpy(position+10,&quot;data.txt&quot;); sequence = 0; struct Data * base = (struct Data*)malloc(sizeof(struct Data)); base-&gt;next = NULL; if(pf = fopen(position,&quot;r&quot;),pf==NULL) { dataRear = base; dataHead = base; return base; } strcpy(position+10,&quot;examination.txt&quot;); pf_exam = fopen(position,&quot;r&quot;); strcpy(position+10,&quot;medicine.txt&quot;); pf_med = fopen(position,&quot;r&quot;); struct Data *p1, *p2 = NULL; p1 = base; int itr = 1; int flag = 0; fseek(pf,-123,SEEK_END); while(!flag) { int countScan = 0; p2 = (struct Data *)malloc(sizeof(struct Data)); p2-&gt;next = NULL; p1-&gt;next = p2; countScan = fscanf(pf,&quot;%d%d%s%d%d%s&quot;,&amp;(p2-&gt;number),&amp;(p2-&gt;ID),p2-&gt;name,&amp;(p2-&gt;age),&amp;(p2-&gt;doctor.number),p2-&gt;doctor.name); if(countScan != 6) { reSeek(pf); continue; } countScan = fscanf(pf,&quot;%d%d&quot;,&amp;p2-&gt;doctor.level,&amp;p2-&gt;doctor.department); if(countScan != 2) { reSeek(pf); continue; } countScan = 0; int i; for(i = 0; i &lt; 7; ++i) countScan += fscanf(pf,&quot;%d&quot;,&amp;(p2-&gt;doctor.workingHours[i])); if(countScan != 7) { reSeek(pf); continue; } if(fscanf(pf,&quot;%d&quot;,&amp;(p2-&gt;treatment.total))!= 1) { reSeek(pf); continue; } int med_start,med_end,exam_start,exam_end; countScan = fscanf(pf,&quot;%d%d%d%d&quot;,&amp;med_start,&amp;med_end,&amp;exam_start,&amp;exam_end); if(countScan != 4) { reSeek(pf); continue; } countScan = fscanf(pf,&quot;%d%d&quot;,&amp;(p2-&gt;treatment.hospitalization.ruyuanshijian),&amp;(p2-&gt;treatment.hospitalization.chuyuanshijian)); if(countScan != 2) { reSeek(pf); continue; } p2-&gt;treatment.medicine.next = NULL; fgetc(pf); p2-&gt;treatment.totalMedicineCharge = buildMedList(&amp;(p2-&gt;treatment.medicine),pf_med,med_start,med_end); p2-&gt;treatment.totalExaminationFee = buildExamList(&amp;(p2-&gt;treatment.exminationFee), pf_exam,exam_start,exam_end); p1 = p2; flag = fseek(pf,-(++itr) * 123,SEEK_END); } dataRear = p1; fclose(pf); fclose(pf_exam); fclose(pf_med); return base; } int viewUTDdata(int n)//打开最新的数据文件 { system(&quot;cls&quot;); extern char departments[7][20]; extern struct Data* dataHead; struct Data* dataHeadToDel[100]; int i_del = 0; if(n &gt; 100) { printf(&quot;最多查看100条数据\\n&quot;); return -1; } time_t timep; time(&amp;timep); char location[20] = &quot;data/&quot;; strftime(location+5,sizeof(location),&quot;%m%d&quot;,localtime(&amp;timep)); location[9] = &#39;/&#39;; location[10] = 0; int count = 0; struct Data *container[120]; while(count &lt; n) { dataHead = reInput(location); struct Data *p = dataHead-&gt;next; if(!p) { free(dataHead); } else { dataHeadToDel[i_del++] = dataHead; } printf(&quot;数据日期：%c%c月%c%c日:\\n&quot;,location[5],location[6],location[7],location[8]); while(p) { container[count] = p; printf(&quot;---------------------\\n&quot;); printf(&quot;%d、 &quot;,++count); printf(&quot;序号：%d 患者姓名：%s ID:%d 患者年龄： %d &quot;, p-&gt;number, p-&gt;name,p-&gt;ID, p-&gt;age); printf(&quot;主治医生：%s %s %s 工号:%d \\n药品费： %d元%d角\\n&quot;,departments[p-&gt;doctor.department],DoctorLevel[p-&gt;doctor.level],p-&gt;doctor.name,p-&gt;doctor.number,(p-&gt;treatment.totalMedicineCharge)/10,(p-&gt;treatment.totalMedicineCharge)%10); printMedList(&amp;(p-&gt;treatment.medicine)); printf(&quot;检查费： %d元 %d角&quot;,(p-&gt;treatment.totalExaminationFee)/10,(p-&gt;treatment.totalExaminationFee)%10); printExamList(&amp;(p-&gt;treatment.exminationFee)); printf(&quot;\\n\\n\\n\\n&quot;); p = p-&gt;next; if(count &gt;= n) break; } preDay(location); } container[count] = NULL; for(;;) {printMargin(40); printf(&quot;1：按医生筛选数据\\n&quot;); printMargin(40); printf(&quot;2：按患者ID筛选数据\\n&quot;); printMargin(40); printf(&quot;3：按科室筛选数据\\n&quot;); printMargin(40); printf(&quot;0: 退出\\n&quot;); int command; for(;;) { printf(&quot;请选择：&quot;); scanInt(&amp;command,3); if((command &lt;0)||(command &gt; 3)) { printf(&quot;输入不合法\\n&quot;); } else break; } switch(command) { case 1: { int id; printf(&quot;请输入医生ID(8位):&quot;); for(;;) { if(scanInt(&amp;id,9) != 8) { printf(&quot;数据非法！请重新输入\\n&quot;); } else break; } viewByDoctorID(container,id); break; } case 2: { int id; printf(&quot;请输入患者ID(8位):&quot;); for(;;) { if(scanInt(&amp;id,9) != 8) { printf(&quot;数据非法！请重新输入\\n&quot;); } else break; } viewByPatientID(container,id); break; } case 3: { int nn; for(int i = 0; i &lt; 5; ++i) printf(&quot;%d、%s\\n&quot;,i+1,departments[i]); printf(&quot;请选择：&quot;); for(;;) { scanInt(&amp;nn,3); if((nn &lt; 1)||(nn &gt; 5)) { printf(&quot;输入非法\\n&quot;); } else break; } viewByDepart(container,nn-1); break; } case 0:break; } if(!command) break; } for(int i = 0; i &lt; i_del; ++i) clearList(dataHeadToDel[i]); return 0; } void w_countAllDoc()//统计所有医生本周的繁忙情况 { extern struct Doctor doctor_departments[5]; struct Doctor * p_doc; int count_w = 0; time_t timep; time(&amp;timep); char location[20] = &quot;data/&quot;; strftime(location+5,sizeof(location),&quot;%m%d&quot;,localtime(&amp;timep)); location[9] = &#39;/&#39;; location[10] = 0; dataHead = input(location); for(int i = 0; i &lt; 5; ++i) { p_doc = doctor_departments[i].next; while(p_doc) { p_doc-&gt;w_registed = 0; p_doc = p_doc-&gt;next; } } while(count_w &lt; 7)//打开7天的数据 { if(dataHead-&gt;next)//导入成功 { ++count_w; for(int i = 0; i &lt; 5; ++i) { p_doc = doctor_departments[i].next; while(p_doc) { struct Data * p = dataHead-&gt;next; while(p) { if(p-&gt;doctor.number == p_doc-&gt;number) { ++(p_doc-&gt;w_registed); } p = p-&gt;next; } p_doc = p_doc-&gt;next; } } } preDay(location); clearList(dataHead); dataHead = input(location); } } int showPatientsInHospital() { system(&quot;cls&quot;); printf(&quot;当前住院患者如下:\\n\\n&quot;); struct Data *p = inHospital; int count = 0; while(p) { ++count; printf(&quot;------------------------------------------------------------\\n&quot;); printf(&quot;%d、 &quot;,count); showPatientsInfo(p); printf(&quot;\\n------------------------------------------------------------\\n&quot;); printf(&quot;\\n\\n&quot;); p = p-&gt;next; } printf(&quot;按任意键返回上一级\\n&quot;); getchar(); return 0; } int scanStr(char *s, int length) { int count = 0; char c; while(count &lt; length) { c = getchar(); if(c == &#39;\\n&#39;) break; s[count++] = c; } s[count] = 0; while(c != &#39;\\n&#39;) { c = getchar(); ++count; } return count; } int dataChangeMenu() { printMargin(40); printf(&quot;执行敏感操作，需要您输入密码\\n&quot;); printf(&quot;\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); char pass[20]; char* key = deCode(); for(;;) { printf(&quot;请输入密码，若要退出系统请直接按回车:&quot;); int length = scanStr(pass,15); if(length == 0) return 0; if(strcmp(pass,key)) { printf(&quot;密码错误！\\n&quot;); } else { printf(&quot;密码正确，正在载入\\n&quot;); loading(); system(&quot;cls&quot;); break; } } free(key); for(;;) {printf(&quot;\\n\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;1、诊断记录修改\\n\\n&quot;); printMargin(40); printf(&quot;2、密码修改\\n\\n&quot;); printMargin(40); printf(&quot;0、返回主菜单\\n\\n\\n\\n\\n\\n\\n\\n&quot;); int command; for(;;) { printf(&quot;请选择序号：&quot;); scanInt(&amp;command,3); if((command &gt; 2)||(command &lt; 0)) { printf(&quot;输入非法！\\n&quot;); } else break; } if(command == 0) return 0; if(command == 1) { changeDataMenu(); } else if (command == 2) { printf(&quot;请设置新密码\\n&quot;); setPassWord(); } else { printf(&quot;系统构建中\\n\\n&quot;); printf(&quot;按任意键返回主菜单\\n\\n&quot;); getchar(); } } return 0; } int changeDoctorData(struct Doctor *p) { extern char departments[7][20]; extern const char DoctorLevel[5][12]; int command; for(;;) { printf(&quot;请选择需要修改哪一项:\\n&quot;); printf(&quot;1、医生姓名 2、 医生职级 3、医生科室\\n&quot;); scanInt(&amp;command, 2); if((command &lt; 1)||(command &gt; 3)) { printf(&quot;输入不合法，请检查 \\n&quot;); } else break; } switch(command) { case 2: { printf(&quot;请选择修改后的医生职级(输入序号):&quot;); printf(&quot;1:%s\\n2:%s\\n3:%s\\n4:%s\\n&quot;,DoctorLevel[1],DoctorLevel[2],DoctorLevel[3],DoctorLevel[4]); for(;;) { int n; scanInt(&amp;n,4); if((n &lt; 1)||(n &gt; 4)) printf(&quot;输入不合法！\\n&quot;); else { p-&gt;level = n; break; } } break; } case 1: { printf(&quot;修改姓名:&quot;); scanName(p-&gt;name,20); break; } case 3: { printf(&quot;修改科室(输入序号):&quot;); printf(&quot;1:%s\\n2:%s\\n3:%s\\n4:%s\\n5:%s\\n\\n&quot;,departments[0],departments[1],departments[2],departments[3],departments[4]); for(;;) { int n; scanInt(&amp;n,4); if((n &lt; 1)||(n &gt; 5)) printf(&quot;输入不合法！\\n&quot;); else { p-&gt;department = n-1; break; } } break; } } printf(&quot;修改成功！修改后的医生信息为：&quot;); printf(&quot;%s %s %s \\n&quot;,departments[p-&gt;department],DoctorLevel[p-&gt;level],p-&gt;name); return 0; } int changeExamList(struct ExaminationFee * head) { struct ExaminationFee *p = head-&gt;next; struct ExaminationFee * line[200]; int i = 0; while(p) { line[i] = p; printf(&quot;%d)、 项目名： %15s 单价：%5d \\n&quot;,++i,p-&gt;name,p-&gt;cost); p = p-&gt;next; } line[i] = NULL; int command; for(;;) { printf(&quot;请选择需要执行的操作：1、增加一条数据 2、删除一条数据 3、修改数据\\n&quot;); scanInt(&amp;command,3); if((command &gt;3) || (command &lt; 1)) { printf(&quot;输入不合法\\n&quot;); } else break; } switch (command) { case 1://插入一条数据 { struct ExaminationFee * pnew = (struct ExaminationFee *) malloc (sizeof(struct ExaminationFee)); pnew-&gt;next = NULL; printf(&quot;请输入检查项目名称：&quot;); scanStr(pnew-&gt;name,14); for(;;) { printf(&quot;请输入检查项目价格（格式： 元 角,最高不超过99999元） 中间用空格隔开：&quot;); int m, n; for(;;) { scanInt(&amp;m, 6); scanInt(&amp;n,3); if((m &lt; 0)||(m &gt; 99999)||(n &lt; 0)||(n &gt; 9)) { printf(&quot;请检查输入格式\\n&quot;); } else { pnew-&gt;cost = m * 10 + n; break; } } } break; } case 2://删除一条数据 { if(!i)//链表为空 { printf(&quot;没有可删除的数据\\n&quot;); break; } printf(&quot;请输入欲删除的数据序号\\n&quot;); for(;;) { int command; scanInt(&amp;command,3); if((command &lt; 0)||(command &gt; i)) { printf(&quot;请检查输入格式!\\n&quot;); } else { if(command == 1) { free(line[0]); head-&gt;next = NULL; } else { free(line[command - 1]); line[command - 2]-&gt;next = line[command]; } printf(&quot;已删除&quot;); break; } } break; } case 3://修改一条数据 { int command; struct ExaminationFee *pp; for(;;) { printf(&quot;请输入欲修改的数据序号：&quot;); scanInt( &amp;command, 3); if((command &gt; i)||(command &lt; 0)) { printf(&quot;输入不合法！\\n&quot;); } else { pp = line[command - 1]; break; } } printf(&quot;请输入检查项目名称：&quot;); scanStr(pp-&gt;name,14); for(;;) { printf(&quot;请输入检查项目价格（格式： 元 角,最高不超过99999元） 中间用空格隔开：&quot;); int m, n; for(;;) { scanInt(&amp;m, 6); scanInt(&amp;n,3); if((m &lt; 0)||(m &gt; 99999)||(n &lt; 0)||(n &gt; 9)) { printf(&quot;请检查输入格式\\n&quot;); } else { pp-&gt;cost = m * 10 + n; break; } } } break; } } p = head-&gt;next; printf(&quot;修改后数据：\\n&quot;); i = 0; while(p) { line[i] = p; printf(&quot;%d)、 项目名： %15s 单价：%5d \\n&quot;,++i,p-&gt;name,p-&gt;cost); p = p-&gt;next; } return 0; } int changeDataMenu() { extern struct Data* dataHead; char position[20] = &quot;data/&quot;; int start_m, start_d; system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n\\n&quot;); printf(&quot;要修改哪天的数据呢？\\n&quot;); inputDate(&amp;start_m,&amp;start_d); position[5] = start_m / 10 + &#39;0&#39;; position[6] = start_m % 10 + &#39;0&#39;; position[7] = start_d / 10 + &#39;0&#39;; position[8] = start_d % 10 + &#39;0&#39;; position[9] = &#39;/&#39;; position[10] = 0; dataHead = input(position); if(changeData() == -1) { printf(&quot;\\n\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;未找到这一天的数据，按任意键返回上一层\\n&quot;); getchar(); system(&quot;cls&quot;); } saveData(position); clearList(dataHead); return 0; } int setPassWord()//加密控件 { char key[21]; int length; for(;;) { printf(&quot;请输入新密码(8到16位):&quot;); length = scanStr(key,17); if((length &gt; 16)||(length &lt; 8)) { printf(&quot;请检查输入长度\\n&quot;); continue; } printf(&quot;请再次输入：&quot;); char key2[20]; scanStr(key2,18); if(strcmp(key,key2)) { printf(&quot;两次输入密码不一致，请检查\\n&quot;); continue; } break; } srand(time(0)); FILE *pf = fopen(&quot;data/key.txt&quot;,&quot;wb&quot;); for(int i = 0; i &lt; length; ++i) { for(int j = 0; j &lt; 7; ++j) { int num = rand()%128; int bi = 1 &lt;&lt; j; if(((key[i]) &amp; bi)) { num |= bi; } else num &amp;= (~bi); fwrite(&amp;num,1,1,pf); } } fclose(pf); return 0; } char * deCode() { FILE *pf = fopen(&quot;data/key.txt&quot;,&quot;rb&quot;); char *password = (char *)malloc(20); int pos = 0; int num; while(!feof(pf)) { num = 0; for(int i = 0; i &lt; 7; ++i) { int tmp; int bi = (1 &lt;&lt; i); fread(&amp;tmp,1,1,pf); num += (tmp &amp; bi); } password[pos++] = num; } password[pos-1] = 0; fclose(pf); return password; } int dataViewMenu() { printf(&quot;\\n\\n\\n\\n\\n&quot;); printMargin(40);printf(&quot;1、医生信息\\n\\n&quot;); printMargin(40);printf(&quot;2、营业额 \\n\\n&quot;); printMargin(40);printf(&quot;3、诊疗记录浏览 \\n\\n&quot;); printMargin(40);printf(&quot;0、返回上一层\\n\\n\\n\\n\\n&quot;); int command; for(;;) { printf(&quot;请选择一项（输入序号）:&quot;); scanInt(&amp;command,3); if((command &gt; 3)||(command &lt; 0)) { printf(&quot;输入非法\\n&quot;); } else break; } switch(command) { case 1: showDepartStatus(); break; case 2: { system(&quot;cls&quot;); printfMoneyStatus(); printf(&quot;按任意键返回\\n&quot;); getchar(); break; } case 3: viewData();break; case 0: break; } return 0; } int inpatientDapart() { for(;;) { system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;1、病房信息\\n\\n&quot;); printMargin(40); printf(&quot;2、住院病人管理\\n\\n&quot;); printMargin(40); printf(&quot;0、返回主菜单\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); int command = 0; for(;;) { scanInt(&amp;command, 3); if((command &lt; 0)||(command &gt; 3)) printf(&quot;输入不合法\\n&quot;); else break; } if(command == 1) { showPatientsInHospital(); } else if(command == 2) patientAdminMenu(); else break; } return 0; } int printMargin(int n) { for (int i = 0; i &lt; n; i++) printf(&quot; &quot;); return 0; } void loading() { system(&quot;color f0&quot;); int i, j; printf(&quot;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); for (i = 1; i &lt;= 10; i++) { printf(&quot;\\t\\t\\t\\t\\t\\t欢迎使用|&quot;); for (j = 0; j &lt; i; j++) printf(&quot;-&quot;); printf(&quot;|&#39;%d%%&#39;\\r&quot;, i*10); Sleep(50); } system(&quot;cls&quot;); } int countPatient(int id, int departmentID)//根据病人id，统计它在某个科室挂了多少号 { extern struct Data *dataHead; struct Data * p = dataHead; int num = 0; while(p) { if((p-&gt;ID == id)&amp;&amp;(p-&gt;doctor.department == departmentID)) { ++num; } p = p-&gt;next; } return num; } int countPatientDoc(int id, int doctorID)//根据病人id，统计它在某个医生名下挂了多少号 { extern struct Data *dataHead; struct Data * p = dataHead; int num = 0; while(p) { if((p-&gt;ID == id)&amp;&amp;(p-&gt;doctor.number == doctorID)) { ++num; } p = p-&gt;next; } return num; } int saveMedData() { extern struct Medicine* mediStorage; struct Medicine * p = mediStorage-&gt;next; FILE * pf = fopen(&quot;hospital/medicine.txt&quot;,&quot;w&quot;); int i = 0; while(p) { fprintf(pf,&quot;%06d %16s %3d %4d\\n&quot;,++i,p-&gt;name,p-&gt;number,p-&gt;price); p = p-&gt;next; } fprintf(pf,&quot;%8d&quot;, i); fclose(pf); return 0; } int reSeek(FILE *pf) { char c = 0; while((c != &#39;\\n&#39;)&amp;&amp;(c != EOF)) { c = fgetc(pf); } return 0; } //文件view.h #ifndef HOUSJ_H_INCLUDED #define HOUSJ_H_INCLUDED int viewByDoctorID(struct Data ** container, int ID);//按医生工号筛选诊疗信息 int viewByDepart(struct Data ** container, int ID);//按科室筛选诊疗信息 int viewByPatientID(struct Data ** container, int ID);//按患者ID筛选诊疗信息 int countPatientDoc(int id, int doctorID);//根据病人id，统计它在某个医生名下挂了多少号 int countPatient(int id, int departmentID);//根据病人id，统计它在某个科室挂了多少号 void countAllDoc();//统计所有医生的挂号数量 void printMedList(struct Medicine * head);//输出某位患者的购药单 void printExamList(struct ExaminationFee * head);//输出某位患者的检查单 int showPatientsInHospital();//展示病房信息 int showPatientsInfo(struct Data *node);//展示住院病人的信息 int viewDataSpan();//按时间区间浏览历史诊疗记录 int printDataList(struct Data * base);//输出所建链表的所有数据 #endif // HOUSJ_H_INCLUDED //文件view.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include &lt;io.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include&lt;windows.h&gt; #include&quot;basic.h&quot; #include&quot;view.h&quot; #include&quot;change.h&quot; /*打印head链表的所有的诊疗记录*/ int printDataList(struct Data * base)//返回值为链表的有效结点数 { if(base-&gt;next == NULL) return -1; struct Data *p = base-&gt;next; printf(&quot;正在打印数据...：\\n\\n&quot;); int i = 0; while(p) { printf(&quot;---------------------\\n&quot;); printf(&quot;%d、 &quot;,++i); printSingleData(p); printf(&quot;\\n\\n\\n\\n&quot;); p = p-&gt;next; } return i; } int viewByDoctorID(struct Data ** container, int ID) { int itr = 0; int i = 0; int count = 0; while(container[itr]) { if(container[itr]-&gt;doctor.number == ID) { ++i; printf(&quot;%d、&quot;,++count); printSingleData(container[itr]); printf(&quot;\\n\\n&quot;); } ++itr; } if(!i) { printMargin(40); printf(&quot;未找到任何数据！\\n&quot;); printMargin(40); printf(&quot;按任意键返回上一层\\n&quot;); getchar(); return 0; } return 0; } int viewByDepart(struct Data ** container, int ID) { int itr = 0; int count = 0; int i = 0; while(container[itr]) { if(container[itr]-&gt;doctor.department == ID) { printf(&quot;%d、&quot;,++count); printSingleData(container[itr]); printf(&quot;\\n\\n&quot;); ++i; } ++itr; } if(!i) { printMargin(40); printf(&quot;未找到任何数据！\\n&quot;); printMargin(40); printf(&quot;按任意键返回上一层\\n&quot;); getchar(); return 0; } return 0; } int viewByPatientID(struct Data ** container, int ID) { int itr = 0; int count = 0; int i = 0; while(container[itr]) { if(container[itr]-&gt;ID == ID) { printf(&quot;%d、&quot;,++count); printSingleData(container[itr]); printf(&quot;\\n\\n&quot;); ++i; } ++itr; } if(!i) { printMargin(40); printf(&quot;未找到任何数据！\\n&quot;); printMargin(40); printf(&quot;按任意键返回上一层\\n&quot;); getchar(); return 0; } return 0; } /*打印购药链表*/ void printMedList(struct Medicine * head) { struct Medicine *p = head-&gt;next; if(!p) return; printf(&quot; ***所购药品如下:*** \\n\\n&quot;); int i = 0; while(p) { printf(&quot;%d)、 药品名：%s 数量：%d, 单价：%d元 %d角 \\n&quot;,++i,p-&gt;name,p-&gt;number,(p-&gt;price)/10,(p-&gt;price)%10); p = p-&gt;next; } printf(&quot; \\n\\n&quot;); } /*打印所做检查项目链表*/ void printExamList(struct ExaminationFee * head) { struct ExaminationFee *p = head-&gt;next; if(!p) return; printf(&quot;\\n ***所做检查项目如下:*** \\n\\n&quot;); int i = 0; while(p) { printf(&quot;检查项目%d： %s 价格：%d 元 %d 角 \\n&quot;,++i,p-&gt;name,(p-&gt;cost)/10,(p-&gt;cost)%10); p = p-&gt;next; } } int viewDataSpan()//可以手动输入日期获取该日期的诊疗记录 { extern struct Data * dataHead; extern char departments[7][20]; char endPosition[20] = &quot;data/&quot;; char position[20] = &quot;data/&quot;; int start_m, start_d; int end_m, end_d; printf(&quot;注意：您最多查看30天的数据\\n&quot;); for(;;) { printf(&quot;请输入需要查看的起始日期\\n&quot;); inputDate(&amp;start_m,&amp;start_d); int tmp1 = start_m * 1000000; tmp1 += (start_d * 10000); printf(&quot;请输入需要查看的结束日期\\n&quot;); inputDate(&amp;end_m, &amp;end_d); int tmp2 = end_m * 1000000; tmp2 += (end_d * 10000); int aa = timeSpan(tmp1,tmp2); if(aa &gt; 30) { printf(&quot;最多查看30天的数据，请重新输入！\\n&quot;); } else break; } position[5] = start_m / 10 + &#39;0&#39;; position[6] = start_m % 10 + &#39;0&#39;; position[7] = start_d / 10 + &#39;0&#39;; position[8] = start_d % 10 + &#39;0&#39;; position[9] = &#39;/&#39;; position[10] = 0; endPosition[5] = end_m / 10 + &#39;0&#39;; endPosition[6] = end_m % 10 + &#39;0&#39;; endPosition[7] = end_d / 10 + &#39;0&#39;; endPosition[8] = end_d % 10 + &#39;0&#39;; endPosition[9] = &#39;/&#39;; position[10] = 0; struct Data* container[300]; int itr = 0; struct Data* dataHeadToDel[100]; int i_del = 0; while(strcmp(position,endPosition) &lt;= 0) { dataHead = input(position); struct Data * p = dataHead-&gt;next; if(!p) { free(dataHead); } else dataHeadToDel[itr++] = dataHead; while(p) { printf(&quot;%d、&quot;,itr+1); printSingleData(p); container[itr++]= p; p = p-&gt;next; } nextDay(position); } container[itr] = NULL; if(!itr) { printMargin(40); printf(&quot;未找到该时间段的任何数据！\\n&quot;); printMargin(40); printf(&quot;按任意键返回上一层\\n&quot;); getchar(); return 0; } for(;;) {printMargin(40); printf(&quot;1：按医生筛选数据\\n&quot;); printMargin(40); printf(&quot;2：按患者ID筛选数据\\n&quot;); printMargin(40); printf(&quot;3：按科室筛选数据\\n&quot;); printMargin(40); printf(&quot;0: 退出\\n&quot;); int command; for(;;) { printf(&quot;请选择：&quot;); scanInt(&amp;command,3); if((command &lt;0)||(command &gt; 3)) { printf(&quot;输入不合法\\n&quot;); } else break; } switch(command) { case 1: { int id; printf(&quot;请输入医生ID(8位):&quot;); for(;;) { if(scanInt(&amp;id,9) != 8) { printf(&quot;数据非法！请重新输入\\n&quot;); } else break; } viewByDoctorID(container,id); break; } case 2: { int id; printf(&quot;请输入患者ID(8位):&quot;); for(;;) { if(scanInt(&amp;id,9) != 8) { printf(&quot;数据非法！请重新输入\\n&quot;); } else break; } viewByPatientID(container,id); break; } case 3: { int nn; for(int i = 0; i &lt; 5; ++i) printf(&quot;%d、%s\\n&quot;,i+1,departments[i]); printf(&quot;请选择：&quot;); for(;;) { scanInt(&amp;nn,3); if((nn &lt; 1)||(nn &gt; 5)) { printf(&quot;输入非法\\n&quot;); } else break; } viewByDepart(container,nn-1); break; } case 0: break; } if(!command) break; } for(int i = 0; i &lt; i_del; ++i) clearList(dataHeadToDel[i]); return 0; } int showPatientsInfo(struct Data *node) { /*日期格式：09020900*/ int in_mon = node-&gt;treatment.hospitalization.ruyuanshijian/1000000; int in_day = (node-&gt;treatment.hospitalization.ruyuanshijian/10000)%100; int in_hou = (node-&gt;treatment.hospitalization.ruyuanshijian/100) % 100; int out_mon = node-&gt;treatment.hospitalization.chuyuanshijian/1000000; int out_day = (node-&gt;treatment.hospitalization.chuyuanshijian/10000)%100; int out_hou = (node-&gt;treatment.hospitalization.chuyuanshijian/100) % 100; char sexstr[2][4] = {&quot;女&quot;,&quot;男&quot;}; int sex = (node-&gt;number % 100000) / 10000; printf(&quot;ID: %d 姓名:%5s 性别：%s 年龄:%2d &quot;,node-&gt;ID,node-&gt;name,sexstr[sex],node-&gt;age); printf(&quot;入院时间： %2d月 %2d日 %2d时 预计出院时间: %2d月 %2d日 %2d时 &quot;,in_mon,in_day,in_hou,out_mon,out_day,out_hou); time_t now; struct tm* tm_now; time(&amp;now); tm_now = localtime(&amp;now); int now_time = (tm_now-&gt;tm_mon+1)*1000000 + tm_now-&gt;tm_mday * 10000 + tm_now-&gt;tm_hour * 100; int cost = 200*timeSpan(node-&gt;treatment.hospitalization.ruyuanshijian,now_time); printf(&quot;总缴纳押金:%d&quot;,node-&gt;treatment.hospitalization.zhuyuanyajin); printf(&quot;住院押金剩余：%d&quot;,node-&gt;treatment.hospitalization.zhuyuanyajin - cost); if(node-&gt;treatment.hospitalization.zhuyuanyajin - cost &lt; 1000) { HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(handle, 0xFC); printMargin(30); printf(&quot;余额不足！&quot;); SetConsoleTextAttribute(handle, 0xF0); } return 0; } //文件change.h #ifndef ZHANGWY_H_INCLUDED #define ZHANGWY_H_INCLUDED int changePatientData(struct Data *p);//修改患者基本信息 int changeDoctorData(struct Doctor *p);//修改数据中的医生信息 int changeMedList(struct Medicine * head);//修改数据中的购药信息 int changeExamList(struct ExaminationFee * head);//修改数据中的检查项目信息 int changeHospitalData(struct Hospitalization *base);//修改数据中的住院信息 int changeData();//修改挂号数据的主界面 #endif // ZHANGWY_H_INCLUDED //文件change.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include &lt;io.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include&lt;windows.h&gt; #include&quot;basic.h&quot; #include&quot;view.h&quot; #include&quot;change.h&quot; int changePatientData(struct Data *p) { int command; for(;;) { printf(&quot;请选择需要修改哪一项:\\n&quot;); printf(&quot;1、挂号序列 2、 姓名 3、年龄 4、ID \\n&quot;); scanInt(&amp;command, 2); if((command &lt; 1)||(command &gt; 4)) { printf(&quot;输入不合法，请检查 \\n&quot;); } else break; } switch(command) { case 1: { printf(&quot;请重新输入挂号序列（9位正整数）:&quot;); for(;;) { if(scanInt(&amp;(p-&gt;number),9)==9) break; else { printf(&quot;请正确输入！\\n&quot;); } } break; } case 2: { printf(&quot;修改姓名:&quot;); scanName(p-&gt;name,20); break; } case 3: { printf(&quot;修改年龄:&quot;); for(;;) { scanInt(&amp;(p-&gt;age), 4); if((p-&gt;age &lt;0) || (p-&gt;age &gt; 140)) { printf(&quot;输入不合法，请检查！\\n&quot;); } else break; } break; } case 4: { printf(&quot;修改ID(8位正整数):&quot;); for(;;) { if(scanInt(&amp;(p-&gt;ID),8) == 8) break; else { printf(&quot;请正确输入!\\n&quot;); } } break; } } printf(&quot;修改成功！修改后的患者信息为：&quot;); printf(&quot;挂号序列：%d 患者姓名：%s ID:%d 患者年龄： %d &quot;, p-&gt;number, p-&gt;name,p-&gt;ID, p-&gt;age); return 0; } int changeData() { system(&quot;cls&quot;); extern struct Data *dataHead; struct Data* p = dataHead-&gt;next; int command; struct Data* line[300]; if(dataHead-&gt;next == NULL) return -1; int i = 0; while(p) { line[i] = p; printf(&quot;---------------------\\n&quot;); printf(&quot;%d、 &quot;,++i); printSingleData(p); p = p-&gt;next; } line[i] = NULL; for(;;) { printMargin(40); printf(&quot;1:删除数据\\n\\n&quot;); printMargin(40); printf(&quot;2:修改数据\\n\\n&quot;); printMargin(40); printf(&quot;0:返回上一层\\n\\n\\n\\n\\n\\n\\n\\n请输入:&quot;); scanInt(&amp;command,3); if((command &gt; 2)||(command &lt;0)) { printf(&quot;输入不合法\\n&quot;); } else break; } if(!command) return 0; if(command == 1) { for(;;) { printf(&quot;您要删除哪条数据？\\n&quot;); int n; scanInt(&amp;n,3); if((n &gt; i)||(n &lt; 1)) printf(&quot;输入不合法！\\n&quot;); else { free(line[n-1]); if(n == 1) dataHead-&gt;next = line[1]; else line[n-2]-&gt;next = line[n]; break; } } system(&quot;cls&quot;); printf(&quot;\\n\\n\\n\\n\\n\\n&quot;); printMargin(40); printf(&quot;删除成功！按任意键返回上一层&quot;); getchar(); return 0; } for(;;) { printf(&quot;请输入需要修改的数据序号(输入0返回上一层):&quot;); scanInt(&amp;command,2); if((command &gt; i)||(command &lt; 0)) { printf(&quot;请检查输入\\n&quot;); } else break; } if(!command) return 0; p = line[command-1]; printf(&quot;\\n\\n\\n\\n&quot;); printMargin(10); printSingleData(p); printf(&quot;\\n\\n请选择修改哪项数据？\\n\\n\\n\\n\\n&quot;); printMargin(10); printf(&quot;1:患者基本信息\\n\\n&quot;); printMargin(10); printf(&quot;2:医生信息\\n\\n&quot;); printMargin(10); printf(&quot;3:购药信息\\n\\n&quot;); printMargin(10); printf(&quot;4:检查项目信息\\n\\n&quot;); printMargin(10); printf(&quot;5:住院信息\\n\\n&quot;); printMargin(10); printf(&quot;0:退出页面\\n\\n&quot;); printMargin(10); for(;;) { scanInt(&amp;command,3); if((command &lt; 0)||(command &gt; 5)) { printf(&quot;输入不合法，请检查！\\n&quot;); } else break; } switch(command) { case 1: changePatientData(p);break; case 2: changeDoctorData(&amp;(p-&gt;doctor));break; case 3: changeMedList(&amp;(p-&gt;treatment.medicine)); break; case 4: changeExamList(&amp;(p-&gt;treatment.exminationFee)); break; case 5: changeHospitalData(&amp;(p-&gt;treatment.hospitalization));break; case 0: break; } system(&quot;cls&quot;); printf(&quot;\\n\\n\\n&quot;); printf(&quot;修改后的完整数据：\\n&quot;); printSingleData(p); printf(&quot;\\n\\n\\n&quot;); printf(&quot;按任意键返回主菜单！&quot;); getchar(); return 0; } int changeHospitalData(struct Hospitalization *base) { int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31}; printf(&quot;请输入入院时间,格式：月 日 时如： \\&quot;9 10 10\\&quot;,数字间以空格间隔 \\n&quot;); int m,d,h,s; base-&gt;zhuyuanyajin = 0; for(;;) { scanInt(&amp;m, 2); scanInt(&amp;d, 2); scanInt(&amp;h, 2); s = 0; if((m &gt; 0)&amp;&amp;(m &lt; 13)&amp;&amp;(d &gt; 0)&amp;&amp; (d &lt;= months[m])&amp;&amp;(h &gt;= 0)&amp;&amp;(h &lt; 24)&amp;&amp;(s &gt;= 0)&amp;&amp;(s &lt; 60)) { break; } printf(&quot;请检查输入格式重新输入:&quot;); } int time1 = m * 1000000; time1 += (d * 10000); time1 += (h * 100); base-&gt;ruyuanshijian = time1; int m1,d1,h1,s1; printf(&quot;请输入出院时间,格式：月 日 时如： \\&quot;9 10 10\\&quot;,数字间以空格间隔 \\n&quot;); for(;;) { scanInt(&amp;m1, 2); scanInt(&amp;d1, 2); scanInt(&amp;h1, 2); s1 = 0; if((m1 &gt; 0)&amp;&amp;(m1 &lt; 13)&amp;&amp;(d1 &gt; 0)&amp;&amp; (d1 &lt;= months[m])&amp;&amp;(h1 &gt;= 0)&amp;&amp;(h1 &lt; 24)) { int n1 = m; n1 = n1 * 40 + d; n1 = n1 * 30 + h; n1 = n1 * 60 + s; int n2 = m1; n2 = n2 * 40 + d1; n2 = n2 * 30 + h1; n2 = n2 * 60 + s1; if(n1 &lt; n2) break; else { printf(&quot;请保证出院时间晚于入院时间\\n&quot;); } } printf(&quot;请重新输入出院时间:&quot;); } time1 = m1 * 1000000; time1 += (d1 * 10000); time1 += (h1 * 100); time1 += (s1); base-&gt;chuyuanshijian = time1; printf(&quot;入院时间：%d月 %d日 %d时 &quot;,(base-&gt;ruyuanshijian)/1000000,((base-&gt;ruyuanshijian)%1000000)/10000,((base-&gt;ruyuanshijian)%10000)/100); printf(&quot;出院时间：%d月 %d日 %d时 \\n&quot;,(base-&gt;chuyuanshijian)/1000000,((base-&gt;chuyuanshijian)%1000000)/10000,((base-&gt;chuyuanshijian)%10000)/100); return 0; } int changeMedList(struct Medicine * head) { struct Medicine *p = head-&gt;next; struct Medicine * line[200]; int i = 0; while(p) { line[i] = p; printf(&quot;%d)、 药品名：%s 数量：%d, 单价：%d \\n&quot;,++i,p-&gt;name,p-&gt;number,p-&gt;price); p = p-&gt;next; } line[i] = NULL; int command; for(;;) { printf(&quot;请选择需要执行的操作：1、增加一条数据 2、删除一条数据 3、修改数据\\n&quot;); scanInt(&amp;command,3); if((command &gt;3) || (command &lt; 1)) { printf(&quot;输入不合法\\n&quot;); } else break; } switch (command) { case 1://插入一条数据 { struct Medicine * pnew = (struct Medicine *) malloc (sizeof(struct Medicine)); pnew-&gt;next = NULL; printf(&quot;请输入药品名称：&quot;); scanStr(pnew-&gt;name,14); printf(&quot;请输入药品单价,\\(格式 \\&quot; 元 角 \\&quot; ,不得超过999元):&quot;); int m,n; for(;;) { scanInt(&amp;n,6); scanInt(&amp;m,5); if((n &lt; 0)||(n &gt; 999)||(m &gt; 9)||(m &lt; 0)) { printf(&quot;请检查输入格式\\n&quot;); } else { pnew-&gt;price = n*10 + m; break; } } printf(&quot;请输入药品数量，不得超过999&quot;); for(;;) { scanInt(&amp;m,4); if((m &lt; 0)||(m &gt; 999)) { printf(&quot;数据不合法\\n&quot;); } else { pnew-&gt;number = m; break; } } head-&gt;next = pnew; pnew-&gt;next = line[0]; break; } case 2://删除一条数据 { if(!i)//链表为空 { printf(&quot;没有可删除的数据\\n&quot;); break; } printf(&quot;请输入欲删除的数据序号\\n&quot;); for(;;) { int command; scanInt(&amp;command,3); if((command &lt; 0)||(command &gt; i)) { printf(&quot;请检查输入格式!\\n&quot;); } else { if(command == 1) { free(line[0]); head-&gt;next = NULL; } else { free(line[command - 1]); line[command - 2]-&gt;next = line[command]; } printf(&quot;已删除&quot;); break; } } break; } case 3://修改一条数据 { int command; struct Medicine *pp; for(;;) { printf(&quot;请输入欲修改的数据序号：&quot;); scanInt( &amp;command, 3); if((command &gt; i)||(command &lt; 0)) { printf(&quot;输入不合法！\\n&quot;); } else { pp = line[command - 1]; break; } } printf(&quot;请输入药品名称：&quot;); scanStr(pp-&gt;name,14); printf(&quot;请输入药品单价,（格式 “元 角” ,不得超过999元）:&quot;); int m,n; for(;;) { scanInt(&amp;n,6); scanInt(&amp;m,5); if((n &lt; 0)||(n &gt; 999)||(m &gt; 9)||(m &lt; 0)) { printf(&quot;请检查输入格式\\n&quot;); } else { pp-&gt;price = n*10 + m; break; } } printf(&quot;请输入药品数量，不得超过999&quot;); for(;;) { scanInt(&amp;m,4); if((m &lt; 0)||(m &gt; 99)) { printf(&quot;数据不合法\\n&quot;); } else { pp-&gt;number = m; break; } } break; } } p = head-&gt;next; printf(&quot;修改后数据：\\n&quot;); while(p) { line[i] = p; printf(&quot;%d)、 药品名：%s 数量：%d, 单价：%d \\n&quot;,++i,p-&gt;name,p-&gt;number,p-&gt;price); p = p-&gt;next; } return 0; } 附件：1、工程源文件.zip2、实验报告.docx 注：工程使用codeblocks:: 17.12编译","categories":[{"name":"C++","slug":"C","permalink":"/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"课设","slug":"课设","permalink":"/tags/课设/"}],"keywords":[{"name":"C++","slug":"C","permalink":"/categories/C/"}]},{"title":"BBC news 10/10 白宫的“超级传播事件”","slug":"BBCnews2020 10 10","date":"2020-10-10T15:00:01.000Z","updated":"2021-02-08T02:05:05.751Z","comments":true,"path":"2020/10/10/BBCnews2020 10 10/","link":"","permalink":"/2020/10/10/BBCnews2020 10 10/","excerpt":"","text":"本报道在2020/10/10日 BBC new官网中浏览量排在第一位 White House hosted Covid ‘superspreader’ event, says Dr FauciTop US virus expert Dr Anthony Fauci has criticised the White House for hosting a gathering last month that has been linked to an outbreak of Covid-19.Dr Fauci, a member of the White House coronavirus task force, said the unveiling of President Donald Trump’s nominee to the Supreme Court was a “superspreader event”.At least 11 people who attended the event on 26 September tested positive.Mr Trump is himself recovering from Covid-19.His doctors have just cleared him to hold public events, less than a month before he faces Democratic candidate Joe Biden in the presidential election.Mr Trump has expressed scepticism about measures such as masks and lockdowns to combat the spread of Covid-19, which has killed more than 213,000 people in the US. He has talked up the prospects of a vaccine becoming available, although researchers say this is unlikely to happen before next year at the earliest.Polling suggests Mr Biden has a single-digit lead over Mr Trump and an ABC News/Ipsos poll found that just 35% of Americans approved of how Mr Trump has handled the crisis. What did Dr Fauci say?CBS News asked on Friday what Dr Fauci thought of the White House’s reluctance to insist on mask-wearing and social distancing as virus precautions, and instead rely on regular testing.“The data speak for themselves - we had a superspreader event in the White House, and it was in a situation where people were crowded together and were not wearing masks.”An event at the White House on Saturday 26 September, for the president’s nomination of Amy Coney Barrett as a Supreme Court justice, is thought to be the root of the localised outbreak.As well as President Trump and his wife Melania, those who attended and later tested positive included two senators, the White House press secretary and former Trump counsellor Kellyanne Conway.Dr Fauci also noted experts have been recommending mask-wearing for the last six months, and condemned talk of a coronavirus “cure” - a word Mr Trump has used in reference to the experimental Covid-19 treatments he received during his recent stay at a military hospital.Large gatherings are still banned in the US capital due to Covid-19, but federal property like the White House is exempt. How is Mr Trump’s health?Mr Trump - who was discharged from hospital on Monday after three nights - was asked in an interview with Fox News on Friday evening about the symptoms he had experienced.The president said he had not felt strong, but had found no problem breathing.Asked if he had re-tested for coronavirus on Friday, the president said he was at “either the bottom of the scale or free”, though he did not say his results were negative. What events does he have planned?On Saturday, which according to his doctors will be 10 days since his diagnosis, Mr Trump will give a speech from the White House balcony to a group gathered on the South Lawn.Hundreds of people have reportedly been invited.All attendees will be required to wear masks, will be given temperature checks and encouraged to social distance, said the White House.Mr Trump’s remarks will be on the subject of “law and order”, according to the White House, which adds that it is a presidential rather than a campaign event.There will also be an event by the group Blexit, a campaign urging black voters to reject the Democratic party.On Monday the Trump campaign is planning a big rally in Sanford, Florida. What about the debates?Next week’s second presidential debate between Mr Trump and his Democratic White House challenger Joe Biden is now officially cancelled.The Commission on Presidential Debates said in a statement on Friday that both campaigns had announced “alternate plans for that date”.Mr Trump had baulked at a request from the commission to hold the 15 October showdown virtually to minimise the risk of spreading coronavirus.The commission said it was still making arrangements for the third and final presidential debate in Nashville, Tennessee, on 22 October.The Trump campaign said the commission was “biased” towards Mr Biden, while the Democrat’s team accused the president of ducking the debate. Who has tested positive in Mr Trump’s circle?The announcement of Mr Trump’s first mass gathering since his infection triggered alarms in Washington, where officials are still attempting to contact trace attendees from the White House event.Mr Trump tested positive for Covid-19 last Thursday, according to his doctors, but he has not said when his last negative test was.As many as 34 White House aides and other contacts have tested positive for Covid-19 in recent days, according to US media.On Friday, the Minnesota Department of Health said nine infections have been tied to Mr Trump’s 18 September campaign rally in the state.At least one person was infectious when they attended, officials say, and two cases have led to hospital admissions, with one of those people in intensive care. 译： 福奇说，白宫发生了新冠病毒“超级传播者”事件美国顶尖病毒专家安东尼·福奇博士（Anthony Fauci）批评白宫上个月举办了一次与Covid-19爆发有关联的聚会。白宫冠状病毒特别工作组成员福奇博士表示，唐纳德·特朗普总统揭晓最高法院法官人选的仪式是一次“超级传播者事件”。9月26日参加活动的人中，至少11人检测呈阳性。特朗普先生本人正在从Covid-19中恢复。他的医生刚刚批准他举行公开活动，不到一个月，他将在总统选举中面对民主党候选人拜登。特朗普先生对口罩和封锁等措施遏制新冠病毒蔓延的效果表示怀疑，该疾病在美国已造成21.3万人死亡。尽管研究人员说在明年之前不可能用上疫苗，但他还是谈到了疫苗的前景。民调显示，拜登领先特朗普个位数，ABC新闻/益普索(ABC News/Ipsos)的民调发现，只有35%的美国人认可特朗普处理这场危机的方式。（has a single-digit lead over 是在个位上领先，还是指领先一位数呢？😳） 福奇博士说了什么？哥伦比亚广播公司（CBS）新闻周五询问福奇博士，对于白宫不愿坚持戴口罩和社交距离作为病毒预防措施，而是依赖定期检测的做法他有何看法。“数据已经说明了一切—白宫发生了一场超级传播者活动，当时人们挤在一起，没有戴口罩。”9月26日星期六在白宫举行了一场活动，艾米·康尼·巴雷特（Amy Coney Barrett）被总统提名为最高法院大法官，这被认为是局部爆发的根源。除了特朗普总统和他的妻子梅拉尼亚外，参加会议并随后被测试为阳性的人包括两名参议员：白宫新闻秘书和前特朗普顾问凯利安·康威。福奇博士还指出，过去6个月来，专家们一直建议戴口罩。他还谴责了有关冠状病毒“治愈”的言论—特朗普使用这个词是指他最近在一家军队医院接受新冠肺炎的实验性治疗。由于新冠病毒，美国首都至今仍禁止举行大型集会，但白宫却不需要理会禁令。 特朗普先生健康状况如何？特朗普在三晚后于周一出院，周五晚接受福克斯新闻采访时被问及他所经历的症状。总统说，他感觉身体不太强壮，但没有发现呼吸问题。当被问及他是否在周五重新检测过冠状病毒时，总统说他“要么处于很低的水平，要么是不必担心的”，尽管他没有说他的结果是阴性的。 特朗普有哪些计划周六，特朗普先生将在白宫阳台向聚集在白宫南草坪的一群人发表演讲。根据他的医生的说法，周六是他确诊后的第10天。据报道，已有数百人被邀请。白宫表示，所有与会者都将被要求戴口罩，并会被测温，并鼓励保持社交距离。白宫表示，特朗普的讲话将围绕“法律和秩序”这一主题，并补充说，这是一场总统活动，而不是竞选活动。还将有Blexit组织的一项活动，旨在敦促黑人选民拒绝民主党。周一，特朗​​普竞选活动计划在佛罗里达州桑福德举行一次大型集会。 关于选举…特朗普先生与他的民主党白宫挑战者乔·拜登之间下周的第二次总统辩论现已正式取消。总统辩论委员会在周五的一份声明中说，两个竞选团队都宣布了“这一天的替代计划”。委员会要求特朗普在10月15日摊牌，实际上是为了将冠状病毒传播的风险降至最低，但特朗普拒绝了这一要求。该委员会表示，他们仍在为10月22日在田纳西州纳什维尔举行的第三次也是最后一次总统辩论做安排。特朗普竞选活动说，该委员会”偏向”拜登，而民主党团队则指责总统回避辩论。 特朗普周围还有谁被检测为阳性？特朗普在确认感染后首次举行群众集会，这一消息在华盛顿引发了警觉，华盛顿的工作人员们仍在尝试联系和追踪白宫事件的参加者。据特朗普的医生称，他上周四的新冠肺炎检测呈阳性，但他没有说他最后一次阴性测试是什么时候。美媒称，在最近一段时间，多达34名白宫助手和其他有关联的人的新冠肺炎检测呈阳性。周五，明尼苏达州卫生部表示，9例感染与特朗普9月18日在该州举行的竞选集会有关。卫生部相关人员表示，至少有一个人在就诊时被传染，而且有两个病例导致入院，其中一个人接受了重症监护。","categories":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"/tags/英语/"},{"name":"BBC","slug":"BBC","permalink":"/tags/BBC/"}],"keywords":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}]},{"title":"leetcode91 解码方法","slug":"leetcode91","date":"2020-10-02T03:40:24.000Z","updated":"2021-02-08T04:42:55.017Z","comments":true,"path":"2020/10/02/leetcode91/","link":"","permalink":"/2020/10/02/leetcode91/","excerpt":"","text":"原题传送门—&gt;&gt; 题目描述： A message containing letters from A-Z is being encoded to numbers using the following mapping: ‘A’ -&gt; 1 ‘B’ -&gt; 2 … ‘Z’ -&gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. The answer is guaranteed to fit in a 32-bit integer. 示例1： Input: s = “12” Output: 2 Explanation: It could be decoded as “AB” (1 2) or “L” (12). 示例2： Input: s = “226” Output: 3 Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6). 示例3： Input: s = “0” Output: 0 Explanation: There is no character that is mapped to a number starting with ‘0’. We cannot ignore a zero when we face it while decoding. So, each ‘0’ should be part of “10” —&gt; ‘J’ or “20” —&gt; ‘T’. 示例4： Input: s = “1” Output: 1 注： &lt;= s.length &lt;= 100 s contains only digits and may contain leading zero(s). 入门级的dp+分治。但这方面的题我做的确实不太多… dp:对于仅包含’1’ ‘2’ 的字符串:“1” : 1种编码方式“12”：2种编码方式“111”：3种编码方式其实就是dp的入门题“爬楼梯”.假设长度为n的12串为steps[n] 则steps[n] = steps[n - 1] + steps[n - 2]; 为方便描述，现规定:对于编码“5”,5被称为“单”，对于编码“12”，1称作“头”，2称作“尾”。显然，1、2可作单、可做头、可作尾，因而1、2字符串可以直接dp 分治:当字符串中出现0、3、4…7、8这些字符时，可以发现，0只能作尾,其他字符只能作尾或作单。也就是说，当字符串是“121312”，3是不可能和后面的1混合编码的，那么可以将”1213”和”12”分开考虑，实际上”121312”的答案是”1213”与”12”的乘积。类推：”171921012319101”可以看成”17” “19” “210” “123” “19” “101”几个子串。而对于子串而言，末尾数字也需要分三种情况：”0”自成一类，”3~6”是一类，”7~9”是一类。 100%kill代码： class Solution { public: int steps[102]; int numDecodings(string s) { if(s[0] == &#39;0&#39;) return 0; steps[0] = 1; steps[1] = 1; steps[2] = 2; for(int i = 3; i &lt; 46; ++i)//为什么是46呢，因为47就超过int型上限了。。。按理，题目给的长度其实最大是100,这个只能自己试了 { steps[i] = steps[i - 1] + steps[i - 2]; }//建立dp数组 vector&lt;char&gt; tmp; int ans = 1; for(int i = 0; i &lt; s.size(); ++i) { tmp.push_back(s[i]); if((s[i] &lt; &#39;1&#39;)||(s[i] &gt; &#39;2&#39;)) { ans *= count(tmp); tmp.clear(); } } return ans*steps[tmp.size()]; } int count(vector&lt;char&gt;&amp; str)//这是处理子串的函数 { int sum = 0; if(str.back() == &#39;0&#39;)//对于0 { if(str.size() == 1) return 0; else return steps[str.size() - 2]; } if(str.back() &gt; &#39;6&#39;)//d对于7、8、9 { if(str.size() == 1) return 1; if(str[str.size()-2] == &#39;1&#39;) return steps[str.size()]; return steps[str.size()-1];//只能单着了 } //剩下3、4、5、6 return steps[str.size()]; } };","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"动态规划","slug":"动态规划","permalink":"/tags/动态规划/"},{"name":"分治","slug":"分治","permalink":"/tags/分治/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"鱼书笔记 第二章 感知机","slug":"鱼书笔记 第二章 感知机","date":"2020-09-27T12:00:00.000Z","updated":"2021-02-08T04:37:43.880Z","comments":true,"path":"2020/09/27/鱼书笔记 第二章 感知机/","link":"","permalink":"/2020/09/27/鱼书笔记 第二章 感知机/","excerpt":"","text":"1、 感知机是什么?感知机接收多个输入信号，输出一个信号。直观讲来，感知机类似数学上的“函数”,但是感知机的所有变量取值只有0和1。 可以假设函数z = ux+ vy，这里的x、y为自变量，u、v为权重（权重的取值是全体实数），并且设定阈值A，当ux+ vy &gt; A时z的值为1，否则为0. 2、 用感知机表示简单逻辑电路1） 与门把与门考虑成感知机：以z = ux+ vy（阈值为A）为例，可以认为它是一个(u, v, A) = (1, 1, 1.5)的感知机（当然还有很多其他取值方式） 2） 与非门和或门把与非门考虑成感知机：以z = ux+ vy（阈值为A）为例，可以认为它是一个(u, v, A) = (-1, -1, -1.5)的感知机(其实只要把与门的参数取值全部取反就可以)同样的，或门可以把参数设置为(u, v, A) = (1, 1, 0.8) 3、 感知机的实现1）简单的与门def AND(x, y): u, v, A = 1, 1, 1.5 tmp = u * x + v * y if tmp &gt; A: return 1 return 0 def main(): print(AND(0, 0)) # 输出0 print(AND(1, 0)) # 输出0 print(AND(1, 1)) # 输出1 print(AND(0, 1)) # 输出0 main() 2) 导入权重和偏置考虑最开始的感知机u x+ v y &gt; A, 这个式子也可以表示为u x+ v y - A &gt; 0. 所以也可以使用如下方式实现感知机：z = u x+ v y + b, 当u x+ v y + b &gt; 0时z取1， 否则取0这里的b称为偏置 下面使用NumPy实现感知机 import numpy as np def AND(x1, x2): x = np.array([x1, x2]) w = np.array([1, 1])# 权重 b = -1.5 # 偏置 if np.sum(x * w) + b &gt; 0: return 1 return 0 4、感知机的局限性及解决1）问题：简单感知机能实现异或门吗？答案时不能。感知机的表达式是线性的。而异或门的函数无法用线性表示。但是感知机可以叠加使用，“多层感知机”就可以实现异或门 3） 异或门的多层感知机实现由逻辑电路知识，异或门可以由与门、或门、与非门搭配实现。 import numpy as np def AND(x1, x2): # 与门 x = np.array([x1, x2]) w = np.array([1, 1])# 权重 b = -1.5 # 偏置 if np.sum(x * w) + b &gt; 0: return 1 return 0 def NAND(x1, x2): # 与非门 x = np.array([x1, x2]) w = np.array([-1, -1])# 权重 b = 1.5 # 偏置 if np.sum(x * w) + b &gt; 0: return 1 return 0 def OR(x1, x2): # 或门 x = np.array([x1, x2]) w = np.array([1, 1])# 权重 b = -0.5 # 偏置 if np.sum(x * w) + b &gt; 0: return 1 return 0 def XOR(x1, x2): # 异或门 s1 = NAND(x1, x2) s2 = OR(x1, x2) y = AND(s1, s2) return y def main(): print(XOR(0, 0)) #输出0 print(XOR(0, 1)) #输出1 print(XOR(1, 0)) #输出1 print(XOR(1, 1)) #输出0 main()","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"鱼书笔记","slug":"鱼书笔记","permalink":"/tags/鱼书笔记/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"leetcode 90 Subsets II 求所有子集","slug":"leetcode90","date":"2020-09-23T01:44:00.000Z","updated":"2021-02-08T04:42:46.542Z","comments":true,"path":"2020/09/23/leetcode90/","link":"","permalink":"/2020/09/23/leetcode90/","excerpt":"","text":"原题传送门-&gt;&gt;&gt; 题目描述： Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets. 示例： Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 简单的回溯题，但是自己解决时遇到很多问题，记录一下。 AC代码 class Solution { public: vector&lt;vector&lt;int&gt;&gt;ans; vector&lt;int&gt; tmp; int* mark; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); mark = new int[nums.size()]; memset(mark, 0, 4 * nums.size()); for (int i = 0; i &lt; nums.size(); ++i) select(nums, i); delete[]mark; ans.push_back(vector&lt;int&gt;()); return ans; } void select(vector&lt;int&gt;&amp; nums, int pos)//将要取pos元素 { if (pos == nums.size()) return; if (pos &amp;&amp; (nums[pos] == nums[pos - 1]) &amp;&amp; (!mark[pos - 1])) return; else { tmp.push_back(nums[pos]); ans.push_back(tmp); mark[pos] = 1; for (int i = pos + 1; i &lt; nums.size(); ++i) select(nums, i); tmp.pop_back(); mark[pos] = 0; } } }; 去重的规则比较清楚：先进行排序。取规则：当多个相同数字连续出现，这几个相同数字必须从左到右取，不能有间隔。比如：array = [1，2，3，3，3] 假如不取array[2]，那么array[3],array[4]也不可以取。问题在于搜索上。 WA代码版本1 // for (int i = pos + 1; i &lt; nums.size(); ++i) // select(nums, i); select(nums, pos + 1); 这个版本是深搜时仅仅探测下一格。它不允许连续取元素。比如array = [1，2，3，3，3]，[1,3]不会出现在答案中 WA代码版本2 //if (pos &amp;&amp; (nums[pos] == nums[pos - 1]) &amp;&amp; (!mark[pos - 1])) // return; if (pos &amp;&amp; (nums[pos] == nums[pos - 1]) &amp;&amp; (!mark[pos - 1])) { for (int i = pos + 1; i &lt; nums.size(); ++i) select(nums, i); return; } 这种情况，当发现重复元素不符合取规则时,会对后面的所有元素进行探测。问题在于，当return之后，该点之后的所有元素会再被探测一遍，结果答案会有大量重复。","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"鱼书笔记 第三章 神经网络","slug":"鱼书笔记 第三章 神经网络","date":"2020-09-22T03:40:24.000Z","updated":"2021-02-08T02:05:17.089Z","comments":true,"path":"2020/09/22/鱼书笔记 第三章 神经网络/","link":"","permalink":"/2020/09/22/鱼书笔记 第三章 神经网络/","excerpt":"","text":"上一章谈到感知机。理论上感知机能表示任意的复杂函数，但是它有很明显的缺点：权重必须手动设定。而本章介绍的神经网络，它的一个重要性质就是可以自动地从数据中学习到合适的权重参数。 一、从感知机到神经网络1)神经网络的例子神经网络分为三层：分别为输入层、中间层、输出层。由于中间层是不可见的，也被称为“隐藏层”。本书把这三层依次称为第0层、第一层、第二层。在连接方式上，神经网络与感知机没有区别。 2)再论感知机感知机的函数可以表达为z = \\begin{cases}1, ux + vy + b > 0 \\\\0, ux + vy + b \\leq 0\\end{cases} 其中x、y为输入,b为偏置。这样的感知机在实现时便需要对x、 y、 b分开处理。其实我们可以将x、y、b 统一处理。假设b也是一个输出、并且它的值恒为b，权重恒为1。另外，我们可以引入函数h(x),h(x) = \\begin{cases}1, x > 0 \\\\ 0, x \\leq 0 \\end{cases}, 这样，上面的函数可以表示为$h(ux + vy + b)$. 3)激活函数登场上面提到的$h(x)$,它可以将输入信号的总和处理成输出信号，这个函数便称为激活函数。激活函数的计算过程也就可以拆分为： 计算 c = ux + vy + b. c 计算所有输入信号的加权和 计算 $h(c)$ 二、激活函数前面介绍的激活函数，以某个阈值为界，当输入超过阈值后就改变输出，这种函数称为阶跃函数，激活函数还有其他的类型 1)sigmoid函数神经网络中经常用到sigmiod函数 h(x) = \\frac{1}{1+e^{-x}}e即是自然对数的底数。感知机和神经元的主要区别就在于激活函数 2）阶跃函数的实现前面的阶跃函数只能处理数组。下面我们写一个能处理矩阵的阶跃函数: import numpy as np def step_function(x): y = x &gt; 0 return y.astype(np.int) x = np.array([-1.0, 1.0, 2.0]) print(step_function(x)) 输出为 [0 1 1] astyped()的方法可以将矩阵元素转换为期望的类型。上面是将bool型转换为np.int型 3）阶跃函数的图像运用matplotlib import numpy as np import matplotlib.pylab as plt def step_function(x): return np.array(x &gt; 0, dtype=np.int) x = np.array([-1.0, 1.0, 2.0]) x = np.arange(-5.0,5.0,0.1) y = step_function(x) plt.plot(x, y) plt.ylim(-0.1, 1.1) # 指定y轴范围 plt.show() 得到的图像如图： 它的函数值呈阶梯形变化，故称阶跃函数 4) sigmoid函数的实现import numpy as np import matplotlib.pylab as plt def sigmoid(x): return 1 / (1 + np.exp(-x)) x = np.arange(-5.0,5.0,0.1) y = sigmoid(x) plt.plot(x, y) plt.ylim(-0.1, 1.1) # 指定y轴范围 plt.show() 函数图像如图： 5）sigmoid函数和阶跃函数的比较 不同点：阶跃函数是“间断”的，sigmoid函数是连续变化的。 相同点：两者的函数值均在0和1之间 6）线性函数与非线性函数阶跃函数和sigmoid函数还有一个共同点：两者均是非线性函数。神经网络的激活函数必须是非线性函数。否则，加深神经网络的层数就没有意义了。线性函数无论如何叠加，其效果均为线性 7) ReLU函数ReLU函数最近被广泛用作激活函数，其表达式为： h(x) = \\begin{cases} x, (x > 0) \\\\0, ( x \\leq 0)\\end{cases}其代码实现： def relu(x): return np.maximum(0,x) 三、多维数组的运算1)多维数组import numpy as np A = np.array([[1,2],[1,4],[8,9]]) print(A) print(np.ndim(A)) # A的维数 print(A.shape) # A的形状 输出结果： [[1 2] [1 4] [8 9]] 2 (3, 2) 2）矩阵的点积（内积）运算：import numpy as np A = np.array([[1,2],[1,4],[8,9]]) B = np.array([[1,2,3],[1,3,4]]) print(np.dot(A,B)) 输出为： [[ 3 8 11] [ 5 14 19] [17 43 60]] 而矩阵运算在神经网络中有什么意义？以上面这段代码为例：A 相当于输入信号， B相当于权重A 有三组输入数据，每组分别有两个量（即为x, y）B 有三个神经元，第一个神经元的权重分别为1、1第二个神经元的权重分别为 2、3。而最后得到的是三个神经元的三次数据。 矩阵运算可以简洁地表示多个神经元、多组输入数据的结果 四、3层神经网络的实现我们要实现下图中的三层神经网络： 1) 符号确认我们先导入w_{12}^{(1)} 、 a_{1}^{(1)} 等符号。这些符号仅在本节中使用右上角的(1)表示这是第1层的神经元、第一层的权重w_{12}^{(3)} 表示从第2层（即第3层的前一层）第1个神经元到第(3)层第2个神经元的权重.a_{2}^{(1)}表示第1层第2个神经元 2)各层间信号传递的实现输入层到第一层其中注意偏置神经元“1”，而表示偏置的b右下角的索引号只有一个数字。此时 a_{1}^{(1)} = w_{11}^{(1)}x_1+w_{12}^{(1)}x_2+b_{1}^{(1)}表示成矩阵运算则为： A^{(1)}=XW^{(1)}+B^{(1)}其中：A^{(1)}=\\begin{pmatrix} a_{1}^{(1)} & a_{2}^{(1)} & a_{3}^{(1)}\\end{pmatrix}\\quad,X^=\\begin{pmatrix} x_{1} & x_{2} & x_{3}\\end{pmatrix}\\quad,B^{(1)}=\\begin{pmatrix} b_{1}^{(1)} & b_{2}^{(1)} & b_{3}^{(1)} \\end{pmatrix}\\quad,W^{(1)}=\\begin{pmatrix} w_{11}^{(1)} & w_{21}^{(1)} & w_{31}^{(1)} \\\\ w_{12}^{(1)} & w_{22}^{(1)} & w_{32}^{(1)}\\end{pmatrix}\\quad 下面我们用Numpy数组来实现 import numpy as np def sigmoid(x): return 1 / (1 + np.exp(-x)) X = np.array([1.0, 0.5]) W1 = np.array([[0.1,0.3,0.5],[0.2,0.4,0.6]]) B1 = np.array([0.1, 0.2, 0.3]) A1 = np.dot(X, W1) + B1 print(A1) print(sigmoid(A1)) 输出： [0.3 0.7 1.1] [0.57444252 0.66818777 0.75026011] 上面的代码中用到了先前的激活函数，实际上代码的过程如下图： 第1层到第2层# 继续使用前面的代码 W2 = np.array([[0.1, 0.4],[0.2, 0.5], [0.3, 0.6]]) B2 = np.array([0.1,0.2]) A2 = np.dot(Z1,W2) + B2 Z2 = sigmoid(A2) print(Z2) 输出： [0.3 0.7 1.1] 第2层到输出层 def identity_function(x): return x W3 = np.array([[0.1, 0.3],[0.2, 0.4]]) B3 = np.array([0.1, 0.2]) A3 = np.dot(Z2, W3) + B3 Y = identity_function(A3) 这里用到了船新的激活函数：identity_function，它其实啥也不干，单纯为了和前面格式统一另外，输出层的激活函数用 \\sigma表示，而不是h 3)代码小结import numpy as np def identity_function(x): return x def sigmoid(x): return 1 / (1 + np.exp(-x)) def init_network(): network = {} network[&#39;W1&#39;] = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]]) network[&#39;b1&#39;] = np.array([0.1, 0.2, 0.3]) #W1是第一层权重，b1是第一层偏置，可以看出第一层共有三个神经元，每个神经元接受两个输入信号 network[&#39;W2&#39;] = np.array([[0.1, 0.4],[0.2, 0.5], [0.3, 0.6]]) network[&#39;b2&#39;] = np.array([0.1, 0.2]) network[&#39;W3&#39;] = np.array([[0.1, 0.3], [0.2, 0.4]]) network[&#39;b3&#39;] = np.array([0.1, 0.2]) return network def forward(network, x): W1, W2, W3 = network[&#39;W1&#39;], network[&#39;W2&#39;], network[&#39;W3&#39;] b1, b2, b3 = network[&#39;b1&#39;], network[&#39;b2&#39;], network[&#39;b3&#39;] a1 = np.dot(x,W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1,W2) + b2 z2 = sigmoid(a2) a3 = np.dot(z2,W3) + b3 y = identity_function(a3) return y network = init_network() x = np.array([1.0, 0.5]) y = forward(network, x) print(y) 输出结果为：[0.31682708 0.69627909] 这里出现了“forward”函数，它表示从输入到输出方向的传递处理。之后会介绍后向（backward,从输出到输入方向的处理） 五、输出层的设计神经网络可以用在分类和回归问题上。一般而言，回归问题用恒等函数，分类问题用softmax函数。 补充：机器学习大致分为分类问题和回归问题分类问题举例：给一张图像，区分图像中的人是男性还是女性回归问题举例：给一张图像，估测图像中人的体重 1)恒等函数和softmax函数恒等函数前面已经接触到了，就是上面的identity_function函数。 softmax函数可以如下式这样表示 y_{k}=\\frac{e^{(a_{k})}}{\\sum_{i=1}^ne^{(a_{i})}}e是自然对数的底数。假设有n个神经元，计算第k个神经元的输出y_{k}.注意式子里面的a均为输入信号。softmax函数与之前的激活函数最大的不同在于它的输出受到所有输入信号的影响。 2)softmax函数的实现下面用python对softmax函数进行实现： import numpy as np def softmax(a): exp_a = np.exp(a) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y 不过，当使用指数运算时会面临数据溢出的问题。上面的的函数，尽管最后的返回值y数字不会太大，但运算过程中的中间量sum_exp_a可能会非常非常大，比如输入中某个值为1000……这样很容易不能正确得到结果，所有需要改进可以证明： \\frac{e^{(a_{k})}}{\\sum_{i=1}^ne^{(a_{i})}}=\\frac{e^{(a_{k}+C)}}{\\sum_{i=1}^ne^{(a_{i}+C)}}所以，输入矩阵中所有元素加/减某一常数，不影响最后的结果 改进如下： import numpy as np def softmax(a): c = np.max(a) exp_a = np.exp(a - c) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y 3）softmax函数的特征import numpy as np def softmax(a): exp_a = np.exp(a) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y a = np.array([0.3, 2.9, 4.0]) y = softmax(a) print(y)#输出：[0.01821127 0.24519181 0.73659691] print(np.sum(y))#输出： 1.0 我直观的感觉：softmax是统计概率的函数，只不过这里面的概率利用了指数运算。依照上面函数的输出结果，可以认为y[2]的概率最大（达到了0.73） 六、手写数字识别假设学习工作已经全部完成，我们通过得到的参数实现神经网络的“推理处理”，推理处理也被称为神经网络的“前向传播”(forward propagation)。 1）MINIST数据集关于MINIST数据集的介绍，请移步百度 加载：这里需要用到书中的源码。仅需要理解加载的结果是：60000张训练图，10000张测试图 import sys, os sys.path.append(os.pardir) from dataset.mnist import load_mnist (x_train, t_train),(x_test, t_test) = load_mnist(flatten=True,normalize=False，one_hot_label=False) print(x_train.shape) #(60000, 784) 60000张28×28像素的训练图 print(t_train.shape) #(60000,)训练图的标签 print(x_test.shape) #(10000, 784)10000张测试图 print(t_test.shape) #(10000,)测试图的标签 load_minist的参数： flatten：是否将图像表示为一维数组。若flatten=False,则图像是1×28×28的三维数组，flatten=True,图像是784个元素的一维数组 normalize：是否将图像正规化。若normalize=False，则数据的值为0~225，若normalize=True，则数据的值为0~1.0 one_hot_label: 当one_hot_label=True时，会将正确解的标签设为1，错误解设为0。 图像显示import sys, os sys.path.append(os.pardir) import numpy as np from dataset.mnist import load_mnist from PIL import Image def img_show(img): pil_img = Image.fromarray(np.uint8(img)) pil_img.show() (x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False) img = x_train[0] label = t_train[0] print(label) # 5 print(img.shape) # (784,) img = img.reshape(28, 28) # 把图像恢复为原来的尺寸 print(img.shape) # (28, 28) img_show(img) 这里用到PIL库。它的作用是将矩阵显示为图像可以看到，x_train[0]保存的是图像“5”，t_train[0]保存的是整数5 2) 神经网络的推理处理任务分析：我们要将MINIST数据集中的照片进行分类工作。神经网络的输入层有784个单元（28×28像素的图片），输出层有10个单元（数字共有0到9，10个类别）。 而神经网络的很多参数是通过训练得到的。这里直接使用训练完的参数: import sys, os sys.path.append(os.pardir) import numpy as np import pickle from dataset.mnist import load_mnist from common.functions import sigmoid, softmax def get_data(): (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, flatten=True, one_hot_label=False) return x_test, t_test def init_network(): with open(&quot;sample_weight.pkl&quot;, &#39;rb&#39;) as f: network = pickle.load(f) return network def predict(network, x): W1, W2, W3 = network[&#39;W1&#39;], network[&#39;W2&#39;], network[&#39;W3&#39;] b1, b2, b3 = network[&#39;b1&#39;], network[&#39;b2&#39;], network[&#39;b3&#39;] a1 = np.dot(x, W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, W2) + b2 z2 = sigmoid(a2) a3 = np.dot(z2, W3) + b3 y = softmax(a3) return y x, t = get_data() network = init_network() # 建立神经网络 accuracy_cnt = 0 for i in range(len(x)): y = predict(network, x[i]) #进行预测 p= np.argmax(y) # 获得概率最高的元素的索引，完成预测 if p == t[i]: accuracy_cnt += 1 #统计有多少张图片分类正确 print(&quot;Accuracy:&quot; + str(float(accuracy_cnt) / len(x))) # 0.9352 即该神经网络的精度是93.52% 3)批处理前面的代码进行了10000张784像素图片的分类工作。每张图片是逐个处理的。实际上完全可以把输入数据处理成10000×784的矩阵，这样就可以一次处理得到全部结果。这种打包式的输入数据称为批(batch)批处理可以节约计算机的运算成本批处理的代码： #x, t = get_data() #network = init_network() # 建立神经网络 #accuracy_cnt = 0 #for i in range(len(x)): # y = predict(network, x[i]) #进行预测 # p= np.argmax(y) # 获得概率最高的元素的索引，完成预测 # if p == t[i]: # accuracy_cnt += 1 #统计有多少张图片分类正确 x, t = get_data() network = init_network() # 建立神经网络 accuracy_cnt = 0 batch_size = 100 #设定批的大小 for i in range(0,len(x),batcg_size): x_batch = x[i : i + batch_size] y_batch = predict(network, x_batch) p = np.argmax(y_batch, axis=1) accuracy_cnt += np.sum(p == t[i:i+batch_size]) 书中源码把批的大小设定为100。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"鱼书笔记","slug":"鱼书笔记","permalink":"/tags/鱼书笔记/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"鱼书笔记 第一章 NumPy和Matplotlib的使用","slug":"鱼书笔记 第一章 NumPy库和Matplotlib库的使用","date":"2020-09-20T03:40:24.000Z","updated":"2021-02-08T02:04:27.187Z","comments":true,"path":"2020/09/20/鱼书笔记 第一章 NumPy库和Matplotlib库的使用/","link":"","permalink":"/2020/09/20/鱼书笔记 第一章 NumPy库和Matplotlib库的使用/","excerpt":"","text":"一、NumPy库Numpy是一个封装了数组和矩阵运算的库 1、 导入import numpy as np 导入numpy，并给它起了一个小名“np” 2、 生成numpy数组x = np.array([1.0, 2.0, 3.0])#使用列表进行初始化&amp;赋值 y = np.array([2.0, 4.0, 6.0]) print(x + y) print(x * y) print(x / y) 输出为: [3. 6. 9.] [ 2. 8. 18.] [0.5 0.5 0.5] 注意这里的四则运算是“对应元素的”，相当于矩阵的点乘。假如两个数组的长度不相同，程序会报错。 数组也可以与数字进行线性运算 x = np.array([1.0, 2.0, 3.0]) print(2 * x) print(x / 2) print(2 / x) 输出为 [2. 4. 6.] [0.5 1. 1.5] [2. 1. 0.66666667] 3、NumPy的N维数组直接使用n维列表作参数 x = np.array([[1.0, 2.0, 3.0],[3.4, 2.0, 9.0]]) print(x) print(x.shape) # 返回x的形状 print(x.dtype) # 返回x的元素类型 输出结果为： [[1. 2. 3. ] [3.4 2. 9. ]] (2, 3) float64 N维数组的四则运算与向量运算规则相同 4、广播前面的例子中 x = np.array([1.0, 2.0, 3.0]) print(2 * x) 这句代码为什么能运行呢? 数字本质是1×1的矩阵，数字和向量为什么能相乘呢？这里用到广播，它会自动将小数组扩充为大数组比如 x = np.array([[1.0, 2.0, 3.0],[3.4, 2.0, 9.0]]) y = np.array([[1], [2]]) z = np.array([1,2,1]) print(x + y) print(x + z) y被扩充为[[1, 1, 1], [2, 2, 2]]z被扩充为[[1, 2, 1], [1, 2, 1]]输出结果： [[ 2. 3. 4. ] [ 5.4 4. 11. ]] [[ 2. 4. 4. ] [ 4.4 4. 10. ]] 5、元素访问1）使用[]print(x[0][0]) print(x[-1][-1]) print(x[0]) 输出为： 1.0 9.0 [1. 2. 3.] 2）简单遍历：x = np.array([[1.0, 2.0, 3.0],[3.4, 2.0, 9.0]]) for i in x: print(i) 输出结果： [1. 2. 3.] [3.4 2. 9. ] 3）将高维数组转化为一维数组x = np.array([[1.0, 2.0, 3.0],[3.4, 2.0, 9.0]]) y = x.flatten() print(y) 输出结果为： [1. 2. 3. 3.4 2. 9. ] 这与初始化的数据顺序是一致的。（与matlab有差异） 4）bool索引的使用x = np.array([[1.0, 2.0, 3.0],[3.4, 2.0, 9.0]]) print( x &gt; 2.5) print(x[x &gt; 2.5]) 输出为 [[False False True] [ True False True]] [3. 3.4 9. ] print(x[x &gt; 0]) 输出为： [1. 2. 3. 3.4 2. 9. ] bool索引返回的是一维数组 二、Matplotlib库Matplotlib是一个图形绘制库，可以将数据可视化 1、 绘制简单图形1）生成数据x = np.arange(0,6,0.1)#以0.1为步长，生成0到6的数据 y = np.sin(x) print(x) print(y) 输出结果为： [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2. 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3. 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4. 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5. 5.1 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9] [ 0. 0.09983342 0.19866933 0.29552021 0.38941834 0.47942554 0.56464247 0.64421769 0.71735609 0.78332691 0.84147098 0.89120736 0.93203909 0.96355819 0.98544973 0.99749499 0.9995736 0.99166481 0.97384763 0.94630009 0.90929743 0.86320937 0.8084964 0.74570521 0.67546318 0.59847214 0.51550137 0.42737988 0.33498815 0.23924933 0.14112001 0.04158066 -0.05837414 -0.15774569 -0.2555411 -0.35078323 -0.44252044 -0.52983614 -0.61185789 -0.68776616 -0.7568025 -0.81827711 -0.87157577 -0.91616594 -0.95160207 -0.97753012 -0.993691 -0.99992326 -0.99616461 -0.98245261 -0.95892427 -0.92581468 -0.88345466 -0.83226744 -0.77276449 -0.70554033 -0.63126664 -0.55068554 -0.46460218 -0.37387666] 2）绘制图形plt.plot(x, y) plt.show() 得到如下图形: 2、 其他功能的简单示例import numpy as np import matplotlib.pyplot as plt plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;] #加上这句可以正常显示中文 x = np.arange(0,6,0.1)#以0.1为步长，生成0到6的数据 y1 = np.sin(x) y2 = np.cos(x) plt.plot(x, y1, label=&quot;sin&quot;) plt.plot(x, y2, linestyle = &quot;--&quot;, label=&quot;cos&quot;) #用虚线绘制 plt.xlabel(&quot;x&quot;) #x轴标签 plt.ylabel(&quot;y&quot;) #y轴标签 plt.title(&quot;sin和cos函数&quot;) plt.legend() #显示图例 plt.show() 效果： 3、 显示图像import numpy as np import matplotlib.pyplot as plt from matplotlib.image import imread img = imread(&#39;timg.jfif&#39;) plt.imshow(img) plt.show() 显示效果：","categories":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"/tags/深度学习/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"鱼书笔记","slug":"鱼书笔记","permalink":"/tags/鱼书笔记/"}],"keywords":[{"name":"深度学习","slug":"深度学习","permalink":"/categories/深度学习/"}]},{"title":"leetcode 89.Gray Code（格雷码）","slug":"leetcode89.Gray Code","date":"2020-09-18T08:20:00.000Z","updated":"2021-02-08T04:42:24.847Z","comments":true,"path":"2020/09/18/leetcode89.Gray Code/","link":"","permalink":"/2020/09/18/leetcode89.Gray Code/","excerpt":"","text":"原题传送门—&gt;&gt;题目描述： 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。格雷编码序列必须以 0 开头。 示例1： 输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1 示例2: 输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 一道背答案的题,记录一下.我先参考了下面这篇文章:原文链接:格雷码Gray Code详解 第一步，改变最右边的位元值； 第二步，改变右起第一个为1的位元的左边位元； 第三步，第四步重复第一步和第二步，直到所有的格雷码产生完毕（换句话说，已经走了(2^n) - 1 步）。 class Solution { public: vector&lt;int&gt; grayCode(int n) { vector&lt;int&gt; ans; if(!n) { ans.push_back(0); return ans; } int count = (1 &lt;&lt; (n-1));//共需要生成2*count个数字,循环count次 int num = 0; for(int i = 0; i &lt; count; ++i) { ans.push_back(num); num ^= 1; ans.push_back(num); change(num); } return ans; } void change(int &amp;n)//改变n右起第一个为‘1’的位的左位 { int i = 1; int flag = 0; while(!flag)//flag为1时退出循环 { flag = n &amp; i; i = i &lt;&lt; 1; } n = n ^ i; } }; 该方案仅仅击败了40% ,看到题解中有套更好的算法:原文链接:Gray Code （镜像反射法，图解） 所以用这种思想我又重写了代码: class Solution { public: vector&lt;int&gt; grayCode(int n) { vector&lt;int&gt; ans; ans.push_back(0); for(int i = 0; i &lt; n; ++i) { int start = ans.size() - 1; for(int j = start; j &gt;= 0; --j) { ans.push_back(ans[j] + (1 &lt;&lt; i)); } } return ans; } }; 果然100%kill","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"leetcode 79. Word Search","slug":"leetcode 79. Word Search","date":"2020-09-17T15:00:00.000Z","updated":"2021-02-08T04:42:17.816Z","comments":true,"path":"2020/09/17/leetcode 79. Word Search/","link":"","permalink":"/2020/09/17/leetcode 79. Word Search/","excerpt":"","text":"原题传送门—&gt;题目描述：Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 示例 board = [ [‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’] ] Given word = “ABCCED”, return true. Given word = “SEE”, return true. Given word = “ABCB”, return false. 标准的深搜题，直接上代码 class Solution { public: int **mark; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { if(board.empty()) return false; mark = new int*[board.size()]; for(int i = 0; i &lt; board.size(); ++i) { mark[i] = new int[board[0].size()]; memset(mark[i], 0, board[0].size()*4); } bool ans = false; for(int i = 0; i &lt; board.size(); ++i) { for(int j = 0; j &lt; board[0].size(); ++j) { if(find(board, word, i, j, 0)) { for(int k = 0; k &lt; board.size(); ++k) { delete []mark[k]; } delete []mark; return true; } } } for(int k = 0; k &lt; board.size(); ++k) { delete []mark[k]; } delete []mark; return false; } bool find(vector&lt;vector&lt;char&gt;&gt; &amp; board, string &amp; word,int row, int column, int pos) { if((row &lt; 0)||(column &lt; 0)||(row == board.size())||(column == board[0].size())) return false; if((mark[row][column])||(board[row][column] != word[pos])) return false; if(pos == word.size() - 1) return true; bool ans = false; mark[row][column] = 1; if(find(board, word, row - 1, column, pos + 1)|| find(board, word, row, column - 1, pos + 1)|| find(board, word, row + 1, column, pos + 1)|| find(board, word, row, column + 1, pos + 1)) return true; mark[row][column] = 0; return ans; } }; 不过这道题有一点需要注意：第47行之后这一段：AC版本: bool ans = false; mark[row][column] = 1; if(find(board, word, row - 1, column, pos + 1)|| find(board, word, row, column - 1, pos + 1)|| find(board, word, row + 1, column, pos + 1)|| find(board, word, row, column + 1, pos + 1)) return true; mark[row][column] = 0; return ans; 原本我是这样写的，会超时：TLE版本： bool ans = false; mark[row][column] = 1; ans |= find(board, word, row - 1, column, pos + 1); ans |= find(board, word, row, column - 1, pos + 1); ans |= find(board, word, row + 1, column, pos + 1); ans |= find(board, word, row, column + 1, pos + 1); return true; mark[row][column] = 0; return ans; 这两段代码我之前以为是一样的，但其实效率差很多，看TLE版本的代码：假如ans在第一步之后就变成true，那么之后的递归已经没有意义了，直接return就可以了。而使用if判断时，对于||条件，当前一个条件值为1，便不会再执行之后的语句了，相当于直接return,所以效率要高很多。","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"爬虫实战 皇室战争部落管理 第一步：数据获取","slug":"py爬虫 皇室战争玩家信息获取","date":"2020-09-17T14:00:00.000Z","updated":"2021-02-08T04:46:20.196Z","comments":true,"path":"2020/09/17/py爬虫 皇室战争玩家信息获取/","link":"","permalink":"/2020/09/17/py爬虫 皇室战争玩家信息获取/","excerpt":"","text":"任务：从royaleapi.com上爬取皇室战争的部落信息，并保存在词典中任务分为两个模块： 1、获取html文件 2、解析html数据 需要用到的其他知识储备： 对html与css的有简单的了解 了解re、urllib、bs4库的主要函数 了解正则表达式 一、获取html文件直接上代码 import urllib.error, urllib.request def askURL(url): head1 = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&quot;} reque = urllib.request.Request(url,headers = head1); html = &quot;&quot; try: response = urllib.request.urlopen(reque) html = response.read().decode(&quot;utf-8&quot;) except urllib.error.URLError as e: if hasattr(e,&quot;code&quot;): print(e.code) if hasattr(e,&quot;reason&quot;): print(e.reason) return html 逐行解释： 1、本函数需要用到urllib库 2、head1时一个字典，中保存了用户信息User-Agent。（在访问一个网站时，浏览器会向网站发送自己的身份信息。这段信息便是作为身份信息，提取自我自己的火狐浏览器。假如不设置，浏览器会向网站发送的身份是“urllib”，等于告诉网站“我是爬虫🐶”） 3、try语句块中： response保存了打开的网页文件 html保存了以utf8编码的字符串 4、该函数返回值为网页信息的字符串 此时返回的字符串内容如下： &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;title&gt;任性小部落 #YJ0PPR8J | Clan - RoyaleAPI&lt;/title&gt; &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; href=&quot;https://royaleapi.com/static/img/favicon/apple-touch-icon.png?t=0647bd87d25109655af8f3e1e88c40a0ce2192c9&quot;&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=&quot;https://royaleapi.com/static/img/favicon/favicon-32x32.png?t=c98ef822a9cedab0fe9ee93478d40d899667c661&quot;&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=&quot;https://royaleapi.com/static/img/favicon/favicon-16x16.png?t=21c28d2951994ad25eb03db2315d82e2132d2678&quot;&gt; &lt;link rel=&quot;manifest&quot; href=&quot;/static/img/favicon/manifest.json?t=34423a0929bf95545ca783822157e9a2b5dd8ba2&quot;&gt; &lt;link rel=&quot;mask-icon&quot; href=&quot;https://royaleapi.com/static/img/favicon/safari-pinned-tab.svg?t=f09d05bf709e0166cade8ea86d08e805d87c1960&quot; color=&quot;#5bbad5&quot;&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://royaleapi.com/favicon.ico&quot;&gt; &lt;meta name=&quot;msapplication-config&quot; content=&quot;https://royaleapi.com/static/img/favicon/browserconfig.xml?t=31082b60c007fac280802a7cea7386a75d20e5d4&quot;&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.royaleapi.com&quot; crossorigin&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.googleapis.com&quot;&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://www.google-analytics.com&quot;&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://cdnjs.cloudflare.com&quot;&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.jsdelivr.net&quot;&gt; &lt;meta name=&quot;google&quot; content=&quot;notranslate&quot; /&gt; &lt;meta name=&quot;title&quot; content=&quot;任性小部落 #YJ0PPR8J | Clan - RoyaleAPI&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;The definitive source about decks, players and teams in Clash Royale. Explore advanced statistics about decks and cards based on millions of games per week.&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;Clash Royale, stats, analytics, decks, esports, API, strategy, guides, chests, Clash, Royale, RoyaleAPI, data, statistics, meta, best, cards, pro&quot;&gt; &lt;meta property=&quot;og:title&quot; content=&quot;任性小部落 #YJ0PPR8J | Clan - RoyaleAPI&quot;&gt; &lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt; &lt;meta property=&quot;og:site_name&quot; content=&quot;RoyaleAPI&quot;&gt; &lt;meta property=&quot;og:url&quot; content=&quot;https://royaleapi.com/clan/YJ0PPR8J&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.royaleapi.com/static/semantic/dist/semantic.min.css?t=32a6bbf4a921163b72ef7bc18a2eff658b0fcb16&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.royaleapi.com/static/scss/app.css?t=794ec8229089e2a68160fc83ea1d4f4554394872&quot; /&gt; &lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot; /&gt; &lt;meta name=&quot;twitter:site&quot; content=&quot;@RoyaleAPI&quot;&gt; &lt;meta name=&quot;twitter:creator&quot; content=&quot;@RoyaleAPI&quot;&gt; &lt;meta name=&quot;twitter:title&quot; content=&quot;任性小部落 #YJ0PPR8J | Clan - RoyaleAPI&quot;&gt; &lt;meta name=&quot;twitter:description&quot; content=&quot;The definitive source about decks, players and teams in Clash Royale. Explore advanced statistics about decks and cards based on millions of games per week.&quot;&gt; &lt;meta property=&quot;og:image:width&quot; content=&quot;127&quot;&gt; &lt;meta property=&quot;og:image:height&quot; content=&quot;151&quot;&gt; &lt;meta property=&quot;og:image&quot; content=&quot;https://cdn.royaleapi.com/static/img/badge/Cherry_Blossom_08.png?t=ede825cbfc9d9dec589c7284b72be82548937828&quot;&gt; &lt;meta property=&quot;og:description&quot; content=&quot;一起来玩耍呀 部落Q群683185709 捐卡500授长老 积极参加部落战 月亮不睡我不睡我是秃头小宝贝(⊙o⊙)！&quot;&gt; （以上显示的是一小部分） 二、将得到的数据进行处理from bs4 import BeautifulSoup import re findPlayerTag = re.compile(r&#39;data-tag=(.*)&quot;&#39;) findPlayerName = re.compile(r&#39;data-name=(.*)&quot;&#39;) findDonate = re.compile(r&#39;&lt;td class=&quot;donations right aligned mobile-hide&quot; data-sort-value=(.*)&gt;&#39;) def getdata(url): dic = {} html = askURL(url) soup = BeautifulSoup(html,&quot;html.parser&quot;) wholedata = soup.select(&#39;tbody &gt; tr&#39;) for item in wholedata: s = str(item) tag = re.findall(findPlayerTag,s)[0] name = re.findall(findPlayerName,s)[0] donate = re.findall(findDonate,s) info = [] info += [cutName(str(name))] info += [str(donate)] dic[str(tag)[1:]] = info print(dic) def cutName(str): end = str.find(&#39;&quot;&#39;,2) return str[1:end] 我需要提取到的信息：玩家标签(以变量名tag进行保存)、玩家游戏昵称（以变量名name进行保存）、玩家的捐赠量（以变量名donate进行保存）。逐行解释：1、需要使用bs4和re库2、soup = BeautifulSoup(html,”html.parser”) ，BeautifulSoup执行解析工作，可以将网页处理成树形结构，而html.parser是专门用于html文件的解析器 3、wholedata = soup.select(‘tbody &gt; tr’)， select执行搜索工作。这里使用的是css选择器模式，为什么是”tbody &gt; tr“呢？这里需要查看html文件的结构 &lt;tbody&gt; &lt;tr data-tag=&quot;28PVL00L2&quot; data-role=&quot;Member&quot; class=&quot;role-Member tr_member&quot;&gt; &lt;td data-sort-value=&quot;1&quot;&gt;1&lt;/td&gt; &lt;td data-sort-value=神奇哟&gt; &lt;a class=&quot;block member_link&quot; data-tag=&quot;28PVL00L2&quot; href=&quot;/player/28PVL00L2&quot;&gt; 神奇哟 &lt;div class=&quot;last_seen i18n_duration_short&quot; data-seconds=&quot;&quot; data-datetime=&quot;20200917T043248.000Z&quot;&gt; 3h 17m ago &lt;/div&gt; &lt;/a&gt; &lt;div class=&quot;mobile-show&quot;&gt; &lt;div class=&quot;meta&quot;&gt; Member &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mobile-show mobile-member-summary&quot;&gt; &lt;div&gt; &lt;i class=&quot;big icons&quot;&gt; &lt;img class=&quot;ui verytiny image&quot; src=&quot;https://cdn.royaleapi.com/static/img/icon/ic-cards.png?t=73da5b1cae92477331cfa0c20a422c6cd6fa45f6&quot; /&gt; &lt;i class=&quot;corner blue arrow up icon&quot;&gt;&lt;/i&gt; &lt;/i&gt; 58 &lt;/div&gt; &lt;div&gt; &lt;i class=&quot;big icons&quot;&gt; &lt;img class=&quot;ui verytiny image&quot; src=&quot;https://cdn.royaleapi.com/static/img/icon/ic-cards.png?t=73da5b1cae92477331cfa0c20a422c6cd6fa45f6&quot; /&gt; &lt;i class=&quot;corner orange arrow down icon&quot;&gt;&lt;/i&gt; &lt;/i&gt; 160 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;join_status&quot; id=&quot;join-28PVL00L2&quot;&gt;&lt;/div&gt; &lt;/td&gt; &lt;td class=&quot;inactivity_content inactivity in_trophies&quot;&gt; &lt;img class=&quot;inactive_bar&quot; style=&quot;display:none;&quot; src=&quot;https://cdn.royaleapi.com/static/img/ui/inactivity-trophies.png?t=2a9ca5964e11b039314532607f6924022cabfc58&quot; /&gt; &lt;/td&gt; &lt;td class=&quot;inactivity_content inactivity in_donations&quot;&gt; &lt;img class=&quot;inactive_bar&quot; style=&quot;display:none;&quot; src=&quot;https://cdn.royaleapi.com/static/img/ui/inactivity-donations.png?t=873649431655834474ce80d06a2d7cdcc251ac53&quot; /&gt; &lt;/td&gt; &lt;td class=&quot;mobile-hide tablet-hide&quot;&gt; &lt;a href=&quot;/player/28PVL00L2/battles&quot;&gt; &lt;img class=&quot;ui verytiny image&quot; src=&quot;https://cdn.royaleapi.com/static/img/ui/battle.png?t=b176e1aa36db187823a4a93069cba312e838df9b&quot; alt=&quot;Battles&quot;&gt; &lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;mobile-hide&quot; data-sort-value=&quot;3&quot;&gt;Member&lt;/td&gt; &lt;td class=&quot;mobile-hide tablet-hide&quot; data-sort-value=&quot;6325462410230&quot;&gt; 28PVL00L2 &lt;/td&gt; &lt;td class=&quot;&quot; data-sort-value=&quot;5167&quot;&gt; 5,167 &lt;img class=&quot;ui mini image arena_icon&quot; src=&quot;https://cdn.royaleapi.com/static/img/arenas-fs8/arena16-fs8.png?t=3b029e481bd4b71e7e2f5256452db7a032477a68&quot; alt=&quot;Arena_L4 / Master I&quot; /&gt; &lt;/td&gt; &lt;td class=&quot;right aligned mobile-hide&quot; data-sort-value=&quot;12&quot;&gt;12&lt;/td&gt; &lt;td class=&quot;donations right aligned mobile-hide&quot; data-sort-value=&quot;58&quot;&gt; 58 &lt;i class=&quot;big icons&quot;&gt; &lt;img class=&quot;ui verytiny image&quot; src=&quot;https://cdn.royaleapi.com/static/img/icon/ic-cards.png?t=73da5b1cae92477331cfa0c20a422c6cd6fa45f6&quot; /&gt; &lt;i class=&quot;corner blue arrow up icon&quot;&gt;&lt;/i&gt; &lt;/i&gt; &lt;/td&gt; &lt;td class=&quot;donations right aligned mobile-hide&quot; data-sort-value=&quot;160&quot;&gt; 160 &lt;i class=&quot;big icons&quot;&gt; &lt;img class=&quot;ui verytiny image&quot; src=&quot;https://cdn.royaleapi.com/static/img/icon/ic-cards.png?t=73da5b1cae92477331cfa0c20a422c6cd6fa45f6&quot; /&gt; &lt;i class=&quot;corner orange arrow down icon&quot;&gt;&lt;/i&gt; &lt;/i&gt; &lt;/td&gt; &lt;td class=&quot;mobile-hide&quot;&gt; &lt;div class=&quot;&quot;&gt; &lt;input id=&quot;compare-checkbox-28PVL00L2&quot; class=&quot;compareme&quot; type=&quot;checkbox&quot; data-tag=&quot;28PVL00L2&quot; data-name=&quot;神奇哟&quot; /&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr data-tag=&quot;29LV0UYYR&quot; data-role=&quot;Co-Leader&quot; class=&quot;role-Co-Leader tr_member&quot;&gt; &lt;td data-sort-value=&quot;2&quot;&gt;2&lt;/td&gt; 可以看到，我想要的信息全部都处在&lt;tbody&gt;下的&lt;tr&gt;标签中,使用tbody &gt; tr便能提取到我想要的信息4、re是一个正则搜索库,这里主要是用到了它的findall函数，至于它的参数findPlayerTag等其实是定义为全局变量了（关于怎样定义这些变量，请百度“正则表达式”）。观察html文件，标签保存在：data-tag=”28PVL00L2”（28PVL00L2是标签），findPlayerTag = re.compile(r’data-tag=(.*)”‘)就能找到类似的字段。 三、完整代码： import urllib.error, urllib.request from bs4 import BeautifulSoup import re findPlayerTag = re.compile(r&#39;data-tag=(.*)&quot;&#39;) findPlayerName = re.compile(r&#39;data-name=(.*)&quot;&#39;) findDonate = re.compile(r&#39;&lt;td class=&quot;donations right aligned mobile-hide&quot; data-sort-value=(.*)&gt;&#39;) def askURL(url): head1 = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&quot;} reque = urllib.request.Request(url,headers = head1); html = &quot;&quot; try: response = urllib.request.urlopen(reque) html = response.read().decode(&quot;utf-8&quot;) except urllib.error.URLError as e: if hasattr(e,&quot;code&quot;): print(e.code) if hasattr(e,&quot;reason&quot;): print(e.reason) return html def getdata(url): dic = {} html = askURL(url) soup = BeautifulSoup(html,&quot;html.parser&quot;) wholedata = soup.select(&#39;tbody &gt; tr&#39;) for item in wholedata: s = str(item) tag = re.findall(findPlayerTag,s)[0] name = re.findall(findPlayerName,s)[0] donate = re.findall(findDonate,s) info = [] info += [cutName(str(name))] info += [str(donate)] dic[str(tag)[1:]] = info return dic def cutName(str): end = str.find(&#39;&quot;&#39;,2) return str[1:end] def main(): url = &quot;https://royaleapi.com/clan/YJ0PPR8J&quot; dic = getdata(url) for key,value in dic.items(): print(key) print(value) print(&quot;\\n\\n&quot;) main() 输出结果： 28PVL00L2 [&#39;神奇哟&#39;, &#39;[\\&#39;&quot;58&quot;\\&#39;, \\&#39;&quot;160&quot;\\&#39;]&#39;] 29LV0UYYR [&#39;宇宙无敌&amp;amp;地表最强 超级麦麦！&#39;, &#39;[\\&#39;&quot;326&quot;\\&#39;, \\&#39;&quot;240&quot;\\&#39;]&#39;] JY289GJ [&#39;宗大宝&#39;, &#39;[\\&#39;&quot;1013&quot;\\&#39;, \\&#39;&quot;400&quot;\\&#39;]&#39;] Q9UY98L [&#39;:(*^﹏^*):&#39;, &#39;[\\&#39;&quot;259&quot;\\&#39;, \\&#39;&quot;240&quot;\\&#39;]&#39;] 2QRRR2JGV [&#39;吉吉思密达&#39;, &#39;[\\&#39;&quot;288&quot;\\&#39;, \\&#39;&quot;256&quot;\\&#39;]&#39;] (内容过长，仅展示一小部分)","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"/tags/爬虫/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"《三体》《围城》词云","slug":"WordCloud 《围城》《三体》词云应用","date":"2020-09-09T14:16:01.000Z","updated":"2021-02-08T03:14:52.162Z","comments":true,"path":"2020/09/09/WordCloud 《围城》《三体》词云应用/","link":"","permalink":"/2020/09/09/WordCloud 《围城》《三体》词云应用/","excerpt":"","text":"wordcloud是python一个简单的词云生成库，使用教程请戳—&gt;所谓词云，就是将一大段文字（可能是一份报告、一本小说）中的词频作分析，将其中出现的关键词汇通过图片显示出来。本文利用wordcloud库，生成几本非常棒的小说的词云。 一、英文书举例：When Breath Becomes Air这本书的中译名是：《当呼吸化为空气》，强推的一本书。 简介：全世界只有万分之零点一二的人会在36岁前患上肺癌，保罗·卡拉尼什（Paul Kalanithi）是其中之一。当你读到这本书时，他已经不在人世。保罗曾获得过美国斯坦福大学英语文学及人体生物学双料学位，并于英国剑桥大学获得科学史与哲学研究硕士学位，以优异成绩获得美国耶鲁大学医学博士学位，即将获得斯坦福医学院外科教授职位并主持自己的研究室。2013年，即将抵达人生巅峰的保罗，忽然被诊断出患有第四期肺癌。自此，他开始以医生和患者的双重身份，记录自己的余生，反思医疗与人性。他的文章刊登在《纽约时报》《华盛顿邮报》等媒体，获得了全球读者关注。本书文笔优美，诚挚感人，书里有着对人性、生死、医疗的深沉思索，让全球无数读者为之动容。 *上代码import wordcloud pf = open(&quot;When-Breath-Becomes-Air-Paul-Kalanithi.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) txt = pf.read().lower() pf.close() w = wordcloud.WordCloud( width = 1000, height = 700, background_color = &quot;white&quot;, max_words = 20) w.generate(txt) w.to_file(&quot;when_breath.png&quot;) 生成效果如图 这些词和篇前的一首小诗有些重合之处，蛮有意思： You that seek what life is in death,Now find it air that once was breath.New names unknown, old names gone:Till time end bodies, but souls none.Reader! then make time, while you be,But steps to your eternity.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—Baron Brooke Fulke Greville, “Caelica 83” 二、中文书举例：《三体》 《围城》与英文书相比有以下区别： 英语单词间用空格分隔(wordcloud也是使用空格来区分单词)，而汉字的词语间并没有明显的分隔 这里需要用到中文分词库jieba wordcloud默认的字体不能显示中文 需要添加字体路径文件 这里用到的是微软雅黑”msyh.tcc” 《围城》《围城》是钱钟书所著的长篇小说，是中国现代文学史上一部风格独特的讽刺小说。被誉为“新儒林外史”。第一版于1947年由上海晨光出版公司出版。故事主要写抗战初期知识分子的群相。大部分人会把它当成爱情小说吧。 import jieba import wordcloud f = open(&quot;钱钟书《围城》.txt&quot;,&quot;r&quot;, encoding=&quot;ANSI&quot;) t = f.read() f.close() ls = jieba.lcut(t) txt = &quot; &quot;.join(ls) w = wordcloud.WordCloud( font_path = &quot;msyh.ttc&quot;, width = 1000, height = 700, background_color = &quot;white&quot;) w.generate(txt) w.to_file(&quot;《围城》.png&quot;) 生成效果如图 赵辛楣可能才是方鸿渐最重要的人，所以为什么要跟孙柔嘉结婚嘛？ 《三体》中国科幻里程碑之作，不用多描述了哈哈。 代码还是同样的配方 import jieba import wordcloud f = open(&quot;刘慈欣-三体.txt&quot;,&quot;r&quot;, encoding=&quot;utf-8&quot;) t = f.read() f.close() ls = jieba.lcut(t) txt = &quot; &quot;.join(ls) w = wordcloud.WordCloud( font_path = &quot;msyh.ttc&quot;, width = 1000, height = 700, background_color = &quot;white&quot;) w.generate(txt) w.to_file(&quot;《三体》.png&quot;) 但是可以发现，这些高频词语好多都是无意义的代词，所以进一步处理下。这里使用stopwords操作排除无意义词汇 import jieba import wordcloud f = open(&quot;刘慈欣-三体.txt&quot;,&quot;r&quot;, encoding=&quot;utf-8&quot;) t = f.read() f.close() ls = jieba.lcut(t) Stop_Words = [&quot;他们&quot;,&quot;一个&quot;,&quot;自己&quot;,&quot;没有&quot;,&quot;不是&quot;&quot;还有&quot;,&quot;可以&quot;,&quot;可能&quot;,&quot;什么&quot;,&quot;已经&quot;,&quot;这样&quot;,/ &quot;就是&quot;,&quot;只有&quot;,&quot;你们&quot;,&quot;这个&quot;,&quot;当然&quot;,&quot;我们&quot;,&quot;看到&quot;,&quot;知道&quot;,&quot;现在&quot;,&quot;这种&quot;,/ &quot;这里&quot;,&quot;不是&quot;,&quot;只是&quot;,&quot;还是&quot;,&quot;如果&quot;,&quot;那个&quot;,&quot;这些&quot;,&quot;出现&quot;,&quot;还有&quot;,&quot;这时&quot;,&quot;真的&quot;] #这个列表里的词汇不会在词云中显示 txt = &quot; &quot;.join(ls) w = wordcloud.WordCloud( font_path = &quot;msyh.ttc&quot;, width = 1000, height = 700, background_color = &quot;white&quot;, stopwords=Stop_Words) w.generate(txt) w.to_file(&quot;《三体》.png&quot;) 最终效果图","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"wordcloud","slug":"wordcloud","permalink":"/tags/wordcloud/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"C++ 利用迭代器删除元素后会发生什么？（转载）","slug":"C++ 利用迭代器删除元素后会发生什么？","date":"2020-09-05T09:25:00.000Z","updated":"2021-02-08T04:42:39.317Z","comments":true,"path":"2020/09/05/C++ 利用迭代器删除元素后会发生什么？/","link":"","permalink":"/2020/09/05/C++ 利用迭代器删除元素后会发生什么？/","excerpt":"","text":"原文链接：C++中利用迭代器删除元素会发生什么？ （1）关联容器对于关联容器（如map，set，multimap，multiset），删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前的iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入，删除一个结点不会对其他结点造成影响。使用方式如下例子： set&lt;int&gt; valset = { 1,2,3,4,5,6 }; set&lt;int&gt;::iterator iter; for (iter = valset.begin(); iter != valset.end(); ) { if (3 == *iter) valset.erase(iter++); else ++iter; } 因为传给erase的是iter的一个副本，iter++是下一个有效的迭代器。 (2)顺序容器对于序列式容器（如vector，deque，list等），删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。不过erase方法可以返回下一个有效的iterator。使用方式如下,例如： vector&lt;int&gt; val = { 1,2,3,4,5,6 }; vector&lt;int&gt;::iterator iter; for (iter = val.begin(); iter != val.end(); ) { if (3 == *iter) iter = val.erase(iter); //返回下一个有效的迭代器，无需+1 else ++iter; }","categories":[{"name":"C++","slug":"C","permalink":"/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"STL","slug":"STL","permalink":"/tags/STL/"}],"keywords":[{"name":"C++","slug":"C","permalink":"/categories/C/"}]},{"title":"leetcode 60 求第k个排列（全排列相关）","slug":"leetcode 60 求第k个排列（全排列相关）","date":"2020-09-03T01:40:00.000Z","updated":"2021-02-08T04:42:10.871Z","comments":true,"path":"2020/09/03/leetcode 60 求第k个排列（全排列相关）/","link":"","permalink":"/2020/09/03/leetcode 60 求第k个排列（全排列相关）/","excerpt":"原题传送门 —&gt;&gt;","text":"原题传送门 —&gt;&gt; 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123”“132”“213”“231”“312”“321”给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1: 输入: n = 3, k = 3输出: “213” 示例 2: 输入: n = 4, k = 9输出: “2314” 容易想到的是深搜（回溯），但 O(n!)的复杂度可以直接判死刑了。（但是我看题解里确实回溯+剪枝过了的）下面的是种偏向数学的解法。 思路： 对于4个数字（1，2，3，4），1开头的序列有3! 、即6个，2开头的同理，那么假如要求第15个，那么一定是3（(15-1)除以6 再加1）开头 继续，3已经确定是第一个数字，剩下的数字有1，2，4。我们接下来需要求1、3、4全排列的第3（(15-1) mod 6）个数字，规则同上，则需要以第2（3除以2再加1）个数字开头， 2是第二个数字 同上，1是第3个数字，4是第4个数字 答案为3214 15 - 1 = 6 × 2 + 2 × 1 + 1 × 0 （6、2、1分别是3、2、1的阶乘），每次取第3、2、1 个数字（剩下一个数字自动补上就可以）100% kill代码： class Solution { public: string getPermutation(int n, int k) { vector&lt;int&gt; a; vector&lt;int&gt; b; for(int i = 1; i &lt;= n; ++i) b.push_back(i); a.push_back(1); for(int i = 2; i &lt; n; ++i) { a.push_back(a[i-2]*i); } int kk = k - 1; string ans; for(int i = 0; i &lt; n-1; ++i) { int j = kk/a[n-2-i]; kk %= a[n-2-i]; ans.push_back(b[j] + &#39;0&#39;); b.erase(b.begin()+ j); } ans.push_back(b[0] + &#39;0&#39;); return ans; } };","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"CNN News 2020/8/25 特朗普 or 拜登？","slug":"CNNnews 8月25日 拜登？特朗普？","date":"2020-08-27T14:16:01.000Z","updated":"2021-02-08T02:06:07.856Z","comments":false,"path":"2020/08/27/CNNnews 8月25日 拜登？特朗普？/","link":"","permalink":"/2020/08/27/CNNnews 8月25日 拜登？特朗普？/","excerpt":"","text":"Trump or Biden, which candidate does China want in the White House? Analysis by Selina Wang, CNNUpdated 0950 GMT (1750 HKT) August 25, 2020 Hong Kong (CNN) — US President Donald Trump recently claimed that if his Democratic rival Joe Biden wins this November’s presidential election, China will “own” the United States and Americans will have to learn to speak Chinese.The suggestion that Democrats are soft on China is a reoccurring policy theme that the President has returned to throughout his four years in oce. Now, as Trump prepares to take on Biden in a bid to secure a second term, his administration is once again amping up the anti-China rhetoric.Ahead of this week’s Republican National Convention, Trump’s campaign announced its second term agenda. The short document sets out 10 core priorities. Near the top of the agenda is “End our reliance on China,” listed right after “Jobs” and “Eradicate Covid-19.”The campaign said it plans to bring back 1 million manufacturing jobs from China and hold the country “fully accountable for allowing the virus to spread around the world.”Since Trump took oce, relations between the two countries have spiraled to their lowest point in decades. Trump has waged a tari war, sanctioned Chinese ocials, angered Beijing with his support for Taiwan, and banned Chinese technology companies, including prized telecommunications giant Huawei.Though concerns about China have become decidedly more bipartisan in recent years, there remains a view among many in Washington that Chinese leaders would prefer a President Biden come 2021. It’s an idea that was given fresh impetus, after William Evanina, a top US intelligence ocial, said in a statement last month that Beijing would rather Trump lose the election.During a key note address at the opening night of the Republican convention, Monday, former ambassador to the United Nations and former governor of South Carolina Nikki Haley said Biden would be “great for Communist China.”But experts say the reality is far more complex, and China’s leadership remains decidedly split on which candidate would better align with the country’s long-term strategic aims. Social media mockeryFrom Beijing’s perspective, Trump appears to have weakened America’s traditional alliances and international reputation. Chinese propaganda has cited Trump’s response to the pandemic, which has now killed more than 177,000 Americans, as proof of the US’ failing political system and faltering global leadership. On Chinese social media, Trump has been mockingly named “Chuan Jianguo,” or “Build up the Country Trump,” with online users positing that Trump is bolstering Chinese President Xi Jinping’s regime by wrecking America. Although Trump has unleashed an onslaught of attacks on China in the form of taris, sanctions and bans, he has largely acted unilaterally, without the support of key allies.“They know Biden will be a multilateralist, whether it’s on trade, whether it’s on security, whether it’s even on human rights,” said Stephen Orlins, president of the National Committee on US-China Relations. “He will have a multilateral approach to China and those people are fearful of a Biden presidency.” Chinese President Xi Jinping and US President Donald Trump on the sidelines of the G20 Summit in Osaka on June 29, 2019.During Trump’s presidency, China has been given a window to be more assertive on the international stage. After Trump announced America’s withdrawal from the World Health Organization (WHO), Xi said China would provide $2 billion over two years to help with the global pandemic response. China has pressed ahead with a national security law in Hong Kong, hardened its stance on self-governing Taiwan, which China views as an inseparable part of its territory, and continued to aggressively push its claims of sovereignty in the disputed waters of the South China Sea. According to Minxin Pei, professor of government at Claremont McKenna College and author of “China’s Crony Capitalism,” Biden would reinstate America’s support for multilateral organizations, including the WHO, while strengthening trade and North Atlantic Treaty Organization (NATO) military alliances — all of which would constrain China. Though Biden only mentioned China once in his acceptance speech at the Democratic National Convention last week, he has repeatedly condemned Trump for being weak on China. He’s called Xi a “thug” and his campaign ads have claimed Trump hasn’t held China accountable for the spread of the pandemic, amid suggestions Chinese ocials covered up the initial outbreak. Democratic presidential candidate Joe Biden speaks at the Democratic National Convention on August 20 in Wilmington, Delaware. In the Democrats’ sweeping 92-page party platform outlining policies including health care, climate change and the economy, China is mentioned 22 times. The document outlines how “Democrats will take aggressive action against China or any other country that tries to undercut American manufacturing,” work with “allies to stand up to China,” condemn “China’s mass internment of Uyghurs and other ethnic minorities” in Xinjiang, and enforce sanctions on entities “responsible for undercutting Hong Kong’s autonomy.” Biden wrote in a Foreign Aairs article earlier this year that, “China can’t aord to ignore more than half the global economy. That gives us substantial leverage to shape the rules of the road on everything from the environment to labor, trade, technology, and transparency, so they continue to reflect democratic interests and values.”Susan Shirk, chair of the 21st Century China Center at UC San Diego and former Deputy Assistant Secretary of State during the Clinton administration, said China has “lost a lot of friends in Asia” by using its economic power to coerce other countries into endorsing the Chinese line. “If there is a Biden administration, building a stronger coalition in Asia will be a lot easier.” Trump’s ‘unpredictability’But whereas a Biden presidency would be challenging for Beijing, Trump presents something altogether dierent for risk-averse leaders in Beijing: volatility. In a recent US intelligence report compiled by top ocial Evanina, Trump’s “unpredictability” was cited as a reason why China would prefer Biden.When Trump first took oce, he sang Xi’s praises after they dined together at his Mar-a-Lago estate in Florida. But that hasn’t stopped him alternating between aiming threats at China and announcing that he and Xi “love each other.” Experts say that this type of unpredictability increases the risk of military escalation, in areas where interests overlap, such as the South China Sea, East China Sea, and Taiwan. “We do not have a good communications and crisis prevention with China the way we had with the Soviet Union during the Cold War,” Shirk said. “So it’s a very dangerous situation.” Chinese state media has called Biden “smoother” to deal with, creating room to cooperate on major international issues like climate change and nuclear non-proliferation. Henry Wang, an adviser to China’s cabinet and founder of the Center for Globalization, said that under a Biden administration, there would be more opportunities for dialogue. Pei said the split in Chinese attitudes toward Trump and Biden depend on whether ocials in Beijing are taking a short- or long-term view. Those who take a long-term view prefer Trump, since they view him as being incompetent and unable to get allies on board, thus giving China more room to maneuver. Another four years of Trump would lead to more internal divisions within America, reducing its ability to successfully wage a long-term struggle against China, Pei said. “The Biden administration can devise a long-term strategy that is sustainable, that is multilateral with ally support, that will actually contain Chinese power, much more eectively for the next two to three decades,” Pei said. Those focused on the near-term would prefer Biden, since he would put a pause in the rapidly deteriorating relations. “A Biden administration will most likely have a pause in what I call this demolition process, Pei said. “It’s not in the US’ fundamental interest to demolish the most important relationship in the world.” 中国希望谁赢得大选？特朗普？拜登？作者: Selina Wang, CNN最后更新于 GMT 2020年 8月25日 CNN记者香港报道—— 美国总统唐纳德-特朗普声称，假如他的民主党对手拜登当选，中国将“战胜”美国,并且美国人将不得不学习汉语。 在奥巴马执政时期，特朗普就在他的政治口号中反复强调民主党对中国软弱。 而如今，在与拜登竞争以争取连任之际，特朗普再次鼓吹中国的威胁。 在本周的共和党全国代表大会之前，川普的竞选团队宣布了他们第二个任期的计划，这份简短的文件列出了十项核心计划，排在最前面便有“摆脱对中国的依赖”，这一项紧跟“工作”和“根除新冠病毒”之后，列在第三位。 川普的竞选团队称，他们计划把一百万个工作岗位从中国带回来，并认为中国对冠状病毒在世界的传播负有全责。 自特朗普接替奥巴马以来，两个国家的关系慢慢下降到了数十年的最低水平。特朗普发动了一场针锋相对的战争，对中国政府进行了制裁，他对台湾的支持激怒了北京，并且禁止了中国的科技公司，包括著名电信巨头华为。 尽管近年来两党对于中国问题的看法越来越趋于一致，仍有意见认为北京希望拜登赢得大选。在美国高级情报社会威廉·伊万尼纳(William Evanina)上个月在一份声明中表示，北京方面宁愿特朗普输掉选举后，这一想法得到了新的推力。 周一，前驻联合国大使、南卡罗来纳州前州长尼基·黑利(Nikki Haley)在共和党全国代表大会开幕当晚的一次重要讲话中表示，拜登将“对共产主义中国非常有利”。 然而专家们说情况远比这复杂，中国的领导层对于谁当选对中国的战略规划更有利这个问题上存在分歧。 社交媒体上的嘲弄从中国的角度来说，川普的表现削弱了美国的传统联盟，损坏了美国的国际声誉。中国的宣传中引用了特朗普对冠状病毒传播的应对，这场疾病流行现在已经杀死了超过17.7万美国人，这证明了美国政治体系的失败和全球领导力的削弱。 在中国的社交媒体中，特朗普被戏称为“川建国”或者“建立国家的川普”， 网友们认为特朗普正在通过破坏美国来巩固习近平主席的政权。尽管特朗普以恐怖袭击，制裁和禁令的形式对中国发动了猛烈攻击，但他基本上在单独行动，没有得到主要盟友的支持。 美中关系全国委员会(National Committee on US-China Relations)主席斯蒂芬·奥尔林斯(Stephen Orlins)表示：“他们知道拜登将是一个多边主义者，无论是在贸易、安全、甚至是人权方面。” “他将以多边的方式来对待，那些人担心拜登当选总统。” （图）2019年6月29日，中国国家主席习近平和美国总统唐纳德 · 特朗普在大阪出席 G20峰会 在特朗普的任期内，中国被给予了在世界舞台更加自信地展现自己的窗口。在特朗普宣布退出世卫组织（WHO）之后，习近平主席宣布将在未来两年内提供二十亿美元资金，以帮助应对世界疾病流行。中国已经在香港颁布了国安法，强调了对于“台独“的立场——台湾是中国领土不可分割的一部分，并继续在南海有争议海域强调自己的主权。克莱蒙特·麦肯纳学院教授、《中国的裙带资本主义》作者Minxin Pei说，拜登（上台后）将会恢复对各种组织、包括WHO、北约，这些将会约束中国。 尽管拜登在上周的总统提名演讲上仅仅提到了中国一次，但他反复谴责特朗普对中国的软弱，他称习近平主席为“暴徒”，并且他的竞选广告声称特朗普没有追究中国对疫情蔓延的责任，因为有传言称中国官员掩盖了最初的疫情。 (图)民主党总统候选人乔·拜登8月20日在特拉华州威明顿市举行的民主党全国代表大会上发表讲话。 在民主党人长达92页的政党纲领中，概述了包括医疗保健，气候变化和经济在内的政策，“中国”被提到了22次，这份文件概述了“民主党人将如何对中国或任何其他试图削弱美国制造业的国家采取积极行动”，如何与“盟友合作对抗中国”，如何谴责“中国在新疆大规模关押维吾尔族人和其他少数民族”，以及如何对“破坏香港自治”的实体实施制裁。 在今年早些时候，拜登在《外国航空》上刊文道：“中国不能忽视全球一半以上的经济。 这给了我们很大的筹码来塑造从环境到劳动力、贸易、技术和透明度等方方面面的规则，以此让它们它们继续反映民主国家的利益和价值观。苏珊·希尔克（Susan Shirk）是加州大学圣地亚哥分校21世纪中国中心主席，克林顿政府时期任美国副国务卿。他说，中国已经“利用其经济实力迫使其他国家认可‘中国路线’，从而失去了很多亚洲朋友”。 “如果有拜登政府，在亚洲建立更强大的联盟将容易得多。” 特朗普的“不可预测性”但是，尽管拜登担任总统对北京而言是具有挑战性的，但特朗普对北京的规避风险的领导人们带来了完全不同的东西：动荡。 在由高级社会人士埃文娜（Evanina）编制的最新美国情报报告中，特朗普的“不可预测性”被认为是中国偏爱拜登的原因。 特朗普刚刚接替奥巴马后，他在习近平在佛罗里达州Mar-a-Lago庄园共进晚餐后唱赞歌。 但这并没有阻止他在针对中国发动威胁与宣布他与习近平“彼此相爱”之间不停转换态度。 专家说，在诸如南中国海，东中国海和台湾等利益重叠的地区，这种不可预测性增加了军事升级的风险。 Shirk说：“与冷战时期相比，我们与中国之间的沟通和危机预防不如当时和苏联那样好。” “所以这是非常危险的情况。” 中国官方媒体称应对拜登“更为容易”，为在气候变化和核不扩散等重大国际问题上开展合作创造了空间。 中国内阁顾问、全球化中心(Center For Globalization)创始人亨利·王(Henry Wang)表示，在拜登政府的领导下，将有更多对话机会。 Pei说，中国对特朗普和拜登的态度分歧取决于北京的社会主义者是短期还是长期地看待这个问题。 那些从长远眼光看事情的人更喜欢特朗普，因为他们认为特朗普不能胜任这个位置而且无法招募盟友，从而为中国提供了更大的回旋余地。 Pei说，特朗普再任四年将导致美国内部出现更多分歧，从而降低其成功与中国进行长期斗争的能力。 Pei还说：“拜登政府可以制定一项可持续的长期战略，这是在盟友支持下的多边战略，实际上将遏制中国的力量，在接下来的两到三十年中将更加有效。” 那些关注近期局势的人更喜欢拜登，因为他会暂停迅速恶化的关系。”,Pei说：“拜登政府很可能会暂停我所说的“拆除”过程。”,“摧毁世界上最重要的关系不符合美国的根本利益。”","categories":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"/tags/英语/"},{"name":"CNN新闻","slug":"CNN新闻","permalink":"/tags/CNN新闻/"}],"keywords":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}]},{"title":"C++ 一个对象占用的空间大小计算（转载）","slug":"2020-8-12-cpp-class-space","date":"2020-08-12T14:16:01.000Z","updated":"2021-02-08T04:36:36.892Z","comments":false,"path":"2020/08/12/2020-8-12-cpp-class-space/","link":"","permalink":"/2020/08/12/2020-8-12-cpp-class-space/","excerpt":"一个class对象需要占用的内存空间大小，最权威的结论是： 非静态成员变量总合 加上编译器为了CPU计算，作出的数据对齐处理 加上为了支持虚函数，产生的额外负担 可以分为基类和派生类两种情况来查看一个类占用的内存空间大小。","text":"一个class对象需要占用的内存空间大小，最权威的结论是： 非静态成员变量总合 加上编译器为了CPU计算，作出的数据对齐处理 加上为了支持虚函数，产生的额外负担 可以分为基类和派生类两种情况来查看一个类占用的内存空间大小。 原文链接：https://blog.csdn.net/u011012049/article/details/48767917 基类(一)class CBase { }; sizeof(CBase)=1； c++要求每个实例在内存中都有独一无二的地址，空类也会被实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1。 (二)class CBase { private: int a; char p; }; sizeof(CBase)=8; 记得对齐的问题。int 占4字节，char占一字节，补齐3字节。 (三)class CBase { private: int a; char p; static int b; } sizeof(CBase)=8; 静态成员变量属于整个类，不单独属于某个对象。 (四)class CBase { public: void func(); private: int a; char p; }; sizeof(CBase)=8; 成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table，table里面记录的各个成员函数的地址. (五)class CBase { public: CBase(void); virtual ~CBase(void); private: int a; char *p; }; sizeof(CBase)=12 C++类中有虚函数的时候有一个指向虚函数表的指针（vptr），在32位系统分配指针大小为4字节。一个基类对象无论有多少个虚函数，只有这一个指针，4字节。在内存布局中，C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 派生类派生类的大小是本身成员变量的大小加上基类的大小。如果派生类继承了多个基类的虚函数，那个这个派生类的所有虚函数所占用的内存空间等于4*（基类个数），即为每个拥有虚函数的基类维护一张虚函数表。 class B1 { public: int x; virtual void v1(){ cout &lt;&lt; &quot;B1::v1&quot; &lt;&lt; endl; } void f1(){cout &lt;&lt; &quot;B1::f1&quot; &lt;&lt; endl; } }; class B2 { public: int y; virtual void v2(){ cout &lt;&lt; &quot;B2::v2&quot; &lt;&lt; endl; } void f2(){ cout &lt;&lt; &quot;B2::f2&quot; &lt;&lt; endl; } }; class B3 { public: int z; virtual void v3(){ cout &lt;&lt; &quot;B3::v3&quot; &lt;&lt; endl; } void f3(){ cout &lt;&lt; &quot;B3::f3&quot; &lt;&lt; endl; } }; class D : public B1, public B2, public B3 { public: int a; void v3(){ cout &lt;&lt; &quot;D::v3&quot; &lt;&lt; endl; } virtual void vD(){ cout &lt;&lt; &quot;D::vD&quot; &lt;&lt; endl; } }; 内存布局为： 与单继承相同的是所有的虚函数都包含在虚函数表中，所不同的是多重继承有多个虚函数表，当子类对父类的虚函数有重写时，子类的函数覆盖父类的函数在对应的虚函数位置，当子类有新的虚函数时，这些虚函数被加在第一个虚函数表的后面。 参考：http://blog.sina.com.cn/s/blog_69c189bf0100mkeuhttp://www.cnblogs.com/itech/archive/2009/02/28/1399995","categories":[{"name":"C++","slug":"C","permalink":"/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"}],"keywords":[{"name":"C++","slug":"C","permalink":"/categories/C/"}]},{"title":"The Guardian 2020/8/4 Tiktok被强制拆分","slug":"The Guardian Tiktok被强制拆分","date":"2020-08-04T13:32:00.000Z","updated":"2021-02-08T03:14:38.464Z","comments":true,"path":"2020/08/04/The Guardian Tiktok被强制拆分/","link":"","permalink":"/2020/08/04/The Guardian Tiktok被强制拆分/","excerpt":"“Forced acquisition + only 45 days + intermediary fees are not comparable to Google. It is incredible,” he said.“强制收购+仅有45天期限+收取中介费用的行径与谷歌退出中国绝不是一回事。这太不可思议了，” 他说","text":"“Forced acquisition + only 45 days + intermediary fees are not comparable to Google. It is incredible,” he said.“强制收购+仅有45天期限+收取中介费用的行径与谷歌退出中国绝不是一回事。这太不可思议了，” 他说本文在卫报当天的阅读量在全站第5位，内容均为原文原图（但是原文没有图哈哈） TikTok row: China hits out at US ‘smash and grab’ as tech dispute deepensForeign affairs spokesman accuses US of hypocrisy and editorial in state-run newspaper decries choice between submission at ‘mortal combat’ Helen Davidson Tue 4 Aug 2020 07.18 BST The US has offered China the “choice of submission or mortal combat in the tech realm”, state media in Beijing have said, as the two rival powers manoeuvred on the thorny issue of splitting up TikTok. The popular video-sharing app has joined Huawei to become a technology flashpoint, with Chinese officials and media rushing to defend it following Donald Trump’s threat of a US ban. The US president later gave Microsoft until 15 September to make an acquisition deal with TikTok’s parent company, ByteDance, and said the US Treasury should receive payment as part of the deal. As with his declaration on banning the app, he did not explain if, or how, this was possible. An editorial in the official state paper, China Daily, said China would not accept the “theft” of one of its technology companies, “and it has plenty of ways to respond if the administration carries out its planned smash and grab”. The US actions were driven by the profits in data, it said, and offered “an either-or choice of submission or mortal combat in the tech realm”. On Monday, a spokesman for China’s ministry of foreign affairs said China firmly opposed any US action against Chinese software companies over national security concerns. “The US generalises the concept of national security and, without any evidence, presumptions of guilt and threats against relevant companies,” said Wang Wenbin. “This violates the principles of market economy and exposes the hypocrisy and typical double standards of the US in maintaining fairness and freedom. It also violates the World Trade Organisation’s principles of openness, transparency and non-discrimination.” China’s ambassador to the UK, Liu Xiaoming, also accused the US of hypocrisy. “It is the US that has politicised economic issues and abused the concept of national security to pursue discriminatory and exclusive policies,” he said. Kai-Fu Lee, the former president of Google China, said the US treatment of TikTok was “unbelievable”. Lee said China set out clear rules for tech companies to comply with if they wanted to do business in the country, and Google had decided not to stay on that basis. He accused the US of giving no parameters for TikTok to work with, or providing any evidence for their national security claims “Google didn’t want to comply with Chinese laws &amp; regulations, so it quit,” said Lee, who added he had left the company prior to its exit from China. “Forced acquisition + only 45 days + intermediary fees are not comparable to Google. It is incredible,” he said. An editorial in China’s state-owned 21st Century Business Herald said forcing the sale would set a “dangerous precedent”. “For this transaction, the Chinese government may also consider reviewing whether the technology transfer in it violates Chinese laws and harms China’s national interests.” ByteDance has not confirmed any discussions with Microsoft, but an internal staff memo from founder Zhang Yiming addressed the speculation on Monday. Separately on Monday the company also said it was considering establishing TikTok’s headquarters outside the US. The reports prompted some backlash on Chinese social media, with some accusing the company of surrendering to the US, which was akin “to being anti-China”. “Choose wisely on selling to the United States or becoming an enemy at home,” wrote one user. Additional reporting by Pei Lin Wu Topics: China TikTok Asia Pacific news 译文： Tiktok之争： 科技争端加剧之下，中国谴责美国的破坏与劫掠行径外交部发言人指责美国虚伪，官方社论谴责在“殊死搏斗”中选择屈服的行为 作者：Helen Davidson英国时间 2020/8/4/ 星期二 7:18 中国官媒报道称，美国要让中国在科技领域内做出选择——“是屈服还是抗争？”。这两个敌对大国正在就拆分 TikTok 这一棘手问题上周旋。 在特朗普威胁要实行禁令后，这款广受欢迎的视频分享应用和先前的华为一样，成为科技领域的冲突中心，中国官员和媒体争相为其辩护。 之后，美国总统要求微软在9月15日之前与TikTok的母公司ByteDance达成收购协议，并表示，作为这场交易的助推者，美国财政部也应获得回报。至于他关于禁止该应用程序的声明，他没有解释这是否可行，或者如何可行。 中国官方报纸《中国日报》的一篇社论说，中国不会接受一家科技公司遭受“盗窃”，“如果（美国）政府有预谋地实施破坏和掠夺，中国有很多办法应对”。 报告称，美国的行为是受数据利润的驱动，并给中国了一个“在科技领域要么屈服要么殊死搏斗的选择”。 周一，中国外交部发言人表示，中国坚决反对美国出于国家安全考虑而对中国软件公司采取任何行动。王文彬表示：“美国滥用国家安全的概念，在没有任何证据的情况下，无端猜测相关公司违反法律或威胁国家安全。” “这违反了市场经济原则，暴露了美国在维护公平与自由方面的虚伪和典型双标。 这也违反了世界贸易组织的开放，透明和不歧视原则。 中国驻英国大使刘晓明也指责美国虚伪。 他说：“正是美国将经济问题政治化，滥用了国家安全的概念，奉行歧视性和排他性政策。” 谷歌中国前总裁李开复表示，美国对待TikTok的方式“令人难以置信”。 李表示，中国为科技公司在中国开展业务制定了明确的规则，这也是谷歌决定不在中国继续开展业务的原因。他指责美国没有告诉TikTok需要遵守怎样的规则，也没有为他们的国家安全主张提供任何证据。 李开复说，谷歌不想遵守中国的法律法规，所以退出了。李开复还说，他在谷歌退出中国之前就离开了该公司。强制收购+仅有45天期限+收取中介费用的行径不能与谷歌退出相提并论。这太不可思议了，他说。 中国国有报纸《21世纪经济报道》（21st Century Business Herald）的一篇社论说，强行收购将树立“危险先例”。 “对于这笔交易，中国政府还可以考虑审查其中的技术转让是否违反中国法律，是否损害中国的国家利益。” 字节跳动尚未证实与微软进行了任何讨论，但创始人张一鸣周一的一份内部员工信回应了这一猜测。 另外，该公司周一还表示，正在考虑在美国以外设立TikTok总部。 这些报道引发了中国社交媒体的强烈反对，有人指责该公司向美国投降，这类似于“反华”。 一位用户写道：“做出明智的选择：要么向美国出售，要么成为国内的公敌。”（这句应该有语病，但我是按英语原文翻译的，不知道是不是我理解错了。） Pei Lin Wu补充报道 主题： 中国 字节跳动 亚太 新闻 严格说来，字节跳动的遭遇算不得什么突发事件——之前华为问题时，所有人都明白华为之后必然是字节跳动。 华为和字节跳动，作为中国“走出去”最成功的民营企业，受到美国政府打压是必然的。但我也没想到特朗普政府这么“无赖”吧...（得是有多无赖才能明目张胆地收取“中介费”？） 之前有很多人说字节跳动会成为下一个互联网巨头，BAT中的B变成Byte dance（我也是这个想法）现在看来是过于乐观吧。 我也不想站在道德制高点上谴责张一鸣，他只是个商人，但我真的希望他能强硬一些，给国内一个惊喜。（现在看来不大可能啦）","categories":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"/tags/英语/"},{"name":"The Guardian","slug":"The-Guardian","permalink":"/tags/The-Guardian/"}],"keywords":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}]},{"title":"STL map随机读取效率测试","slug":"STL map的插入与随机读取效率测试","date":"2020-07-28T02:30:00.000Z","updated":"2021-02-08T04:48:04.599Z","comments":true,"path":"2020/07/28/STL map的插入与随机读取效率测试/","link":"","permalink":"/2020/07/28/STL map的插入与随机读取效率测试/","excerpt":"背景：map是STL中的重要关联容器，可以根据key值来进行有序插入、随机读取。 map的随机读取很特殊：可以通过中括号访问。 比如map&lt;int,int&gt;sample中有一个元素为pair&lt;4,6&gt;，则可以通过sample[4]的形式访问到这个元素","text":"背景：map是STL中的重要关联容器，可以根据key值来进行有序插入、随机读取。 map的随机读取很特殊：可以通过中括号访问。 比如map&lt;int,int&gt;sample中有一个元素为pair&lt;4,6&gt;，则可以通过sample[4]的形式访问到这个元素但由于map为用AVL树存储的关联容器，而不是顺序容器，它的随机读取效率应该只有O(logn),下面进行验证。 下列测试比较了以int和string类型作key值时，插入与随机读取效率。 测试代码： #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;string&gt; #include&lt;ctime&gt; #include&lt;iomanip&gt; using namespace std; const int length_of_str = 5;//字符串长度 map&lt;string,int&gt;StringMap; map&lt;int,int&gt;IntMap; void InsertString(string &amp;str) { StringMap.insert(pair&lt;string,int&gt;(str,1)); return; } void InsertInt(int num) { IntMap.insert(pair&lt;int,int&gt;(num,1)); return; } int main() { string base = &quot;hfauiehlkesadolaijeqpjioehfuoaiyeufhesufhuiesaueiry77861423yeyadhasd73y2ade43derduisadhwuduahdjsdkajhdygyegskfdjskfaugeyrkhdagydgeygyegf&quot;; string s[100];//存储100个随机字符串 int nums[100];//存储100个随机数 for(int i = 0; i &lt; 100; ++i) { s[i] = base.substr(i,length_of_str); nums[i] = (i*762921372)%1000; } clock_t StartTime, EndTime; StartTime = clock(); for(int i = 0; i &lt; 100; ++i) { for(int i = 0; i &lt; 100; ++i) { InsertString(s[i]); } } EndTime = clock(); cout &lt;&lt; &quot;string插入时间&quot; &lt;&lt; setprecision(3) &lt;&lt; setiosflags(ios::fixed)&lt;&lt;(double)EndTime - StartTime &lt;&lt; endl; StartTime = clock(); for(int i = 0; i &lt; 100; ++i) { for(int i = 0; i &lt; 100; ++i) { InsertInt(nums[i]); } } EndTime = clock(); cout &lt;&lt;&quot;int插入时间&quot;&lt;&lt; setprecision(3) &lt;&lt; setiosflags(ios::fixed)&lt;&lt;(double)EndTime - StartTime &lt;&lt; endl; StartTime = clock(); for(int i = 0; i &lt; 100; ++i) { for(int i = 0; i &lt; 100; ++i) { int j = StringMap[s[i]]; } } EndTime = clock(); cout &lt;&lt;&quot;map:string读取时间&quot;&lt;&lt; setprecision(3) &lt;&lt; setiosflags(ios::fixed)&lt;&lt;(double)EndTime - StartTime &lt;&lt; endl; StartTime = clock(); for(int i = 0; i &lt; 100; ++i) { for(int i = 0; i &lt; 100; ++i) { int j = IntMap[nums[i]]; } } EndTime = clock(); cout &lt;&lt;&quot;map:Int读取时间&quot;&lt;&lt; setprecision(3) &lt;&lt; setiosflags(ios::fixed)&lt;&lt;(double)EndTime - StartTime &lt;&lt; endl; StartTime = clock(); for(int i = 0; i &lt; 100; ++i) { for(int i = 0; i &lt; 100; ++i) { int j = nums[i]; } } EndTime = clock(); cout &lt;&lt;&quot;顺序存储:Int读取时间&quot;&lt;&lt; setprecision(3) &lt;&lt; setiosflags(ios::fixed)&lt;&lt;(double)EndTime - StartTime &lt;&lt; endl; return 0; } 程序运行结果： string插入时间72.000 int插入时间23.000 map:string读取时间30.000 map:Int读取时间12.000 顺序存储:Int读取时间0.000 可以发现，map的随机存取与插入的时间复杂度大致是在同一级复杂度（O(logn)），在使用map的下标访问功能时，应考虑操作的时间代价。","categories":[{"name":"C++","slug":"C","permalink":"/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"STL","slug":"STL","permalink":"/tags/STL/"}],"keywords":[{"name":"C++","slug":"C","permalink":"/categories/C/"}]},{"title":"?:条目运算符","slug":"？：条目运算符","date":"2020-07-26T03:40:24.000Z","updated":"2021-02-08T04:36:03.942Z","comments":true,"path":"2020/07/26/？：条目运算符/","link":"","permalink":"/2020/07/26/？：条目运算符/","excerpt":"参考自: www.runoob.com 格式：Exp1 ? Exp2 : Exp3;","text":"参考自: www.runoob.com 格式：Exp1 ? Exp2 : Exp3; 其中，Exp1、Exp2 和 Exp3 是表达式。请注意冒号的使用和位置。? : 表达式的值取决于 Exp1 的计算结果。如果 Exp1 为真，则计算 Exp2 的值，且 Exp2 的计算结果则为整个 ? : 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，且 Exp3 的计算结果则为整个 ? : 表达式的值。 ? 被称为三元运算符，因为它需要三个操作数，可以用来代替如下所示的 if-else 语句： if(condition){ var = X; }else{ var = Y; } 例如，请看下面这段代码： if(y &lt; 10){ var = 30; }else{ var = 40; } 上面的代码可以写成以下语句： var = (y &lt; 10) ? 30 : 40; 在这里，如果 y 小于 10，则 var 被赋值为 30，如果 y 不小于 10，则 var 被赋值为 40。请看下面的实例： #include &lt;iostream&gt; using namespace std; int main () { // 局部变量声明 int x, y = 10; x = (y &lt; 10) ? 30 : 40; cout &lt;&lt; &quot;value of x: &quot; &lt;&lt; x &lt;&lt; endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： value of x: 40; 注意点： ?: 表达式返回值是变量本身，而不是变量的副本。也就是说，被选择的变量不止可以返回一个值，也可以直接修改这个值 如以下代码： int a = 1, b = 2； ++((a &gt; b)? a : b); 执行以后，a = 1, b = 3;","categories":[{"name":"C++","slug":"C","permalink":"/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"C++","slug":"C","permalink":"/categories/C/"}]},{"title":"The Forbes 2020/7/18 特朗普使华为受重创，但这远不是结束","slug":"The Forbes 特朗普使华为受重创，但这远不是结束","date":"2020-07-21T12:40:24.000Z","updated":"2021-02-08T03:14:12.292Z","comments":true,"path":"2020/07/21/The Forbes 特朗普使华为受重创，但这远不是结束/","link":"","permalink":"/2020/07/21/The Forbes 特朗普使华为受重创，但这远不是结束/","excerpt":"Hawkish U.S. politicians come and go, this Chinese giant is playing a much longer game.美国的鹰派政客来来往往，而这个中国巨头正在玩一个更长的游戏。”","text":"Hawkish U.S. politicians come and go, this Chinese giant is playing a much longer game.美国的鹰派政客来来往往，而这个中国巨头正在玩一个更长的游戏。” 截止7月21日，本文在Forbes阅读量为37435人次 Yes, Trump Just Seriously Damaged Huawei—But This Isn’t Over YetContributor: Zak Doffman VCG VIA GETTY IMAGES We now have confirmation, if any was needed, that the U.K.’s decision to ban Huawei from its 5G network came as a direct result of pressure from U.S. President Trump and his security team. There was also the non-trivial issue of an about-turn in the advice from Britain’s spooks to its politicians—the risks with Huawei equipment could no longer be mitigated. This, again, was directly attributable to America’s campaign against the Chinese tech giant. On the surface, this may look like a victory for Washington, but it’s not that simple—Huawei is far from defeated. The clear implication in the U.K. is that the Huawei decision is all about politics and has little to do with security. The U.K. cyber team charged with defending the realm from the threats associated with Chinese equipment have only changed their view because, at America’s insistence, U.S. components inside Huawei equipment are being replaced by (likely) Chinese equivalents. A change in the political winds—there’s a U.S. election now just a few months away —and both the lobbying and the supply chain restrictions could easily fall away. This context behind the U.K.’s “materially” changed security report, that the change was fabricated by the U.S., is critical. Absent the latest sanctions, the U.K. advice would not have changed and the reason driving the U.K.’s reversal would not exist. The confirmation from leading chip supplier TSMC, that it will cease supplying Huawei in September per new U.S. rules, was also steeped in the implication that were those rules to soften or change, or were the company to successfully apply for a license to supply, than we’d be quickly back to normal. Even the structure of the U.K.’s newly announced reversal is all about the detail. The decision to bar purchases of 5G equipment from next January leaves a sizeable procurement window wide open, and is designed to restrict the acquisition of standalone 5G kit rather than LTE-to-5G upgrades. The long grace period (until 2027) before a rip and replace is mandatory, and the silence on existing 3G and 4G equipment already deployed, have left many options on the table. If a week is a long time in politics, seven years is a lifetime. Trump was quick to take credit for the U.K. decision, personalizing the victory, and it’s true that the president has campaigned long and hard to persuade his key defense and intelligence ally to toe the U.S. line. But Washington’s relationship with Beijing is starkly different to London’s. The U.S. can brush aside economic threats from China—neither can live without the other. A U.K. facing up to the harsh realities of a post-COVID Brexit is not in such a fortunate position. China issued further threats of “retaliation” in the wake of the Huawei decision. And that carries some weight in a country reliant on Chinese investments in infrastructure and technology, and with a huge install base of Huawei equipment. Huawei’s U.K. PR chief, Ed Brewster, stressed during a charged BBC Newsnight interview last week, that the company’s mission in the U.K. continues. R&D investments and the decision, announced post the 5G reversal, to open new flagship stores should tell you all you need to know about where Huawei stands on its U.K. future. “We know that millions of people here in the U.K. love our products,” the company said on announcing the £10 million (\\$12.5 million) investment. Hawkish U.S. politicians come and go, this Chinese giant is playing a much longer game. The group of U.K. politicians that has lobbied its government hard for tougher sanctions on Huawei knows there is a risk of further changes as this story runs through November’s U.S. election and whatever fallout we see from inquiries into the origins of coronavirus and Beijing’s alleged misinformation. There is also a much wider technology stand-off, one that has now dragged the TikTok into the mix. The U.S. is fast approaching a decision point as to just how far it wants to take this, before the implications on its own technology sector become much harder to sell back home. The headlines might be filled these days with news of new investments into India, but China is China, and it’s not going to be easily displaced as the world’s centre of tech manufacturing and the world’s hottest consumer market. Stepping back from this seminal week in the battle between the U.S. and Huawei, it’s hard not to think that the U.K. has left the door ajar for further twists and turns. The decision is solely based on U.S. lobbying and sanctions, and the U.K. does not want to be left holding the check should the U.S. change its tone. # 是的，特朗普刚刚重创了华为，但这远还没有结束... 作者：Zak Doffman 已经确认：在美国总统特朗普和他的安全团队压力下，英国决定会在时机恰当时禁止华为参与其5G网络建设。还有一个非常重要的问题，那就是英国的情报人员给政府提供的建议发生了180度转变，即华为设备的风险无法得到缓解。这又一次的胜利直接归因于美国对中国科技巨头的打击。从表面上看，这似乎是属于华盛顿的胜利，但真相没有那么简单——华为远未被击败。 英国方面的意思很清楚：针对华为的决定完全是出于政治，与安全几乎没有什么关系。英国负责保卫国家免受与中国设备相关的威胁的网络团突然改口否认华为，原因其实是在美国的坚持下，华为设备中的美国组件被中国的相似产品所替代（可能是）。然而，政治风向却会改变，美国大选近在眼前，政治游说和对实体管制清单都很容易消失。 更重要的是英国对安全报告做出“实质性”改变的背景——这一改变是由美国捏造的。假如没有最新的制裁措施，英国的态度就不会改变，推动英国逆转的原因将不复存在。领先的芯片供应商台积电（TSMC）确认将根据美国新规定于9月停止向华为供货，这也暗示着,倘若这些规定有丝毫松动，或者该公司成功申请了供应许可证，一切又会恢复常态。 甚至连英国最新宣布的反转都是关于具体的细节。 从明年1月起禁止购买5G设备的决定，留下了一个相当长的时间窗口用于采购。这项政策旨在限制购买完整的5G套件，但不包括从4G到5G的升级。设备的更新和更换需要足够长的时间，政策也必须要给足够长的缓冲期限（直到2027年）。已经部署好的3G和4G设备，则给了通信商很多选择空间。如果对于政治来说，七天是很长的一段时间，那么七年已经相当于一辈子了。 特朗普很快将赞扬了英国的决定，并认为这场胜利也是他的外交成果，诚然，总统已经做出长期而艰难的努力，以说服他的国防和情报盟友站到美国的战线上，但是华盛顿和北京的关系与北京和伦敦的关系截然不同。美国可以无视来自中国的经济威胁ーー两者都离不开对方。而英国没有那么幸运，在脱欧以及新冠病毒之后，英国正面对着严酷的现实。在英国做出对华为的决定之后，中国威胁会进行进一步的“报复”。对于一个依赖中国对基础设施和技术的进行投资，并且拥有庞大的华为设备安装基础的国家中，这个威胁具有一定的分量。 华为英国公关负责人埃德·布鲁斯特(Ed Brewster)上周在接受BBC新闻之夜(BBC Newsnight)采访时强调，该公司在英国的使命仍在继续。在5G问题的反转之后，华为宣布了研发投资并决定开设新旗舰店——关于华为在英国未来的立场，我想已经不言而喻了。该公司在宣布投资1000万英镑（折合1250万美元）时说：“我知道在英国有数百人喜爱我们的产品”。美国的鹰派政客来来往往，这个中国巨头正在玩一个更长的游戏。” 一直在努力游说政府对华为实施更严厉制裁的英国政界人士知道，事态有发生变化的危险。一方面11月即将进行美国大选，另一方面，我们在调查冠状病毒来源和以及北京所谓的虚假信息所导致的任何后果，都给未来埋下隐患。另外还有一场更广泛的技术对峙，这场对峙已经将字节跳动公司（TikTok）也拖入了泥潭。 这个问题（中美对峙）对美国国科技行业的影响使会使得美国的政策难以在国内继续推行，这迫使美国必须快速做出决定：在这个问题上美国究竟要走多远？ 这些天的头条新闻可能充斥着对印度的新投资，但中国就是中国，它不会轻易取代中国，成为世界科技制造业中心和世界上最热门的消费市场。 最后，我们再回头看看美国与华为战斗的这重要一周，我们很难不去想：英国已经为未来的混乱打开了半扇大门。这一决定完全基于美国的游说和制裁，如果美国变卦，英国不希望看到自己承担后果。 唠两句： 最近英国“反戈”，台积电断供，国人又把目光投向华为。 我找了找国外相关报道，结果充斥各个新闻门户的全是关于美国大选和新冠病毒，关于华为的只有几则简讯。大部分简讯其实是反华的，“义正言辞”地扯一些关于“国家安全”，“情报”之类的犊子。而长篇的文章很少，只看到这么一篇还算像样的。 中美对峙正影响到我们每一个人。 华为以及文中提到的字节跳动，是我不少学长的毕业去向。尤其是字节跳动，今年扩招4w员工让很多人意外，不少大四甚至大三学长已经拿到offer（我甚至怀疑字节跳动提供这么多岗位是在争取政府对它的支持）。而华为和字节跳动的未来是扑朔迷离的，这和中美关系息息相关。 中国的科技巨头们不大可能倒下，毕竟国内市场这么大，不至于被美国扼住喉咙，但是肯定会有波折，也许会裁员，也许会业绩下滑...中国能够对抗美国，但是对国内的公司（其实也包括美国一些公司），生存下来未必轻松。","categories":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"/tags/英语/"},{"name":"The Forbes","slug":"The-Forbes","permalink":"/tags/The-Forbes/"}],"keywords":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}]},{"title":"The Guardian 2020/7/18 被撕裂的美国","slug":"The Guardian 7月18日 被撕裂的美国","date":"2020-07-18T13:40:24.000Z","updated":"2021-02-08T03:14:25.346Z","comments":true,"path":"2020/07/18/The Guardian 7月18日 被撕裂的美国/","link":"","permalink":"/2020/07/18/The Guardian 7月18日 被撕裂的美国/","excerpt":"With flu season on the horizon and Donald Trump demanding that millions of students return to school in the fall – not to mention a presidential election quickly approaching – the country appears at risk of being torn apart.流感季节即将到来、大选临近、总统又要求学校秋季开学——美国正面临被撕裂的危险。","text":"With flu season on the horizon and Donald Trump demanding that millions of students return to school in the fall – not to mention a presidential election quickly approaching – the country appears at risk of being torn apart.流感季节即将到来、大选临近、总统又要求学校秋季开学——美国正面临被撕裂的危险。本文在卫报当天的阅读量在全站第2位，内容均为原文原图 The virus doesn’t care about excuses’:US faces terrifying autumn as Covid19 urgesThe breathing space afforded by lockdowns in the spring has been squandered, with new cases running at five times the rate ofthe whole of Europe. Things will only get worse, experts warn by Tom McCarthy in New YorkCoronavirus latest global updatesMain image: Composite: Guardian Design/Getty/ShutterstockSat 18 Jul 2020 06.00 BST In early June, the United States awoke from a months-long nightmare.Coronavirus had brutalized the north-east, with New York City alone recording more than 20,000 deaths, the bodies piling up in refrigerated trucks. Thousands sheltered at home. Rice, flour and toilet paper ran out. Millions of jobs disappeared. But then the national curve flattened, governors declared success and patrons returned to restaurants, bars and beaches. “We are winning the fight against the invisible enemy,” vicepresident Mike Pence wrote in a 16 June op-ed, titled, “There isn’t a coronavirus ‘second wave’.” Except, in truth, the nightmare was not over – the country was not awake – and a new wave of cases was gathering with terrifying force. As Pence was writing, the virus was spreading across the American south and interior, finding thousands of untouched communities and infecting millions of new bodies. Except for the precipitous drop in New York cases, the curve was not flat at all. It was surging, in line with epidemiological predictions. Now, four months into the pandemic, with test results delayed, contact tracing scarce， protective equipment dwindling and emergency rooms once again filling, the United States finds itself in a fight for its life: swamped by partisanship, mistrustful of science, engulfed in mask wars and led by a president whose ncompetence is rivaled only by his indifference to Americans’ suffering. With flu season on the horizon and Donald Trump demanding that millions of students return to school in the fall – not to mention a presidential election quickly approaching – the country appears at risk of being torn apart. “I feel like it’s March all over again,” said William Hanage, a professor of epidemiology at the Harvard TH Chan School of Public Health. “There is no way in which a large number of cases of disease, and indeed a large number of deaths, are going to be avoided.” The problem facing the United States is plain. New cases nationally are up a remarkable 50% over the last two weeks and the daily death toll is up 42% over the same period. Cases are on the rise in 40 out of 50 states, Washington DC and Puerto Rico. Last week America recorded more than 75,000 new cases daily – five times the rate of all Europe. “We are unfortunately seeing more higher daily case numbers than we’ve ever seen, even exceeding pre-lockdown times,” said Jennifer Nuzzo, an epidemiologist at the Johns Hopkins Center for Health Security. “The number of new cases that occur each day in the US are greater than we’ve yet experienced. So this is obviously a very worrisome direction that we’re headed in.” Donald Trump speaks to the media before boarding Marine One on 10 July to head to coronavirus-stricken Florida as he ramps up public appearances ahead of the election. Photograph: Shawn Thew/Bloomberg/Getty Images The mayor of Houston, Texas, proposed a “two-week shutdown” last week after cases in the state climbed by tens of thousands. The governor of California reclosed restaurants, churches and bars, while the governors of Louisiana, Alabama and Montana made mask-wearing in public compulsory.“Today I am sounding the alarm,” Governor Kate Brown said. “We are at risk of Covid-19 getting out of control in Oregon.” As dire as the current position seems, the months ahead look even worse. The country anticipates hundred of thousands of hospitalizations, if the annual averages hold, during the upcoming flu season. Those hospitalizations will further strain the capacity of overstretched clinics. But a flu outbreak could also hamper the country’s ability to fight coronavirus in other ways. Because the two viruses have similar symptoms – fever, chills, diarrhea, fatigue – mistaken diagnoses could delay care for some patients until it’s too late, and make outbreaks harder to catch, one of the country’s top health officials has warned. “I am worried,” Dr Robert Redfield, the director of the Centers for Disease Control (CDC), said last week. “I do think the fall and the winter of 2020 and 2021 are probably going to be one of the most difficult times that we have experienced in American public health because of … the co-occurrence of Covid and influenza.” Other factors will be in play. A precipitous reopening of schools in the fall, as demanded by Trump and the education secretary, Betsy DeVos, without safety measures recommended by the CDC, could create new superspreader events, with unknown consequences for children. “We would expect that to be throwing fuel on the fire,” said Hanage of blanket school reopenings. “So it’s going to be bad over the next month or so. You can pretty much expect it to be getting worse in the fall.” The list of aggravating circumstances goes on and on. A federal unemployment assistance program that gave each claimant an extra 600 a month is set to expire at the end of July. A new coronavirus relief package is being held up in Congress by Republicans’ accusations that states are wasting money, and their insistence that any new legislation include liability protections for businesses that reopen during the pandemic. Customers shop for fruit at a street vendor in the Corona neighborhood in Queens, New York, on 27 June. Photograph: Amir Hamja/Bloomberg/Getty Images Cable broadcasts and social media have been filled, meanwhile, with video clips of furious confrontations on sidewalks, in stores and streets over wearing facial masks. In Michigan, a sheriff’s deputy shot dead a man who had stabbed another man for challenging him about not wearing a mask at a convenience store. In Georgia, the Republican governor sued the Democratic mayor of Atlanta for issuing a city-wide mask mandate. The partisan divide on masks is slowly closing as the outbreaks intensify. The share of Republicans saying they wear masks whenever they leave home rose 10 points to 45% in the first two weeks of July, while 78% of Democrats reported doing so, according to an Axios-Ipsos poll. Another divide has proven tragically resilient. As hotspots have shifted south, the virus continues to affect Black and Latinx communities disproportionately. Members of those communities are three times as likely to become infected and twice as likely to die from the virus as white people, according to data from early July. The raging virus has prompted speculation in some corners that the only way out for the United States is through some kind of “herd immunity” achieved by simply giving up. But that grossly underestimates the human tragedy such a scenario would involve, epidemiologists say, in the form of tens of millions of new cases and unknown thousands of deaths. “I think that every single serology study that’s been done to date suggests that the vast majority of Americans have not yet been exposed to this virus,” Nuzzo said. “So we’re still very much in the early stages. “Which is good, that’s actually really good news. I don’t want to strive for herd immunity, because that means the vast majority of us will get sick and that will mean many, many more deaths. The point is to slow the spread as much as possible, protect ourselves as much as possible, until we have other tools.” But the ability of the US to take that basic step – to slow the spread, as dozens of other countries have done – is in perilous doubt. After half a year, the Trump administration has made no effort to establish a national protocol for testing, contact tracing and supported isolation – the same proven three-pronged strategy by which other countries control their outbreaks. Critics say that instead, Trump has dithered and denied as the national death toll climbed to almost 140,000. The Democratic presidential candidate, Joe Biden, who is hoping to unseat Trump in November, blasted the president for refusing until recently to wear a mask in public. “He wasted four months that Americans have been making sacrifices by stoking divisions and actively discouraging people from taking a very basic step to protect each other,” Biden said in a statement last weekend. A healthcare worker talks to a patient in the ER at Oakbend medical center in Richmond, Texas, on 15 July. Photograph: Mark Felix/AFP/Getty Images Meanwhile the White House has attacked Dr Anthony Fauci, the country’s foremost expert on infectious diseases whose refusal to lie to the public has enraged Trump, by publishing an oped signed by one of the president’s top aides titled “Anthony Fauci has been wrong about everything I have interacted with him on” and by releasing a file of opposition research to the Washington Post. Trump claimed the number of cases was a function of unusually robust testing, though experts said that positivity rates of 20% in multiple states suggested that the United States is testing too little – and that in any case closing one’s eyes to the problem by testing less would not make it go away. “We’ve done 45 million tests,” Trump said this week, padding the figure only slightly. “If we did half that number, you’d have half the cases, probably around that number. If we did another half of that, you’d have half the numbers. Everyone would be saying we’re doing well on cases.” Such statements by Trump have encouraged unfavorable comparisons of the US pandemic response with those in countries such as Italy, which recorded just 169 new cases on Monday after a horrific spring, and South Korea, which has kept cases in the low double-digits since April. The Senate majority leader, Mitch McConnell, walks to his office from the Senate floor on 13 May. Photograph: Shawn Thew/EPA But the United States could also look to many African countries for lessons in pandemic response, said Amanda McClelland, who runs a global epidemic prevention program at Resolve to Save Lives. “We’ve seen some good success in countries like Ghana, who have really focused on contact tracing, and being able to follow up superspreading events,” said McClelland. “We see Ethiopia: they kept their borders open for a lot longer than other countries, but they have really aggressive testing and active case-finding to make sure that they’re not missing cases. “I think what we’ve seen is that you need not just a strong health system but strong leadership and governance to be able to manage the outbreak, and we’ve seen countries that have all three do well.” Factory workers produce personal protective equipment for coronavirus frontline health workers at a factory commissioned by the government, in Accra, Ghana, on 17 April. The US pandemic response compares unfavorably with a number of African countries. Photograph: Nipah Dennis/AFP/Getty Images But in America, the large laboratories that process Covid-19 tests are unable to keep up with demand. Quest Diagnostics announced on Tuesday that its average turnaround time for test results was a minimum of seven days for most patients. “We want patients and healthcare providers to know that we will not be in a position to reduce our turnaround times as long as cases of Covid-19 continue to increase dramatically,” the lab said. “You can’t have unlimited lab capacity, and what we’ve done is allow, to some extent, cases to go beyond our capacity,” said McClelland. “We’re never going to be able to treat and track and trace uncontrolled transmission. This outbreak is just too infectious.” Public health experts emphasize that the United States does not have to accept as its fate a cascade of tens of millions of new cases, and tens of thousands of deaths, in the months ahead. Focused leadership and individual resolve could yet help the country follow in the footsteps of other nations that have successfully faced serious outbreaks – and brought them under control. But it is clear that the most vulnerable Americans, including the elderly and those with preexisting conditions, face grave danger. Republicans have argued in recent weeks that while cases in the US have soared, death rates are not climbing so quickly, because the new cases are disproportionately affecting younger adults. That is a false reassurance, health experts say, because deaths are a lagging indicator – cases necessarily rise before deaths do – and because large outbreaks among any demographic group speeds the virus’s ability to get inside nursing homes, care facilities and other places where residents are most vulnerable. “If we don’t do anything to stop the virus, it’s going to be very difficult to prevent it from getting to people who will die,” said Nuzzo. A United States flag flies at half-mast outside the Hammonton center for rehabilitation and healthcare in Hammonton, New Jersey, on 19 May. Photograph: Lucas Jackson/Reuters There is a question of whether the United States, for all its wealth and expertise – and its selfregard as an exceptional actor on the world stage – can summon the will to keep up the fight. People are tired of fighting the virus, and of fighting each other. “I think unfortunately people are emotionally exhausted from having to think about and worry about this virus,” said Nuzzo. “They feel like they’ve already sacrificed a lot. So the worry that I have is, what willingness is there left, to do what it takes?” It is as if the country is “treading water in the middle of the ocean”, Hanage said. “People tend to be shuffling very quickly between denial and fatalism,” he said. “That’s really not helpful. There are a number of things that can be done. “What I would hope is that this marks a point when the United States finally wakes up and realizes that this is a pandemic and starts taking it seriously. “Folks tend to look at what has happened elsewhere and then they make up some kind of magical reason why it’s not going to happen to them. “People keep making these excuses, and the virus doesn’t care about the excuses. The virus just keeps going. If you give it the opportunity, it will take it.” America faces an epic choice …… in the coming months, and the results will define the country for a generation. These are perilous times. Over the last three years, much of what the Guardian holds dear has been threatened – democracy, civility, truth. The country is at a crossroads. Science is in a battle with conjecture and instinct to determine policy in the middle of a pandemic. At the same time, the US is reckoning with centuries of racial injustice – as the White House stokes division along racial lines. At a time like this, an independent news organisation that fights for truth and holds power to account is not just optional. It is essential. 译文：病毒才不会听你的借口： Covid使美国面临可怕的秋季春季的封锁所争取到的机会已经被浪费，病例的增长速度是整个欧洲的五倍。专家警告说，情况只会变得更糟… 作者：纽约记者Tom McCarthy栏目：病毒最新讯息主要图片来源 Guardian Design/Getty/Shutterstock时间：英国时间2020年7月18日 星期六 6：00 6月初，美国从长达数月的噩梦中醒来。 冠状病毒使东北部遭受重创，仅纽约市就有2万多人死亡，冷藏卡车中尸体堆积如山。 数千人躲在家里，用光了大米，面粉和纸巾。 数以百万计的岗位消失了。 但随后，全国病例增长曲线变得平坦，州长们宣布了胜利的消息，人们又回到了餐馆、酒吧和海滩。 副总统迈克·彭斯(Mike Pence)在6月16日发表的题为“不会出现‘第二波’冠状病毒”的专栏文章中写道：“我们正在赢得这场与看不见的敌人的战斗。” 但是，事实上，噩梦还没有结束——这个国家还没有醒来——新一波的病例正以可怕的力量涌现。 就在彭斯写这篇文章的时候，病毒正在美国南部和内陆蔓延，它找到了数千个之前未受影响的社区，并感染了数百万新的宿主。 除了纽约的病例急剧下降外，这条曲线根本不是平坦的。 与流行病学预测一致，感染者的数量正在激增。 现在，病毒已经肆虐四个月了，检测排查被推迟、对接触者的追踪几乎没有、防护设备越来越少、急诊室又一次挤满了人，美国发现自己陷入了一场关乎生存的战斗：既有党派之争，又有对科学的不信任，并身陷口罩战争（即：戴口罩还是不戴口罩在美国引起的政治/社会冲突，有点儿滑稽）的泥潭，而领导这场战斗的总统，既无能又对美国人们毫不关心。 流感季节即将到来、特朗普要求数百万学生在秋季重返校园——再加上总统选举的迅速临近——这个国家似乎面临被撕裂的风险。 哈佛大学公共卫生学院流行病学教授William Hanage说，“三月的情况又要重现。” “我们没有办法避免大量的病例，甚至是大量的死亡。” 美国面临的问题是显而易见的。在过去的两周里，全国的新病例上升了50%，而同时每天的死亡人数上升了42%。在50个州中的40个州，华盛顿特区和波多黎各的病例呈上升趋势。上周，美国每天记录到75000多个新病例，是整个欧洲病例增长速度的五倍。 约翰 · 霍普金斯健康安全中心(Johns Hopkins Center for Health Security)的流行病学家珍妮弗 · 努佐(Jennifer Nuzzo)说，“不幸的是，我们每天看到的病例数量比以往任何时候都多，甚至超过了封锁前。“美国每天的新病例数量正在刷新之前的记录。因此，我们显然正朝着一个非常令人担忧的方向前进。 (图片:7月10日，唐纳德·特朗普登上“海军一号”，前往遭受冠状病毒袭击的佛罗里达州，在大选前增加在公众的露面，在此之前他接受了媒体采访。图片来源：Shawn Thew/彭博社/盖蒂图像） 上周，得克萨斯州休斯敦市长提议“一切活动中止两周” ，此前该州的病例增加了数万例。加利福尼亚州州长重新关闭了餐厅、教堂和酒吧，而路易斯安那州、阿拉巴马州和蒙大拿州的州长则强制要求在公共场合戴口罩。 “今天我敲响警钟，”州长 Kate Brown 说，“我们正面临着新冠肺炎在俄勒冈州失控的危险。” 尽管目前的形势看起来很可怕，但未来几个月的情况或许更糟。 该国预计，在即将到来的流感季节，按照往年的平均水平，将有数十万人住院，这些人的住院将使本就超负荷运转的诊所更加不堪重负。 并且流感的爆发也会以其他方式阻碍该国抗击新冠病毒。该国一位高级卫生官员警告说，由于这两种病毒有相似的症状——发烧、发冷、腹泻、疲劳——错误的诊断可能会延误对一些病人的治疗，直到错过最佳治疗时期，并使新疫情的爆发更难被发现。 “我很担心，”疾病控制中心(CDC)Robert Redfield博士上周说。 “我认为2020年和2021年的秋天和冬天可能会是我们在美国公共卫生领域经历的最艰难的时期之一，因为… 冠状病毒和流感并存。” 其他因素也将发挥作用。 在没有采取疾控中心建议的安全措施的情况下，特朗普和教育部长贸然要求学校在秋季开学。这可能会引发新的超级传播事件，给孩子们带来未知的后果。 “我们预计这是火上浇油，” Hanage在谈到全日制学校重新开学时说,“所以下个月左右的情况会很糟糕。 并且几乎可以肯定，秋季会更糟糕。” 形势急转直下。 一项联邦失业援助计划将在7月底到期，该计划每月为每名索赔人补助600美元。 共和党人指责各州在浪费资金，并坚持要求任何新的立法都包括对在大流行期间重新营业的企业的责任保护，这是国会提出的一项新的冠状病毒救助方案。 图片：6月27日，在纽约皇后区科罗纳社区，顾客在街头小贩处选购水果 图片来源：Amir Hamja/彭博社/盖蒂图片社 与此同时，在人行道上、商店和街道上因戴不戴口罩而引起了激烈对抗，这类视频充斥于有线广播和社交媒体上。在密歇根州，一名警长的副手开枪打死了一名男子，该男子刺伤了另一名男子，起因是他因为不戴口罩而被这名被刺伤的男子责备。 在佐治亚州，共和党州长起诉亚特兰大民主市长，理由是他发布了在全市范围内佩戴口罩的命令。 随着疫情的加剧，党派在口罩问题上的分歧正在慢慢弥合。根据Axios-Ipsos的一项民意调查，在7月的前两周，共和党人说他们每次出门都戴口罩的比例上升了10个百分点，达到45%，而民主党人为78%。 另一个分歧在悲剧性地在现实中重演。 随着感染中心向南转移，该病毒继续不成比例地影响到黑人和拉丁裔社区。 根据7月初的数据，这些社区的成员被感染的几率是白人的三倍，死亡率是白人的两倍。 肆虐的病毒在一些角落引发了人们的猜测：美国唯一的出路就是通过简单的放弃来实现某种“群体免疫”。但流行病学家说，这严重低估了这种情况将导致的人类悲剧，即数以千万计的新病例和不可估计的死亡人数。 Nuzzo说：“我认为迄今为止进行的每项血清学研究都表明，绝大多数美国人尚未接触过这种病毒。” “因此，我们仍处于开始阶段。 “这很好，这实际上真的是个好消息。 我不想争取群体免疫力，因为这意味着我们中的绝大多数人会生病，这意味着会有更多的人死亡。 关键是要在找到新的手段前，尽可能地减缓扩散，尽可能地保护自己。” 但美国是否有能力采取基本措施，如数十个其他国家所做的那样，减缓扩散，这一点令人怀疑。疫情已经扩散半年，特朗普政府没有努力建立任何一项用于检测新病例、接触者追踪和支持隔离的政策——这套“三管齐下”的措施在其他国家已经被证明行之有效。 批评者说，随着全国死亡人数攀升至近14万人，特朗普不仅没有采取这些措施，并且犹豫不决甚至予以否认。民主党总统候选人Joe Biden希望在11月让特朗普下台，他抨击总统直到最近才拒绝在公共场合戴口罩。 拜登在上周末的一份声明中说：“他浪费了四个月的时间，一直在煽动分裂和积极劝阻人们采取基本的自我保护手段，这造成了人民不必要的牺牲” 图片：7月15日，在德克萨斯州里士满的奥克本德医疗中心，一名医护人员在急诊室与一名患者交谈。图片来源：Mark Felix/法新社/盖蒂图片社 与此同时，白宫抨击了美国最重要的传染病专家安东尼·福奇(Anthony Fuci)博士。原因是他拒绝对公众撒谎激怒了特朗普。他之前发表了一篇由总统的一名高级助手签名的专栏文章，题为“安东尼·福奇在我与他互动的一切问题上都是错误的”，并向华盛顿邮报公布了一份反对党的研究文件。 特朗普声称，病例数量庞大是因为美国做了强有力的检测，尽管专家表示，多个州20%的阳性率表明美国检测太少——无论如何，通过减少检测而对问题视而不见并不能让问题消失。 “我们已经做了4500万次测试，”特朗普本周说，这个数字仅有略微的夸张。 “如果我们做这个数字的一半，病例就会减少一半，大约就是这个数字。 如果我们再做一半，你就有一半的数字。 每个人都会说我们在控制病例上做得很好。“ 特朗普的这种言论助长了社会将美国的应对措施与其他国家的对比。在经历了一个可怕的春季之后，意大利周一仅出现169例新病例。而韩国，自4月份以来病例数一直维持在两位数。 （图片：5月13日，参议院多数党领袖米奇·麦康奈尔(Mitch McConnell)从参议院走到他的办公室。图片来源：Shawn Thew/EPA） 但Amanda McClelland说，美国也可以向许多非洲国家学习应对大流行的经验教训。McClelland负责一个全球流行病预防项目，名为Resolve To Save Life。 “在加纳这样的国家，我们已经看到了不错的成功，这些国家非常专注于联系追踪，并且能够跟进超级传播事件。” McClelland说，“我们看到埃塞俄比亚：他们的边境开放时间比其他国家长了很多，但他们确实积极地检测、主动地寻找病例，以确保不会遗漏病例。” “我认为我们看到的情况是，你不仅需要强大的卫生系统，还需要强有力的领导和治理，才能控制疫情，我们已经看到这三个国家都做得很好。” （图片：4月17日，在加纳阿克拉政府委托的一家工厂里，工厂工人为冠状病毒前线卫生工作者生产个人防护设备。 与许多非洲国家相比，美国的大流行应对措施并不让人满意。 图片来源Nipah Dennis /法新社/盖蒂图片社） 但在美国，处理新冠肺炎检测的大型实验室跟不上需求。 Quest Diagnostics周二宣布，对于大多数患者来说，得到测试结果的平均周期至少为7天。 该实验室表示：“我们希望患者和医疗服务提供者知道，只要新冠肺炎的病例继续大幅增加，我们就无法缩短检测周期。” “你不可能拥有无限的实验室容量，我们所做的就是在某种程度上允许病例超出我们的能力。” McClelland说，“我们永远无法追踪和控制失控的传播，这次爆发的传染性太强了。” 公共卫生专家强调，在接下来的几个月中，美国不必认为数千万的新病例和数千人的死亡是已经注定的。 专注的领导力量和个人决心仍可帮助该国效仿成功应对严重疫情的其他国家，并使疫情受到控制。 但很明显，最脆弱的美国人，包括老年人和有既往疾病的人，面临着严重的危险。 共和党人最近几周辩称，尽管美国的病例激增，但死亡率并没有上升得那么快，因为新病例对年轻人的影响不成比例。 卫生专家表示，共和党人的保证是错误的，因为死亡率是一个滞后指标——病例必然先于死亡率上升——还因为任何大规模疫情爆发都会加速病毒进入疗养院、护理机构和其他居民最易感染的地方的能力。 Nuzzo说：“如果我们不采取任何措施来阻止这种病毒，将很难阻止它传播给将要死亡的人。” （图5月19日，在新泽西州哈蒙顿的哈蒙顿康复和医疗中心外，一面美国国旗降半旗。图片来源: Lucas jackson/路透社） 有一个问题是，尽管美国拥有财富和专业知识，而且自诩为世界舞台上的杰出角色，但它是否能够鼓起继续战斗的勇气？人们厌倦了与病毒作斗争，也厌倦了相互斗争。 “我认为不幸的是，人们已经因为不得不思考和担心这种病毒而精疲力竭，” Nuzzo 说,“他们觉得自己已经牺牲了很多。因此，我担心的是，他们还有什么意愿去做需要做的事情呢? ” Hanage说，这个国家仿佛正在“大洋中央涉水”。 “人们往往在肯定和否定宿命之间摇摆不定，”他说， “这真的没有什么用，有很多事情是可以做的。” “我希望这标志着美国终于醒来，意识到这是一场流行病，并开始认真对待它。” 人们倾向于看看其他地方发生了什么，然后他们会编出某种神奇的理由，来说明为什么不会发生在他们身上。 美国面临史诗般的选择……在接下来的几个月里，选举结果将定义这个国家的一代人。 这是一个危险的时代， 在过去的三年里，“卫报”珍视的许多东西都受到了威胁——民主、文明、真理。 这个国家正处于十字路口。 科学正在与猜想和本能作斗争，以便在大流行期间决定政策。与此同时，美国正在重新考虑几个世纪以来的种族歧视，因为白宫加剧了种族分歧。在这样的时候，一个为真理而战并拥有问责权的独立新闻机构不仅是可选的,更是必不可少的。","categories":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"/tags/英语/"},{"name":"The Guardian","slug":"The-Guardian","permalink":"/tags/The-Guardian/"}],"keywords":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}]},{"title":"音乐 • Down • 杂想","slug":"Music-Down","date":"2020-07-14T13:55:24.000Z","updated":"2021-02-07T03:27:12.377Z","comments":true,"path":"2020/07/14/Music-Down/","link":"","permalink":"/2020/07/14/Music-Down/","excerpt":"I’m not ready to let go我还没有准备好放手Cause then I’d never know因为我永远无法得知What I could be missing我会错过些什么","text":"I’m not ready to let go我还没有准备好放手Cause then I’d never know因为我永远无法得知What I could be missing我会错过些什么 But I’m missing way too much但是我已经错过太多太多太多So when do I give up所以当我真正要放弃的时候What I’ve been wishing for我还在渴望什么？ I shot for the sky我努力飞向天空I’m stuck on the ground却被困在地上So why do I try所以我为什么还在挣扎I know I’m gonna fall down我知道我即将沉沦I thought I could fly我以为我能够飞翔So why did I drown所以我为什么还要争取Never know why我永远都不知道为什么It’s coming down, down, down我一直都在坠落、坠落、坠落 几天前的某次班会，几个快毕业的学长说：想好自己要干什么，好钢要用到刀刃上。没能让我对未来思考得更清楚，反而搞得我心里很乱。 核心问题是要不要考研：考研与直接工作走的是两条不太相似的路：一条偏理论，一条偏实践。尽管两者都很重要，但是总要有一个权衡，知识确实没有高低，但是在不同的场合，知识会发挥不同的作用。 本来，所有的任课老师都告诉我们：一定要读研，最好争取保研。这条路确实没有问题。读研做的确实是更有知识深度的工作，但是“有知识深度”与“有创造力”未必是一回事，甚至是毫不相干的事情。 并且，直接工作才不是停止学习——工作中的学习会更多。 或许两条路没什么区别。但我还有另外的因素吧：比如我有没有魄力进入职场呢？读研或许能给我几年缓冲期。比如——家里人都是希望我读研的，部分人甚至让我读博…（哦我是山东人） 有人教我“有的放矢”，有人教我“好钢用在刀刃上”可是，我真的只能不停选择，不停犯错，才能找到一条路吧。 *写于7月14日夜*","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"音乐","slug":"音乐","permalink":"/tags/音乐/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"BBC news 2020/7/12 国安法颁布 离开的香港人","slug":"BBC news 7月12日 国安法颁布 离开的香港人","date":"2020-07-12T13:55:24.000Z","updated":"2021-02-08T02:06:18.510Z","comments":true,"path":"2020/07/12/BBC news 7月12日 国安法颁布 离开的香港人/","link":"","permalink":"/2020/07/12/BBC news 7月12日 国安法颁布 离开的香港人/","excerpt":"The UK now wants to offer BNO passport holders citizenship rights after six years of stay, arguing that China has breached the Sino-British Joint Declaration by enacting the national security law, which violates the city’s high degree of autonomy and infringes the civil liberties of Hong Kong residents.英国现在希望给予英国护照持有者在居留六年后的公民权利，解释称香港国安法违反了“中英联合声明”，破坏了城市的高度自治，侵犯了香港公民自由。","text":"The UK now wants to offer BNO passport holders citizenship rights after six years of stay, arguing that China has breached the Sino-British Joint Declaration by enacting the national security law, which violates the city’s high degree of autonomy and infringes the civil liberties of Hong Kong residents.英国现在希望给予英国护照持有者在居留六年后的公民权利，解释称香港国安法违反了“中英联合声明”，破坏了城市的高度自治，侵犯了香港公民自由。 本文在BBC news 当天的阅读量排在第 5位，内容均为原文原图。仅用于深入了解事件，西方与国内的价值观不同，请时刻保持理性,“人权”和“自由”绝不是干涉中国内政的正当理由 图片在手机页面经常不能加载，推荐移步PC端 Hong Kong security law: Why we are taking our BNOs and leavingBy Grace Tsoi BBC News, Hong Kong12 July 2020 &nbsp;Since China imposed a draconian national security law on Hong Kong, a lot of dinner party chatter in this protest-minded city has been about personal exit strategies. For up to three million Hongkongers, the exit could come in the form of a British National (Overseas) passport. Will they really leave - and what of those left behind? Michael and Serena have decided to leave Hong Kong for good and settle in the UK, a country they have never set foot in.The couple have British National (Overseas) - or BNO - passports, which were issued to Hong Kong residents that registered before the city was handed back to China on July 1997.Essentially a travel document with rights for some consular assistance, its usefulness seemed limited to many for anything but easier access to the UK and European travel. Some people went for it anyway. Why not, went the thinking for many Hongkongers. Michael and Serena are the embodiment of the comfortable prosperity common in Hong Kong: well-travelled with a 13-year-old daughter, they are both middle managers in a bank and bought a flat many years ago. It is a lot to give up. They say that Hong Kong has become unrecognisable in its handling of the months-long protests triggered by a bill which proposed to allow extradition to mainland China. What the couple saw was a government which did not listen to the people, and police force that showed little restraint.Their daughter has been deeply affected by the protests, even though the family did not take part because the couple work at a Chinese bank, where an employee was fired for protesting.“She has been very angry and upset. She kept asking why the authorities could treat us like that?” Serena said, adding that their daughter had told them she wanted to study abroad.The controversial national security law, which took effect last week, was the last straw.“The articles of the national security law are outrageous,” said Michael. Serena said she did not believe Beijing’s claims that the claim that law would only target “a tiny number of people”. The UK now wants to offer BNO passport holders citizenship rights after six years of stay, arguing that China has breached the Sino-British Joint Declaration by enacting the national security law, which violates the city’s high degree of autonomy and infringes the civil liberties of Hong Kong residents.Michael and Serena’s original plan was to only send their daughter to study abroad, but now moving to the UK as a family has become their first choice. Last November, they renewed their long-expired BNO passports, thinking that it could become useful - a hedge against an uncertain future.“I thought the UK would only offer citizenship to BNO passport holders as a last resort. I didn’t think it would happen so soon, but all of a sudden great changes are happening,” Michael said.In the week since China announced the new security law, the story of Michael and Serena has become more common. The people without BNO passports BNO passports were issued to people who registered before the former British colony was handed back to China Currently, there are about 350,000 BNO passport holders in Hong Kong, and the UK government estimates that there are about 2.9 million BNOs in total.Hong Kong residents born after the 1997 handover are not eligible for the BNO passport - and those who did not apply for one before the handover are not allowed to do so now.Helen was born in 1997 before the handover, but her parents did not apply for a BNO passport for her because she was a baby.“I am not sure if I want to go. But this is my right. Compared to the UK, I like Hong Kong more. But I should have had a BNO passport,” she said, admitting that she blamed her parents a little for not applying for one for her back then. About 350,000 Hong Kong residents are BNO passport holders as of February It is difficult to gauge the number of Hong Kong residents who will take up the UK's offer at this moment - but interest is running high, especially after the UK's announcement on July 1. On that day, Mr Raab told the House of Commons: \"We will not look the other way on Hong Kong, and we will not duck our historic responsibilities to its people.\" Ben Yu, who works for an immigration consultancy in the UK, said: \"My Hong Kong-based colleague receives 30 to 40 messages on Facebook every day. His WhatsApp has received hundreds of messages asking about moving to the UK by all routes, including BNOs and other visas. The messages come in 24/7 non-stop since then.\" The number of BNO renewals appears to be driven by political upheavals in Hong Kong. In 2018, about 170,000 BNO passports were in circulation. The next year, the number jumped to more than 310,000. During the colonial days, Hong Kong was always described as a borrowed place on borrowed time - and it is no stranger to waves of emigration. Between 1984 and 1997, between about 20,000 and 66,000 people left the city every year. The imminent wave of emigration will also likely look different to those in the past. \"A lot of them returned to Hong Kong either before 1997 or after 1997, when they had seized their safety outlets when they had got their foreign passports, when they saw that the political nightmare had not occurred as predicted,\" said Professor Ming Sing, who teaches politics at the Hong Kong University of Science and Technology. \"For the current wave, should it happen, I guess we will see a higher proportion of them is going to be a one-way ticket，\" he said. \"A lot of them see that the legislation of the national security law which has been imposed from the top is not only draconian in nature, but it also reflects Beijing reneging on its promise. Not only its failure to protect Hong Kong's freedoms under the Joint Declaration and under the Basic Law,\" he said, adding that he thinks more young people, many of them are protesters, will exit Hong Kong. ## What comes next? In the city of 7.5 million, about 800,000 people have British, Australian, Canadian, or American passports - including expats. Beijing has expressed anger over the UK's plan to offer citizenship to BNO passport holders in Hong Kong. China's Ambassador to the UK Liu Xiaoming said on Monday the move constitutes **\"gross interference in China's internal affairs\"** \"No one should underestimate the firm determination of China to safeguard its sovereignty, security and development interests,\" he said. The Chinese Embassy also said in a statement all \"Chinese compatriots residing in Hong Kong are Chinese nationals\". In an earlier interview with ITV, Mr Raab said there is little the UK could do if China doesn't allow Hong Kong residents to come to the UK. \"It is hard to predict what consequences Beijing has in mind. Probably more diplomatic ones in the form of a counter-measure, which does not necessarily need to be in the same form but should not be disproportionate,\" said Simon Young, a legal scholar at the University of Hong Kong. Benedict Rogers, co-founder and chair of advocacy group Hong Kong Watch, described the BNO offer as \"generous, courageous and welcome\". (video: Hong Kongers with British passports are divided over whether to leave the country) But the rescue element should be a last resort, Mr Rogers said. \"We should be working to ensure the conditions are met whereby HongKongers can continue their way of life, with the freedoms they were promised, without having to flee their homes. But the reality is that now, for some, it is already too late and they will need a place of sanctuary.\" Michael and Serena are making preparations for a new life in the UK, but they did not succeed at convincing their older son, who is turning 18 soon, to leave with them. He will live with his grandparents after the rest of the family has moved. \"My son says he doesn't want to leave Hong Kong, because he thinks Hong Kong belongs to him,\" Serena said. *Some names have been changed.* *----end---* 香港国安法：我们为何拿着英国护照离开自中国对香港实施了最严格的国安法以来，在这座充满抗议意识的城市，讨论退出香港的策略变成了市民晚宴聊天上的重要话题。对于至多三百万香港人来说，凭借英国国际护照离开或许是一种选择，但他们真的能离开吗？那些留下来的人又将面对什么呢？ Michael与Serena两人已决定离开香港定居英国，在那个从未涉足的国家度过余生。（leave …for good 意为：永久离开）这对夫妇拥有英国海外国民身份——或者说拥有BNO护照。在1997年中国政府收回香港前，英国将这种护照发予当时的香港居民。从本质上说，这（BNO）是一份具有领事协助权的旅行证件，其作用似乎仅限于更容易进入英国以及更方便欧洲旅行。 无论如何，有些人确实凭借它去了英国，为什么不借助它呢？许多香港人开始思考了。（这段俺翻译的很难受，仅供参考）迈克尔Michael和塞雷娜Serena是香港辉煌的体现：他们都是银行的中层管理人员，很多年前买了一处公寓，并带着一个13岁的女儿四处旅行。 离开香港，他们要放弃很多。他们说，香港在处理长达数月的抗议活动中已经变得面目全非。这场抗议活动源自于一向法律提案，该法案允许将香港居民引渡到中国大陆。 夫妇们看到的是一个不听人民意见的政府，而警察部队做事几乎没有克制。他们的女儿深受抗议活动的影响，尽管其他家庭成员没有参加。因为这对夫妇在一家中资银行工作，那里的一名员工因抗议而被解雇。“她一直非常生气和沮丧。她​​一直在问，当局为什么可以这样对待我们？”Serena说，她还补充说，他们的女儿已经告诉他们她想出国学习。上周生效的、备受争议的国家安全法是压死骆驼的最后一根稻草。“国家安全法的条款非常过分，”Michael说。 Serena说她没有相信大陆政府的说法，即法律只会针对“极少数人”。英国现在希望给予英国护照持有者在居留六年后的公民权利，解释称香港国安法违反了“中英联合声明”，破坏了城市的高度自治，侵犯了香港公民自由。Michael和Serena原本的计划是只送女儿出国学习，但现在一家人搬到英国已成为他们的首选。 去年11月，他们续签了长期过期的BNO护照，认为它对不确定性的未来可能会有用。“我原以为英国只会在万不得已的情况下向英国护照持有人提供公民身份。我没有预料到情况会变化得这么快。”Michael说。 那些没有英国公民护照的人（图片）（图片标题：BNO护照当时发给了英国在香港殖民时期的香港居民）目前，香港约有35万人持有BNO护照，而英国政府估计，BNO护照的总数约为290万。（看不太明白，不过中国统计的数据是：约300万香港人有BNO护照，而香港总人口约750万）在1997年移交后出生的香港居民没有资格获得BNO护照,那些在移交之前没有申请的人现在也不能再申请。海伦在香港主权移交前于1997年出生，但她的父母没有为她申请BNO护照，因为她还是婴儿。“我不确定我是否想去，但我有选择的权利。与英国相比，我更喜欢香港，但我本应该拥有BNO护照。”她说，并承认自己对父母当时没有为她申请有些指责。很难估计有多少香港居民会在这个时候接受英国的提议。但香港人的兴趣正在高涨，尤其是在英国7月1日宣布这一消息后。当天，Raab先生告诉下议院：“我们不会抛弃香港，我们不会逃避对人民的历史责任”。在英国一家移民咨询公司工作的Ben Yu说:“我的总部在香港，同事每天在Facebook上收到30到40条信息。他的WhatsApp已收到数百条消息询问有关通过所有路线（包括BNO和其他路线）前往英国的方式。 从那时起，他们的消息提醒几乎是每天24小时都在响。续签BNO的数量似乎是由香港的政治动荡推动的。 在2018年，市面上流通的英国国民(海外)护照约有17万本。 第二年，这一数字忽然猛增到超过31万本，在殖民地时代，香港总是被形容为：在借来的时间上的借来的地方。它对一波又一波的移民并不陌生。 在1984年到1997年之间，每年大约有两万到六万六千人离开这座城市。即将到来的移民潮也可能与过去不同。香港科技大学(Hong Kong University of Science and Technology)政治学教授明星(Ming Sing)说，“他们中的很多人在1997年之前或1997年之后回到了香港，当时他们拿到外国护照后，他们发现政治噩梦并没有如预期的那般发生，便关闭了预留的‘安全出口’。”。他表示: “就目前的浪潮而言，如果发生这种情况，更高比例的人将成为单程票。”。“他们中的很多人看到，由高层强加的《国家安全法》未能在《联合声明》和《基本法》下保护香港的自由，不仅性质严厉，而且反映了大陆政府背弃承诺。他还认为，更多的年轻人，其中许多是抗议者，将退出香港。 那么，接下来会发生什么？在这座拥有750万人口的城市，大约有80万人持有英国、澳大利亚、加拿大或美国护照-包括外籍人士。北京对英国向香港的BNO护照持有人提供公民身份的计划表示愤怒。 中国驻英国大使刘晓明周一表示，此举构成“对中国内政的严重干涉”。他说：“任何人都不应低估中国维护其主权，安全与发展利益的坚定决心。”中国大使馆还在一份声明中表示，“所有居住在香港的中国同胞都是中国公民”。拉伯在接受ITV采访时说，如果中国不允许香港居民来英国，英国将无能为力。 “很难预言北京将带来什么后果。 很可能采取的外交上的反击手段，不一定采取相同的形式，但也不应不相称。”香港大学法律学者西蒙·杨说。“香港观察”(Hong Kong Watch)的联合创始人兼主席本尼迪克特•罗杰斯(Benedict Rogers)形容 BNO 的提议是“慷慨、勇敢和欢迎的”。但罗杰斯表示，救援措施应该是最后的手段。“我们应该努力创造条件来使香港人能够继续他们的生活方式，享有承诺的自由，而不必逃离家园。但现实是，对一些人来说，现在已经太晚了，他们需要一个避难所。”迈克尔和塞雷纳正在为英国的新生活做准备，但他们未能说服即将年满18岁的大儿子与他们一起离开。 家庭其他成员搬迁后，他将与祖父母同住。瑟琳娜说：“我儿子说他不想离开香港，因为他认为香港属于他。” *文中所用部分名字为化名*","categories":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"/tags/英语/"},{"name":"BBC新闻","slug":"BBC新闻","permalink":"/tags/BBC新闻/"}],"keywords":[{"name":"英语","slug":"英语","permalink":"/categories/英语/"}]},{"title":"洛谷P4447 [AHOI2018初中组] 分组","slug":"洛谷P4447 [AHOI2018初中组]分组","date":"2020-07-12T11:11:00.000Z","updated":"2021-02-08T04:37:34.680Z","comments":true,"path":"2020/07/12/洛谷P4447 [AHOI2018初中组]分组/","link":"","permalink":"/2020/07/12/洛谷P4447 [AHOI2018初中组]分组/","excerpt":"题目描述：小可可的学校信息组总共有n 个队员，每个人都有一个实力值a[i]。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的n 个队员分成若干个小组去参加这场比赛。这是道类似玩斗地主的题","text":"题目描述：小可可的学校信息组总共有n 个队员，每个人都有一个实力值a[i]。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的n 个队员分成若干个小组去参加这场比赛。这是道类似玩斗地主的题 原题传送门-&gt;-&gt; 输入格式输入有两行： 第一行一个正整数n，表示队员数量。第二行有n 个整数，第i 个整数a[i]表示第i 个队员的实力。 输出格式输出一行，包括一个正整数，表示人数最少的组的人数最大值。 输入输出样例输入 #1 74 5 2 3 -4 -3 -5 输出 #1 3 说明/提示【样例解释】 分为2 组，一组的队员实力值是{4, 5, 2, 3},一组是{-4, -3, -5}其中最小的组人数为3，可以发现没有比3 更优的分法了。 【数据范围】对于100%的数据满足：1≤n≤10^5，∣a[i]∣≤ 10^9。 本题共10 个测试点，编号为1~10，每个测试点额外保证如下： 1~2 n≤6,1≤a[i]≤1003~4 n ≤ 10^3 ,1≤a[i]≤ 10^5, 且a[i]互不相同5~6 n≤ 10^5,a[i]互不相同 7~8 n≤ 10^5, 1≤a[i]≤10^59~10 n≤ 10^5,∣a[i]∣≤ 10^9 —————————————-分割线———————————————- 分析：大学生还在做初中组的题。。。好吧我一直知道自己是个菜鸡分组规则：要满足递增序列，并且还要保证最小组成员数最大————俺联想到打斗地主里面的连对。问题转化为：手里有一堆牌，怎样才能组成合适的连对？ 比如：五张牌：3、4、5、6、7,可以凑成连对，所以最基本的首先要找递增序列。但是找递增序列显然不能盲目，假如你手里牌是：3、4、5、6、7、7、8、9、10、J（J就是11）。怎么出牌比较好呢？答案应该是：3、4、5、6、7和7、8、9、10、J。这道题的贪心核心就在这里：当发现有相同的数字时，要在合适的地方拆解。再举个例子：3,4,5,6,7,7,8,8,9,9,10,J应该分成：3，4，5，6，7，8，9以及7，8，9，10，J其实就是在从n张到n-1张过渡的地方截取。 我是用map来存储的，第一个值为实力值，第二个值是频次。比如有3人实力为8，那么这个结点就是，当某个小组需要一名实力为8的成员，这个结点就变成， 直到降为后把这个结点删除。 #include&lt;map&gt; #include&lt;iostream&gt; using namespace std; map&lt;int,int&gt; Stu;//实力值，频次 void Input() { int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) { int a; cin &gt;&gt; a; pair&lt;map&lt;int,int&gt;::iterator,int&gt; flag = Stu.insert(pair&lt;int,int&gt;(a,1)); if(!flag.second) ++(flag.first-&gt;second); } } void solve() { int ans = (1 &lt;&lt; 30); while(!Stu.empty()) { int tmp = 1;//tmp记录小组长度 map&lt;int,int&gt;::iterator i = Stu.begin(); pair&lt;int,int&gt;pre = *i; --(i-&gt;second); if(!i-&gt;second) i = Stu.erase(i); else ++i; while(i != Stu.end()) { if(i-&gt;first != ( pre.first + 1)) break; if(i-&gt;second == (pre.second-1)) break; pre = *i; ++tmp; --(i-&gt;second); if(!i-&gt;second) i = Stu.erase(i); else ++i; } if(tmp &lt; ans) ans = tmp; } cout &lt;&lt; ans &lt;&lt; endl; } int main() { Input(); solve(); return 0; }","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"贪心","slug":"贪心","permalink":"/tags/贪心/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"洛谷P3879 [TJOI2010] 阅读理解","slug":"洛谷P3879 [TJOI2010] 阅读理解","date":"2020-07-09T15:18:00.000Z","updated":"2021-02-08T04:37:23.915Z","comments":true,"path":"2020/07/09/洛谷P3879 [TJOI2010] 阅读理解/","link":"","permalink":"/2020/07/09/洛谷P3879 [TJOI2010] 阅读理解/","excerpt":"题目描述：英语老师留了 N 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过","text":"题目描述：英语老师留了 N 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过 原题传送门-&gt;-&gt; 输入格式第一行为整数 N ，表示短文篇数，其中每篇短文只含空格和小写字母。 按下来的 N 行，每行描述一篇短文。每行的开头是一个整数 L ，表示这篇短文由 L 个单词组成。接下来是 L 个单词，单词之间用一个空格分隔。 然后为一个整数 M ，表示要做几次询问。后面有 M 行，每行表示一个要统计的生词。 输出格式对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。 输入输出样例输入 #1 3 9 you are a good boy ha ha o yeah 13 o my god you like bleach narutoone piece and so do i 11 but i do not think you will get all thepoints 5 you i o all naruto 输出 #1 1 2 3 2 3 1 2 3 2 说明/提示 对于 30% 的数据， 1 ≤ M ≤ $10^3$。 对于 100%100\\%100% 的数据，1 ≤ M ≤ $10^4$1 ≤ N ≤ $10^3$ 。 每篇短文长度（含相邻单词之间的空格）≤ $5×10^3$字符，每个单词长度 ≤ 20 字符。 每个测试点时限 2 秒。 —————————————-分割线———————————————- 第一反应是用桶排，如果能把单词表示成一个编码，直接用int数组就可以做了，但是显然，20个字母组成的单词编码的数据会很大。 但我可以想到可以退而求其次：对字母的前两个字母进行编码，编码相同的单词存储到同一个map&lt; string , list&gt;中,string记录单词，list记录单词在哪几个文章中出现。这样的由于前两个字母都一样的单词很少，查找几乎是线性时间就能结束。 建立一个这样的数组存储所有的单词。map","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"散列","slug":"散列","permalink":"/tags/散列/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"洛谷P1127 词链","slug":"洛谷 P1127 词链","date":"2020-07-09T07:40:24.000Z","updated":"2021-02-08T04:37:14.641Z","comments":true,"path":"2020/07/09/洛谷 P1127 词链/","link":"","permalink":"/2020/07/09/洛谷 P1127 词链/","excerpt":"题目描述：如果单词 X 的末字母与单词 Y 的首字母相同，则 X 与 Y 可以相连成 X.Y。（注意：X、Y 之间是英文的句号 .）。例如，单词 dog 与单词 gopher，则 dog 与 gopher 可以相连成 dog.gopher","text":"题目描述：如果单词 X 的末字母与单词 Y 的首字母相同，则 X 与 Y 可以相连成 X.Y。（注意：X、Y 之间是英文的句号 .）。例如，单词 dog 与单词 gopher，则 dog 与 gopher 可以相连成 dog.gopher 原题传送门-&gt;-&gt; 另外还有一些例子：• dog.gopher• gopher.rat• rat.tiger• aloha.aloha• arachnid.dog连接成的词可以与其他单词相连，组成更长的词链，例如：aloha.arachnid.dog.gopher.rat.tiger注意到，. 两边的字母一定是相同的。现在给你一些单词，请你找到字典序最小的词链，使得这些单词在词链中出现且仅出现一次。 输入格式：第一行是一个正整数 n（1≤n≤1000），代表单词数量。接下来共有 n 行，每行是一个由 1 到 20 个小写字母组成的单词。 输出格式：只有一行，表示组成字典序最小的词链，若不存在则只输出三个星号 *。 输入输出样例输入 #16alohaarachniddoggopherrattiger输出 #1aloha.arachnid.dog.gopher.rat.tiger 说明/提示• 对于 40% 的数据，有 n≤10；• 对于 100% 的数据， n≤1000。 分析：每个单词都有头字母和尾字母，不难发现，每条词链都有这样的特点：除第一个单词外，其余单词的头字母必然有一个尾字母与其对应。除最后一个单词外，其余单词的尾字母必然有一个头字母与其对应。显然是一个欧拉路问题。 问题转化为： 一张图中有26（即26个字母，允许有孤立点）个结点，n条有向路（即n个单词），寻找一条欧拉路，使得经过的词链最短。 解决前思考的几个小问题：问题1：是否有解？记录每个字母的入度和出度，按照欧拉路的判断方法就可以判断，但是要注意环的存在。 问题2：何时词链字典序最小？注意到”.”的ASCII码为46，小于所有字母的ASCII码，所以ab.ba&lt;ba.ab abcd.de &lt; abcdd.de 其实只要把字典序小的尽量排在前面就OK 问题3：如何快速找到某个点的后继边？最好建立一个索引集。在按字典序将所有字母排序之后，以某个字母为首字母的所有单词都在一个固定区间上 问题4：如何遍历？类似深度优先搜索，每次尽量选择字典序最小的边进行递归。 伪代码： /*伪代码：*/ int main() { Input();//输入数据 sort();//排序 SetPtr();//建立索引集 if(! IsEulerRoad()) //假如不是欧拉路（但由于环的存在，其实并非充分条件,后面还要判断） { cout &lt;&lt; “***” &lt;&lt; endl; return 0; } Travel(); //遍历，并记录答案 Output();//输出 return 0; } 完整AC代码： #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;algorithm&gt; #include&lt;list&gt; using namespace std; string words[1002];//记录所有单词 int mark[1001];//遍历时作标记 int num = 0;//边（即单词）的总数 int Ptr[28]; //索引集，记录words[] 中以26个字母为首字母的第一个单词下标 int Begin;//遍历起点 int ans[1002];//存储遍历路径 int flag = false;//标记是否遍历结束 void SetPtr(); //初始化Ptr void travel(int s,int depth); int InDegree[28];//26个字母的入度 int OutDegree[28];//26个字母的出度 bool IsEulerRoad(); int main() { cin &gt;&gt; num; for(int i = 0; i &lt; num; ++i) { cin &gt;&gt; words[i]; char apple = words[i][0]; char banana = words[i][words[i].size()-1]; ++OutDegree[apple - &#39;a&#39;]; ++InDegree[banana - &#39;a&#39;]; } sort(words,words+num);//按字典序排序 SetPtr(); if(!IsEulerRoad()) { cout &lt;&lt; &quot;***&quot; &lt;&lt; endl; return 0; } travel(Begin,1); if(!flag)//排除回路的干扰。比如输入数据为：2 a b。 { cout &lt;&lt; &quot;***&quot; &lt;&lt;endl; return 0; } cout &lt;&lt; words[ans[0]]; for(int i = 1; i &lt; num; ++i) { cout &lt;&lt; &quot;.&quot; &lt;&lt; words[ans[i]]; } cout &lt;&lt; endl; return 0; } void SetPtr() { int j = 0; for(int i = 0; i &lt; num; ++i) { int k = (char)(words[i][0]) - &#39;a&#39;; if(k &lt; j) continue; while(k &gt; j) { Ptr[j] = i; ++j; } Ptr[j] = i; ++j; } for(;j &lt; 27;++j ) Ptr[j] = num; return; } void travel(int s,int depth) { ans[depth - 1] = s; if(depth == num) { flag = true; return; } mark[s] = 1;//标记 int next = (words[s][words[s].size()-1])-&#39;a&#39;; int start = Ptr[next]; int end = Ptr[next+1];//索引集派上用场 for(int itr = start; itr &lt; end; ++itr)//遍历所有边 { if(!mark[itr]) { travel(itr,depth+1); mark[itr] = 0; if(flag) return;//防止继续循环覆盖掉正确答案 } } } bool IsEulerRoad() { int Count = 0; int In = 0, Out = 0; for(int i = 0; i &lt; 26; ++i) { if(OutDegree[i] != InDegree[i]) { ++Count; if(OutDegree[i] &gt; InDegree[i]) { Out = OutDegree[i] - InDegree[i]; Begin = Ptr[i];//出度大的点应该为起点。假如这句没有执行，说明这张图可能是欧拉图，Begin=0也是正确的; } else { In = InDegree[i] - OutDegree[i]; } } } if(!Count) return true; if(Count != 2) return false; return ((Out == 1)&amp;&amp;(In == 1)); }","categories":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}],"tags":[{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"OJ题解","slug":"OJ题解","permalink":"/tags/OJ题解/"},{"name":"欧拉路","slug":"欧拉路","permalink":"/tags/欧拉路/"},{"name":"数学","slug":"数学","permalink":"/tags/数学/"}],"keywords":[{"name":"OJ题解","slug":"OJ题解","permalink":"/categories/OJ题解/"}]},{"title":"第二类Stirling数","slug":"第二类斯特林数","date":"2020-07-09T07:40:24.000Z","updated":"2021-02-08T04:42:35.590Z","comments":true,"path":"2020/07/09/第二类斯特林数/","link":"","permalink":"/2020/07/09/第二类斯特林数/","excerpt":"第二类Stirling数实际上是集合的一个拆分，表示将n个不同的元素拆分成m个集合的方案数，","text":"第二类Stirling数实际上是集合的一个拆分，表示将n个不同的元素拆分成m个集合的方案数，本文将其记为S(n,m)={n\\brace m} 求解S(n,m)的问题可以等价为解决以下问题：将n个不同的球放入m个无差别的盒子中，要求盒子非空，有几种方案？ 容易得到以下式子：1、{n \\brace 0}=02、{n \\brace 1}=13、{n \\brace n} = 14、{n \\brace 2}= 2^{n-1} - 15、{n \\brace n-1}= C _n^2 这五个式子不足以求解，还需要下面的递推公式：{n\\brace r} = r {n-1 \\brace r} + {n-1\\brace r-1} 如何理解这个公式呢？ 1、我们先将n个球随机标记为1、2、3…n。 2、先将前n-1个球放入r个盒子。放置完成后有两种情况：①每个盒子都有球{n-1\\brace r}②只有一个盒子没有球。{n-1\\brace r-1} 3、再放第n个球①每个盒子已经有球了，由于每个球都是不同的，这r个盒子每个都是独一无二的，所以需要乘以rr {n-1 \\brace r} ②有一个空盒，那么第n个球只能放在这个空盒里 ，不需要再作运算{n-1\\brace r-1}因此得出最后结果{n\\brace r} = r {n-1 \\brace r} + {n-1\\brace r-1}我觉得需要注意的点是：第n个球是随机得来的，没有任何特殊性，所以取球的过程是不需要运算的。 C语言实现： long long Stirling2(int n,int m) { if(n &lt; m) return 0; if(!m) return 0; if(m == 1) return 1; if(m == n) return 1; if(m == 2) return (1 &lt;&lt; (n - 1)) - 1; if(n == m + 1) return n * m / 2; return m * (Stirling2(n - 1,m)) + Stirling2(n - 1,m - 1); }","categories":[{"name":"数学","slug":"数学","permalink":"/categories/数学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"/tags/数学/"},{"name":"集合论","slug":"集合论","permalink":"/tags/集合论/"}],"keywords":[{"name":"数学","slug":"数学","permalink":"/categories/数学/"}]}]}